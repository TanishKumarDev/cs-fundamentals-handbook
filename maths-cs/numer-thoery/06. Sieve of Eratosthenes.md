### **Sieve of Eratosthenes**

**Goal:**
Find all prime numbers up to a given number `n`.

---

### **Why Use It**

Instead of checking each number one by one for primality, we **eliminate multiples** of known primes — making it **much faster**.

---

### **Logic (Step-by-Step)**

Let’s say we want primes up to **20**.

1. Write all numbers from 2 to 20.
   → 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20

2. Start with 2 (first prime).
   → Keep 2, **cut all multiples of 2**: 4, 6, 8, 10, 12, 14, 16, 18, 20

3. Next uncut number: 3.
   → Keep 3, **cut all multiples of 3**: 6, 9, 12, 15, 18

4. Next uncut number: 5.
   → Keep 5, cut 10, 15, 20 (already cut mostly)

5. Continue this process until √n (square root of n).
   For n = 20 → √20 ≈ 4.4 → so check only till 4 (i.e., primes 2 and 3).

6. The remaining uncut numbers are **prime**.

---

### **Final Result (1 to 20):**

2, 3, 5, 7, 11, 13, 17, 19

---

### **Why Stop at √n**

If a number `n` has a factor greater than √n,
then its pair factor is smaller than √n — and already checked.
So, checking beyond √n is useless.

---

### **Time Complexity**

O(n log log n) → much faster than checking one by one (O(n√n)).

---

### **Use Cases**

* **Computer Science:** efficient prime finding for algorithms.
* **Cryptography:** building secure keys using large primes.
* **Mathematics:** number theory, factorization, etc.

---

### **C++ Implementation**

```cpp
#include <bits/stdc++.h>
using namespace std;

void sieve(int n) {
    vector<bool> isPrime(n+1, true);
    isPrime[0] = isPrime[1] = false;

    for (int i = 2; i * i <= n; i++) {
        if (isPrime[i]) {
            for (int j = i * i; j <= n; j += i)
                isPrime[j] = false;
        }
    }

    for (int i = 2; i <= n; i++)
        if (isPrime[i]) cout << i << " ";
}

int main() {
    int n = 30;
    sieve(n);
    return 0;
}
```

---

### **Output**

```
2 3 5 7 11 13 17 19 23 29
```
