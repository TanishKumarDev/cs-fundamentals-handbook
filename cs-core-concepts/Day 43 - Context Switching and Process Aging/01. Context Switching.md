# Context Switching & Process Aging — Operating Systems

---

## 1. Overview

**Context switching** is the mechanism by which the CPU stops executing one process, saves its execution state, and restores the state of another process so the other process can run. It is the fundamental operation that enables **multitasking** and **time-sharing**: multiple processes appear to run concurrently though the CPU executes only one at a time.

**Process aging** is a scheduling technique used to gradually increase the priority of a waiting process so it does not suffer starvation. Together, context switching and aging help the OS share CPU fairly while preventing indefinite postponement of low-priority jobs.

---

## 2. What is Context Switching?

### What it is

* The sequence of operations that **saves the state** (context) of a running process and **loads the state** of another process.
* The “context” typically includes registers, program counter (PC), stack pointer, and scheduling metadata stored in the Process Control Block (PCB).

### Why it exists / why we need it

* To enable **multiprogramming**: let multiple processes share the CPU.
* To implement **preemptive scheduling** (e.g., Round Robin, Priority preemption).
* To respond to **interrupts** (timer, I/O, traps) and switch execution to handlers or higher-priority tasks.

### How it works (high-level steps)

![](https://media.geeksforgeeks.org/wp-content/uploads/20250825182631440618/1223.webp)

1. **Trap / Interrupt / Scheduler Decision**: an event triggers a need to switch (timer tick, higher-priority ready).
2. **Save state of current process**:

   * Save CPU registers, program counter, stack pointer into PCB.
   * Update process state (e.g., Running → Ready or Waiting).
3. **Choose next process**:

   * Short-term scheduler selects a ready process (based on scheduling algorithm).
4. **Load state of chosen process**:

   * Load registers, PC, stack pointer from its PCB into CPU.
   * Change process state to Running.
5. **Resume execution** of the newly loaded process.

### What problem it solves

* Allows fair sharing and isolation of CPU time among many processes.
* Enables the OS to preempt and serve higher-priority or interactive tasks.
* Supports interrupt-driven execution model (I/O, system calls).

### Why this approach (saving/loading state) is better

* Minimal and portable: saving just the CPU-visible state in PCB is sufficient to resume later.
* General: works for both user↔kernel switches and process↔process switches.
* Extensible: OS can save additional architecture-specific state if needed.

---

## 3. Detailed Components & Where Data Lives

### Process Control Block (PCB) — central to context switching

Fields relevant to context switching:

* **Program Counter (PC)** — next instruction address.
* **CPU registers** — general-purpose, status registers.
* **Stack pointer** — location of process stack.
* **Process state** — Running / Ready / Waiting / Suspended.
* **Scheduling info** — priority, counters, queue pointers.
* **Memory info** — page tables or segment descriptors (if needed).
* **I/O and resource info**, accounting, etc.

### Dispatcher

* Small OS component that **actually performs the context switch** (copying registers, switching mode, jumping to user code).
* Its latency is called **dispatch latency** or **context-switch time**.

---

## 4. When Does Context Switching Happen?

* **Timer interrupt** (time slice expired) → preemption for time-sharing.
* **I/O interrupt** (process waits for I/O) → running → waiting.
* **System call** or trap requiring kernel service; may switch to kernel thread or handler.
* **Higher-priority process becomes ready** (preemptive priority scheduling).
* **User / kernel mode switches** (not always a full process switch — may still involve saving subset of state).

---

## 5. Overhead and Performance Considerations

### Overhead

* **Context switch time** is overhead: CPU cycles spent saving/loading context rather than doing useful work.
* Frequent switching can degrade throughput and increase average response time.

### Factors affecting switch time

* **Hardware support**: register sets, fast context pointers reduce cost.
* **Number of registers**: more registers → more to save/restore.
* **Kernel complexity**: more bookkeeping increases time.
* **Memory speed**: writing/reading PCBs to/from memory takes time.
* **Cache effects**: context switch may evict caches, causing cache misses after switch.

### How modern systems reduce overhead

* Hardware context pointers or banks of registers.
* Lazy saving techniques (save only registers that will be used).
* Avoid unnecessary switches by coalescing interrupts or adjusting timer granularity.
* Efficient dispatcher in low-level assembly.

---

## 6. Process Aging (Why & How)

### What it is

* **Aging** is the gradual increase of priority for processes that wait in the ready queue for a long time.

### Why we need it

* Prevents **starvation**: low-priority processes that are repeatedly bypassed eventually get priority boosts and run.
* Balances fairness and responsiveness in priority-based schedulers.

### How it works (common strategies)

* **Incremental priority bump**: every X milliseconds of waiting, increase priority by one level.
* **Timestamp + dynamic priority**: dynamic priority = base_priority − f(wait_time), where f increases with wait_time.
* **Periodic boost**: periodically boost all waiting processes back to higher queues (used in MLFQ).

### Example policy

* Every 100 ms in ready queue → priority = priority − 1 (lower number = higher priority), until top priority is reached.

---

## 7. Example (Illustration & Pseudocode)

### Pseudocode: simplified dispatcher context switch

```cpp
// illustrative pseudo-code (not hardware-level)
struct PCB {
    int pid;
    uint64_t regs[NUM_REGS]; // saved registers
    uint64_t pc;
    uint64_t sp;
    int state; // READY, RUNNING, WAITING
    int priority;
    // ... other fields
};

void context_switch(PCB* old_pcb, PCB* new_pcb) {
    // Called with interrupts disabled (atomic)
    save_cpu_state_to(old_pcb);    // save registers, PC, SP into old PCB
    old_pcb->state = READY;        // or WAITING, depending on reason

    load_cpu_state_from(new_pcb);  // restore registers, PC, SP from new PCB
    new_pcb->state = RUNNING;

    // return to user mode; CPU resumes at new_pcb->pc
}
```

### Illustrative C++-style simulation (conceptual)

```cpp
// This is a simulation for learning; it does not actually change CPU registers.
#include <iostream>
struct PCB { int pid; int pc; int registers[4]; int state; };
void save_state(PCB &p) { /* store simulated register values */ }
void load_state(const PCB &p) { /* restore simulated register values */ }

int main() {
    PCB p0{0, 100, {1,2,3,4}, /*RUNNING*/1};
    PCB p1{1, 200, {5,6,7,8}, /*READY*/0};

    // context switch p0 -> p1
    save_state(p0);
    p0.state = 0;         // READY
    load_state(p1);
    p1.state = 1;         // RUNNING
    std::cout << "Switched to process " << p1.pid << "\n";
}
```

* Use this to illustrate operations, not as system-level code.

---

## 8. Trade-offs, Advantages & Disadvantages

### Advantages

* Enables **multitasking** and fair sharing.
* Allows **responsive systems** (preemption lets interactive tasks run sooner).
* Makes **interrupt-driven I/O** practical.

### Disadvantages / Costs

* **CPU time wasted** in switching (overhead).
* **Cache and TLB pollution**: new process may cause cache/TLB misses.
* **Complexity** in kernel implementation (saving/restoring architecture state).
* Excessive switching can **reduce throughput**.

---

## 9. Practical Tips & Best Practices

* Tune **time slice (quantum)**: very small → high overhead; very large → poor responsiveness.
* Use **hardware support** where available (register windows, fast interrupt controllers).
* Reduce switches by batching I/O handling and minimizing unnecessary preemption.
* Combine with **aging** to avoid starvation in priority schedulers.
* Profile context-switch frequency and latency when diagnosing performance issues.

---

## 10. Relation to Scheduling Policies

* **Round Robin**: relies heavily on context switching each quantum.
* **Priority preemptive**: causes context switches when higher-priority processes arrive.
* **SJF/SRTF**: preemptive SRTF may cause frequent switching for short jobs arriving.
* **MLFQ**: uses promotions/demotions and periodic boosts — context switches required to enforce queue priorities.

---

## 11. Interview Corner

1. **What is a context switch?**

   * Saving the CPU state of one process and restoring another’s state so the CPU can switch execution.

2. **What gets saved during a context switch?**

   * Program counter, CPU registers, stack pointer, CPU flags, and relevant scheduling/memory descriptors (PCB fields).

3. **(Tricky)** Why does context switching cause cache/TLB misses?

   * Because the new process likely has different working sets and page translations; previously cached entries may no longer be useful.

4. **What is dispatch latency?**

   * Time taken by the dispatcher to stop one process and start another (context-switch overhead).

5. **How does hardware reduce context-switch cost?**

   * Register windows, multiple register sets, special instructions for fast save/restore, hardware thread contexts.

6. **Explain process aging. Why is it necessary?**

   * Aging gradually increases priority of waiting processes to avoid starvation in priority-based scheduling.

7. **(Tricky)** If context switching is expensive, why not avoid preemption?**

   * Non-preemptive systems can give bad responsiveness and allow CPU monopolization. Preemption ensures interactivity and fairness despite overhead.

8. **How would you tune time quantum for Round Robin?**

   * Choose quantum ≈ typical interactive response goal (e.g., 10–100 ms) balanced against acceptable context-switch overhead.

9. **What fields in PCB are critical for a context switch?**

   * Register values, PC, SP, process state, and memory context (page tables) if switching address spaces.

---

## 12. Notes & Takeaways

* **Context switching** is indispensable for multitasking but carries a measurable **cost**.
* Keep **time-slice** moderate: too short → too many switches; too long → poor responsiveness.
* **Process aging** is the standard fix to avoid starvation in priority schedulers.
* Effective OS design balances **switch frequency, latency, and fairness** using both software policies and hardware features.
* When optimizing systems, measure **switch latency**, **frequency**, and **cache/TLB impacts** to find real bottlenecks.
