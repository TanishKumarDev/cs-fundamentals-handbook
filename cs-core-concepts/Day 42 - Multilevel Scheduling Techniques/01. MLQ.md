# **Multilevel Queue (MLQ) CPU Scheduling**

**Definition:**
Multilevel Queue Scheduling is a CPU scheduling technique where processes are **divided into multiple queues** based on characteristics like priority, process type, or resource requirements. Each queue has its **own scheduling algorithm** and **priority level**.

Once assigned, a process **remains in its queue** permanently.

![](https://media.geeksforgeeks.org/wp-content/uploads/20250826144547620717/high_priority.webp)

---

## **Key Features**

1. **Multiple Queues:**
   Processes are grouped by type:

   * **System Processes**
   * **Interactive Processes**
   * **Batch Processes**

2. **Queue Priorities:**

   * Higher-priority queues get CPU before lower-priority queues.
   * Examples:

     * Queue 1 (System) > Queue 2 (Interactive) > Queue 3 (Batch)

3. **Preemption:**

   * A higher-priority process can preempt a lower-priority process.

4. **Different Scheduling Algorithms:**

   * Each queue can have its own scheduling method:

     * Queue 1 → Round Robin
     * Queue 2 → Round Robin
     * Queue 3 → FCFS / SJF

5. **Feedback / Time-Slicing:**

   * Some MLQ systems adjust CPU allocation among queues:

     * Example: Queue 1 → 50% CPU, Queue 2 → 30%, Queue 3 → 20%

6. **Efficient CPU Utilization:**

   * High-priority processes run first.
   * Lower-priority processes get CPU only when higher queues are empty (or via time-slicing).

---

## **Scheduling Among Queues**

**Two main methods:**

1. **Fixed Priority Preemptive Scheduling:**

   * CPU always serves **higher-priority queues first**.
   * Example: Queue 3 (batch) is preempted if Queue 1 or 2 has processes.

2. **Time-Slicing Across Queues:**

   * Each queue gets a **fixed portion of CPU time**.
   * Within a queue, processes are scheduled by that queue’s algorithm.

---

## **Example**

| Process | Queue | Scheduling Algorithm |
| ------- | ----- | -------------------- |
| P1      | 1     | Round Robin          |
| P2      | 2     | FCFS                 |
| P3      | 3     | SJF                  |

**Execution Rules:**

* CPU serves **Queue 1** first (P1 → RR).
* Once Queue 1 is empty, CPU moves to **Queue 2** (P2 → FCFS).
* Finally, CPU executes **Queue 3** (P3 → SJF).

This ensures **fast response for interactive/system processes**, while **batch processes complete eventually**.

---

## **Advantages**

1. Organizes processes into **distinct queues** for easier management.
2. **Predictable scheduling** due to fixed priorities.
3. **Improved response time** for interactive/system processes.
4. Suitable for systems with **diverse workloads**.
5. Ensures **critical processes are not delayed**.

---

## **Disadvantages**

1. CPU may remain **idle** if high-priority queues are empty but lower queues are waiting.
2. Processes **cannot move between queues**, reducing flexibility.
3. **Multiple queues increase bookkeeping** overhead.
4. Some queues may **dominate CPU time**, starving others.
5. Fixed queues reduce adaptability in **dynamic workloads**.
