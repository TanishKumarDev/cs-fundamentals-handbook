# **Multilevel Feedback Queue (MLFQ) CPU Scheduling**

**Definition:**
MLFQ Scheduling is an **advanced version of Multilevel Queue (MLQ) Scheduling** where processes **can move between queues** based on their behavior and CPU usage. This makes it **more flexible and efficient** than MLQ scheduling.

---

## **Key Features**

1. **Multiple Queues:**

   * Similar to MLQ, processes are divided into multiple queues based on priority.
   * **Unlike MLQ, processes can move between queues** depending on their execution behavior.

2. **Dynamic Priority Adjustment:**

   * Process priority is **adjusted dynamically**:

     * If a process uses too much CPU time → moved to lower-priority queue.
     * If a process waits too long in a lower-priority queue → can be promoted to higher-priority queue.

3. **Time-Slicing:**

   * Each queue has a **time quantum**:

     * Example: Queue 1 → 4 units, Queue 2 → 8 units, Queue 3 → FCFS.
   * If a process doesn’t finish within the time quantum, it is **shifted to a lower-priority queue**.

4. **Feedback Mechanism:**

   * The system **monitors process behavior** to adjust priorities and optimize CPU utilization.
   * Helps in **predicting future CPU needs** based on past execution.

5. **Preemption:**

   * Higher-priority processes can **preempt lower-priority processes** to ensure fairness and responsiveness.

---

## **Execution Rules**

1. A process is initially assigned to a queue based on **priority** or type:

   * High-priority → Queue 1
   * Background/low-priority → Queue 3

2. **Queue 1 Execution:**

   * Runs for 4 units (example).
   * If incomplete, moves to Queue 2.

3. **Queue 2 Execution:**

   * Runs for 8 units (example).
   * If incomplete, moves to Queue 3.

4. **Queue 3 Execution:**

   * FCFS scheduling (can also be RR).
   * Executes only if higher-priority queues are empty.

5. **Priority Boosting:**

   * To prevent starvation, processes in lower-priority queues may **periodically be promoted** to the highest-priority queue.

---

## **Advantages**

1. **Flexible:** Processes can move between queues based on behavior.
2. **Prevents Starvation:** Long-waiting processes are promoted.
3. **Optimizes Turnaround Time:** Learns process behavior and adapts, e.g., short CPU-bound processes finish faster.
4. **Improves Response Time:** Interactive/high-priority processes get quicker CPU access.

---

## **Disadvantages**

1. **Complex Algorithm:** Requires more careful implementation.
2. **High CPU Overhead:** Frequent queue changes and preemption increase overhead.
3. **Parameter Selection Required:** Needs careful choice of time quanta, queue levels, and boost intervals.

---

## **Example**

**Problem:**

* CPU-bound process requires 40 seconds.
* Queue time quantum starts at 2 seconds and **increases by 5 seconds at each level**.

**Execution:**

| Queue | Time Quantum | Execution | Status           |
| ----- | ------------ | --------- | ---------------- |
| 1     | 2 s          | 2 s       | Moves to Queue 2 |
| 2     | 7 s          | 7 s       | Moves to Queue 3 |
| 3     | 12 s         | 12 s      | Moves to Queue 4 |
| 4     | 17 s         | 17 s      | Moves to Queue 5 |
| 5     | 2 s          | 2 s       | Completed        |

* **Interruptions:** 4 times
* **Completion:** Queue 5

---

MLFQ is essentially **“learning from past process behavior”** to schedule CPU time efficiently, making it ideal for **time-sharing and interactive systems**.

