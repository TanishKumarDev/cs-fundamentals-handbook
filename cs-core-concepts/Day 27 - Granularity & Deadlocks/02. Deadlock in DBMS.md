# **Day 27 – Granularity & Deadlocks**

---

## **Article 2: Deadlock in DBMS**

---

### **1. Overview**

A **deadlock** occurs when **two or more transactions block each other indefinitely**, each waiting for a resource held by the other.
This creates a **circular wait** where none of the transactions can proceed.

**Example:**

* `T1` locks *Student* and needs *Grade*
* `T2` locks *Grade* and needs *Student*
  → Both wait for each other → **Deadlock**

---

### **2. Necessary Conditions for Deadlock**

A deadlock can occur only if **all four** of these conditions hold true:

| Condition            | Meaning                                                      |
| -------------------- | ------------------------------------------------------------ |
| **Mutual Exclusion** | Only one transaction can use a resource at a time.           |
| **Hold and Wait**    | A transaction holding resources can request more.            |
| **No Preemption**    | A resource cannot be forcibly taken away.                    |
| **Circular Wait**    | A cycle of transactions exists where each waits for another. |

---

### **3. Why Deadlocks Are a Problem**

* Transactions **never complete** — system gets stuck.
* **Throughput decreases** due to blocked operations.
* **Resources remain locked**, reducing concurrency.
* May cause **performance degradation** or even **system-wide halt**.

---

### **4. Real-Life Example**

| Transaction | Operation                                     | Status  |
| ----------- | --------------------------------------------- | ------- |
| **T1**      | Locks rows in *Students*, then wants *Grades* | Waiting |
| **T2**      | Locks rows in *Grades*, then wants *Students* | Waiting |

Both transactions wait for each other → **Deadlock situation** → All DB activity halts.

---

### **5. Handling Deadlocks**

DBMS uses **three main techniques** to handle deadlocks:

---

#### **A. Deadlock Avoidance**

Prevent deadlocks by **planning transactions carefully**.

**Methods:**

1. Access resources in a **consistent order** (e.g., always lock *Students* before *Grades*).
2. Use **row-level locking** and **READ COMMITTED isolation** to reduce (not eliminate) chances.

---

#### **B. Deadlock Detection**

Detect if deadlock already occurred using **Wait-For Graph**.

**Concept:**

* **Nodes:** Transactions
* **Edges:** "T1 waits for T2" relationships
* **Cycle present → Deadlock exists**

**Used for:** Small to medium databases where periodic checking is affordable.

---

#### **C. Deadlock Prevention**

Ensure deadlocks **never occur** by controlling how resources are allocated.
Used mostly in **large databases**.

Two common prevention schemes:

| Scheme         | Type           | Rule                                           | Behavior                           |
| -------------- | -------------- | ---------------------------------------------- | ---------------------------------- |
| **Wait-Die**   | Non-preemptive | Older transactions wait, younger ones abort    | Prevents younger waiting for older |
| **Wound-Wait** | Preemptive     | Older transactions preempt (kill) younger ones | Older never waits for younger      |

---

### **6. Wait-Die Scheme (Non-Preemptive)**

* **Older waits**, **younger dies** (aborts and restarts).
* Prevents circular wait by not allowing younger transactions to wait.

**Example:**

* T1 = 10 (older), T2 = 20 (younger)
* If T1 wants T2’s resource → **T1 waits**
* If T2 wants T1’s resource → **T2 dies and restarts**

**Drawbacks:** More aborts and rollbacks.

---

### **7. Wound-Wait Scheme (Preemptive)**

* **Older wounds (kills)** younger and takes the resource.
* **Younger waits** if it needs an older’s resource.

**Example:**

* T1 = 10 (older), T2 = 20 (younger)
* If T1 wants T2’s resource → **T2 is killed**
* If T2 wants T1’s resource → **T2 waits**

**Advantages:** Fewer aborts and rollbacks.

---

### **8. Wait-Die vs Wound-Wait Comparison**

| Feature             | Wait-Die       | Wound-Wait  |
| ------------------- | -------------- | ----------- |
| Type                | Non-preemptive | Preemptive  |
| Older Transaction   | Waits          | Never waits |
| Younger Transaction | Dies (aborts)  | Waits       |
| Rollbacks           | Higher         | Fewer       |
| Efficiency          | Lower          | Higher      |

---

### **9. Applications Affected by Deadlock**

* **Delayed Transactions:** remain blocked indefinitely.
* **Lost Transactions:** aborted or rolled back.
* **Reduced Concurrency:** fewer simultaneous operations.
* **High Resource Usage:** idle but locked resources.
* **Poor User Experience:** lag, freeze, or system halt.

---

### **10. Summary**

A **deadlock** is a circular waiting situation where transactions are indefinitely blocked.
It requires **Mutual Exclusion**, **Hold and Wait**, **No Preemption**, and **Circular Wait** to occur.
Handled by:

* **Avoidance:** plan execution order.
* **Detection:** identify cycles using wait-for graph.
* **Prevention:** use **Wait-Die** or **Wound-Wait** schemes.

Efficient deadlock handling ensures **smooth transaction execution** and **high concurrency** in database systems.
