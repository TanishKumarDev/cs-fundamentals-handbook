# **Day 27 – Granularity & Deadlocks**

---

## **Article 1: Multiple Granularity Locking in DBMS**

### **1. Overview**

Granularity refers to the **size of the data item** on which a lock is applied.
**Multiple Granularity Locking (MGL)** allows locks to be applied at **different levels** of a hierarchy (e.g., database → area → file → record) to balance **concurrency** and **efficiency**.

---

### **2. Granularity Hierarchy**

A typical locking hierarchy is structured as a **tree**:

```
Database  
 └── Area  
      └── File  
           └── Record
```

* **Database:** entire DB
* **Area:** logical sections
* **File:** groups of records
* **Record:** individual entries

When a transaction locks a node, **all its descendants are implicitly locked**.

**Example:**
If transaction `T1` locks file `Fc` in **Exclusive (X)** mode, all its records are automatically locked in X mode.

---

### **3. Intention Lock Modes**

To manage locks efficiently in the hierarchy, **intention locks** are introduced:

| Lock Mode                              | Meaning                                                              |
| -------------------------------------- | -------------------------------------------------------------------- |
| **IS (Intention Shared)**              | Intends to acquire shared locks at a lower level.                    |
| **IX (Intention Exclusive)**           | Intends to acquire exclusive or shared locks at a lower level.       |
| **SIX (Shared + Intention Exclusive)** | Locks current node in shared mode and lower nodes in exclusive mode. |

These locks allow transactions to **coexist safely** without unnecessary blocking.

---

### **4. Lock Compatibility Matrix (Conceptual Overview)**

* **S** and **IS** are compatible (both shared reads).
* **X** is incompatible with all others.
* **IX** and **SIX** limit simultaneous access depending on intent type.

---

### **5. Locking Protocol Rules**

Transactions must follow specific **locking and unlocking rules**:

1. **Lock root first** (in any mode).
2. To acquire **S or IS**, parent must be in **IS/IX**.
3. To acquire **X, IX, or SIX**, parent must be in **IX or SIX**.
4. Locks acquired **top-down (root → leaf)**.
5. Locks released **bottom-up (leaf → root)**.
6. A node can be unlocked only after all its children are unlocked.
7. Transactions must follow the **Two-Phase Locking (2PL)** protocol.

---

### **6. Example Transactions**

| Transaction | Operation                          | Locks Acquired                                            |
| ----------- | ---------------------------------- | --------------------------------------------------------- |
| **T1**      | Reads record `Ra2` in file `Fa`    | Database (IS), Area A1 (IS), File Fa (IS), Record Ra2 (S) |
| **T2**      | Modifies record `Ra9` in file `Fa` | Database (IX), Area A1 (IX), File Fa (IX), Record Ra9 (X) |
| **T3**      | Reads all records in file `Fa`     | Database (IS), Area A1 (IS), File Fa (S)                  |
| **T4**      | Reads entire database              | Database (S)                                              |

**Concurrency Analysis:**

* `T1`, `T3`, and `T4` can run **concurrently**.
* `T2` can run **with T1**, but **not with T3 or T4** due to conflicting lock types.

---

### **7. Advantages**

* **Improves concurrency** by enabling fine or coarse-grained locks.
* **Reduces lock overhead** by avoiding unnecessary child-level locks.
* **Provides flexibility** in transaction control.

---

### **8. Limitations**

* **Deadlocks are still possible** under this scheme.
* Requires careful **hierarchical lock management**.

---

### **9. Summary**

Multiple Granularity Locking allows a transaction to apply locks at **different levels** of a hierarchical structure.
By introducing **intention locks** and **structured locking rules**, it balances **efficiency** and **concurrency**, though **deadlocks can still occur** and need separate handling mechanisms.
