# **Day 46 – Multithreading And Models**

---

## **1. Introduction**

**Multithreading** is a technique where a **process is divided into smaller execution units called threads** that can run concurrently.

* A **thread** is also called a **lightweight process**.
* Threads within a process share **CPU, memory, and I/O resources**, but have **individual execution contexts** (stack, program counter, registers).

**Why Multithreading?**

* Improves **system performance**
* Increases **responsiveness**
* Enables **parallelism (increase throughput) and concurrency (deal with lots of tasks at once)** - both are different concepts
* Reduces **resource overhead** compared to multiple processes

**Example:**

* **Browser:** Each tab or rendering task runs as a separate thread.
* **MS Word:** One thread formats text while another handles user input.

---

## **2. Multithreading Models**

Threads are implemented using **user-level threads (ULTs)** and **kernel-level threads (KLTs)**.
The **mapping between user threads and kernel threads** defines the multithreading model.

There are **three main models**:

---

### **2.1 Many-to-One Model**


* **Description:** Multiple user threads mapped to **one kernel thread**.
* **Mechanism:**

  * Thread management is done at **user level**.
  * Kernel is unaware of multiple threads.
* **Advantages:** Efficient, low overhead.
* **Disadvantages:**

  * **Blocking limitation:** If one thread makes a blocking system call, **all threads block**.
  * Cannot utilize **multiprocessor systems** (only one kernel thread).

**Diagram Concept:**
![](https://media.geeksforgeeks.org/wp-content/uploads/20250819122313048589/many_to_one_multithreading_model.webp)

---

### **2.2 One-to-One Model**

* **Description:** Each **user thread** maps to **one kernel thread**.
* **Advantages:**

  * True **parallelism** on multi-core CPUs.
  * **Blocking calls** don’t stop other threads.
  * Better **multiprocessor utilization**.
* **Disadvantages:**

  * Creating a new thread requires **corresponding kernel thread** → higher overhead.

**Diagram Concept:**

![](https://media.geeksforgeeks.org/wp-content/uploads/20250819122350089315/one_to_one_multithreading_model.webp)

**This is the most commonly used model in modern OS (Windows, Linux).**

---

### **2.3 Many-to-Many Model**

* **Description:** Multiple user threads mapped to **many kernel threads** (N:M mapping).
* **Advantages:**

  * If a user thread is blocked, **other threads can still run**.
  * Can achieve **high concurrency** and **multiprocessor utilization**.
* **Disadvantages:**

  * More **complex implementation**.
  * Requires careful mapping and management of kernel threads.

**Diagram Concept:**

**Diagram Concept:**
![](https://media.geeksforgeeks.org/wp-content/uploads/20250819122157173383/many_to_many_multithreading_model.webp)


**Best for:** Systems that require **flexibility and high concurrency**, but less common in practice than one-to-one.

---

## **3. How Threads Work Without OS Support**

* **Example:** Java threads managed by JVM.
* JVM handles thread creation, scheduling, and context switching internally.
* The **OS sees the process as single-threaded**, not aware of internal threads.

---

## **4. Applications of Multithreading**

| Application Area                  | Example                                                            |
| --------------------------------- | ------------------------------------------------------------------ |
| **Transaction Processing**        | Banking, online payments, mobile recharges                         |
| **Web and Internet Applications** | Web servers, chat servers, API calls                               |
| **Banking & Financial Systems**   | Fund transfers, balance updates, background verification           |
| **Telecom & Recharge Services**   | Simultaneous service requests, fast response for millions of users |

**Real-life Example:**
A web server uses threads to handle multiple client requests concurrently. While one thread waits for I/O, others can process new requests.

---

## **5. C++ Code Example – Multithreading**

```cpp
#include <bits/stdc++.h>
#include <thread>
using namespace std;

void processRequest(int id) {
    cout << "Processing request: " << id << " on thread ID: " 
         << this_thread::get_id() << endl;
    this_thread::sleep_for(chrono::milliseconds(500));
}

int main() {
    vector<thread> threads;

    // Spawn 5 threads
    for (int i = 1; i <= 5; i++) {
        threads.push_back(thread(processRequest, i));
    }

    // Wait for all threads to finish
    for (auto &t : threads) {
        t.join();
    }

    cout << "All requests processed!" << endl;
    return 0;
}
```

**Explanation:**

* Creates **5 threads** to simulate concurrent requests.
* `this_thread::get_id()` shows the **thread identifier**.
* Threads run in **parallel**, sharing memory and resources.

---

## **6. Advantages of Multithreading**

1. Improved **performance** and throughput.
2. Better **CPU utilization** on multi-core systems.
3. Efficient **resource sharing**.
4. Faster **context switching** than processes.
5. Increased **responsiveness** of applications.

---

## **7. Disadvantages**

1. **Complex debugging and testing**.
2. Risk of **race conditions** if shared data isn’t synchronized.
3. Threads may cause **deadlocks** if not managed carefully.
4. High number of threads may **overload kernel** in one-to-one model.

---

## **8. Summary Table – Multithreading Models**

| Model        | User Threads → Kernel Threads | Blocking Issue | Multiprocessor Support | Usage                   |
| ------------ | ----------------------------- | -------------- | ---------------------- | ----------------------- |
| Many-to-One  | Many → 1                      | Yes            | No                     | Rare                    |
| One-to-One   | 1 → 1                         | No             | Yes                    | Common (Linux, Windows) |
| Many-to-Many | Many → Many                   | No             | Yes                    | Flexible but complex    |
