# **Day 45 – Threads in Operating Systems**

---

## **1. Introduction**

A **thread** is the **smallest unit of CPU execution** within a process.
Threads are also called **lightweight processes (LWP)** because they share most of their resources with their parent process but have their own execution context.

While a **process** represents an independent program, a **thread** represents a single path of execution within that program.

![](https://media.geeksforgeeks.org/wp-content/uploads/20250829104433669224/multithreading-in-os.png)
---

## **2. What is a Thread?**

A **thread** is a sequence of instructions that can be executed independently within a process.
Every process has at least one thread — the **main thread** — and can create more threads for parallel execution.

### **Key Properties**

* Each thread has:

  * **Thread ID**
  * **Program Counter (PC)**
  * **Register Set**
  * **Stack**
* All threads of a process share:

  * **Code segment**
  * **Data segment**
  * **Heap**
  * **Files and I/O resources**

---

## **3. Why Threads? (Need & Importance)**

Threads allow programs to **perform multiple tasks concurrently**, leading to improved **performance and responsiveness**.

| Benefit                    | Description                                                             |
| -------------------------- | ----------------------------------------------------------------------- |
| **Concurrency**            | Multiple threads can run tasks simultaneously (e.g., UI + computation). |
| **Parallelism**            | On multi-core CPUs, threads can truly run in parallel.                  |
| **Responsiveness**         | Keeps applications responsive even during long operations.              |
| **Resource Sharing**       | Threads share memory and files, unlike separate processes.              |
| **Faster Context Switch**  | Switching between threads is faster than switching between processes.   |
| **Better CPU Utilization** | Multiple threads utilize all CPU cores effectively.                     |

---

## **4. Example: Threads in Real Life**

Example — **Web Browser:**

* Thread 1: Renders UI
* Thread 2: Fetches data from network
* Thread 3: Handles user input
* Thread 4: Plays media

All these run concurrently under the same process (`chrome.exe`).

---

## **5. Components of a Thread**

Each thread has its own:

| Component                      | Description                                       |
| ------------------------------ | ------------------------------------------------- |
| **Program Counter**            | Holds address of next instruction.                |
| **Register Set**               | Keeps temporary data and execution state.         |
| **Stack**                      | Stores local variables and function calls.        |
| **Thread Control Block (TCB)** | Stores info like thread ID, state, priority, etc. |

---

## **6. Threads vs Processes**

| Feature       | Process                           | Thread                               |
| ------------- | --------------------------------- | ------------------------------------ |
| Definition    | Independent program in execution  | Lightweight sub-unit of a process    |
| Memory        | Separate memory space             | Shared memory space                  |
| Overhead      | High                              | Low                                  |
| Communication | Inter-Process Communication (IPC) | Shared memory (faster)               |
| Creation time | Slow                              | Fast                                 |
| Example       | `chrome.exe`, `code.exe`          | Rendering, Input, Networking threads |

---

## **7. Types of Threads**

![](https://media.geeksforgeeks.org/wp-content/uploads/20240226115304/Threads.png)


Threads can be implemented at **two levels**:

### **1. User-Level Threads (ULT)**

* Managed **in user space** by thread libraries (e.g., `pthread`, Java threads).
* The **kernel** is unaware of them.
* Context switch is **fast** (no kernel involvement).
* **Drawback:** If one thread blocks, the entire process blocks.

**Example:** Old Java Green Threads, POSIX user threads.

---

### **2. Kernel-Level Threads (KLT)**

* Managed **directly by the OS kernel**.
* Each thread is known to the kernel.
* True **parallel execution** on multiple CPUs.
* Handles **blocking** efficiently (kernel schedules another thread).

**Drawback:** Context switch is **slower** (requires kernel mode switch).

---

### **3. Hybrid Model**

Combines advantages of both —
User-level threads are mapped to kernel threads (N:M mapping).

---

## **8. Thread Models**

| Model            | Description                             | Example                 |
| ---------------- | --------------------------------------- | ----------------------- |
| **Many-to-One**  | Many user threads → One kernel thread   | No true parallelism     |
| **One-to-One**   | Each user thread → One kernel thread    | Windows, Linux          |
| **Many-to-Many** | Many user threads ↔ Many kernel threads | Solaris, Modern systems |

---

## **9. Thread Management**

Each thread’s state and context are managed through **Thread Control Block (TCB)**.

| Field         | Description             |
| ------------- | ----------------------- |
| Thread ID     | Unique identifier       |
| State         | Ready, Running, Waiting |
| Stack Pointer | Points to top of stack  |
| Registers     | Current execution data  |
| Priority      | Scheduling priority     |

---

## **10. Code Example – Multithreading in C++**

```cpp
#include <bits/stdc++.h>
#include <thread>
using namespace std;

void printNumbers(int n) {
    for (int i = 1; i <= n; i++) {
        cout << "Thread 1: " << i << endl;
    }
}

void printLetters() {
    for (char c = 'A'; c <= 'E'; c++) {
        cout << "Thread 2: " << c << endl;
    }
}

int main() {
    thread t1(printNumbers, 5);  // Thread 1
    thread t2(printLetters);     // Thread 2

    t1.join();  // Wait for t1 to finish
    t2.join();  // Wait for t2 to finish

    cout << "Main thread done!" << endl;
    return 0;
}
```

### **Explanation**

* Two threads (`t1`, `t2`) run concurrently.
* Threads share the same address space but have separate stacks.
* `join()` ensures both threads complete before program ends.

---

## **11. Thread Synchronization (Preview)**

When multiple threads share data, **race conditions** can occur.
To handle this, OS provides **synchronization mechanisms**:

* Mutex Locks
* Semaphores
* Monitors
* Condition Variables

(You’ll cover these in next topics.)

---

## **12. Advantages of Multithreading**

1. Enhanced performance on multi-core systems.
2. Better application responsiveness.
3. Efficient resource utilization.
4. Faster context switching.
5. Simplified sharing of memory and data.

---

## **13. Disadvantages of Multithreading**

1. Complex debugging and synchronization.
2. Risk of race conditions and deadlocks.
3. Requires careful design for shared resources.
4. High number of threads may degrade performance.

---

## **14. MCQs on Threads**

### **Q1.** What is a thread?

A. Program in execution
B. Independent memory block
C. Lightweight process
D. Process scheduler

✅ **Answer:** C — Lightweight process.

---

### **Q2.** Which of these is shared by all threads in a process?

A. Stack
B. Registers
C. Code and Data
D. Program Counter

✅ **Answer:** C — Code and Data segment.

---

### **Q3.** Each thread has its own:

A. Stack and Program Counter
B. Data segment
C. Code segment
D. File descriptor

✅ **Answer:** A — Stack and PC.

---

### **Q4.** User-level threads are managed by:

A. Kernel
B. Thread library in user space
C. Hardware
D. BIOS

✅ **Answer:** B — User space library.

---

### **Q5.** Which is true for Kernel-Level Threads?

A. Kernel is unaware of threads
B. Each thread is scheduled independently
C. Context switch is faster
D. One thread blocks all

✅ **Answer:** B — Kernel schedules threads independently.

---

### **Q6.** Which model allows true parallelism?

A. Many-to-One
B. One-to-One
C. Single-Threaded
D. None

✅ **Answer:** B — One-to-One model.

---

### **Q7.** Context switching between threads is:

A. Slower than process
B. Faster than process
C. Same as process
D. None

✅ **Answer:** B — Faster.

---

### **Q8.** In which thread type, if one thread blocks, all block?

A. User-Level Thread
B. Kernel-Level Thread
C. Hybrid Thread
D. Multiprocessor Thread

✅ **Answer:** A — ULT.

---

### **Q9.** Which of the following is NOT shared among threads?

A. Heap
B. Stack
C. Code
D. Files

✅ **Answer:** B — Stack.

---

### **Q10.** Thread Control Block stores:

A. Only PID
B. Only Stack
C. Thread state and context info
D. Entire process memory

✅ **Answer:** C — Thread state and context info.

---

### **Q11.** Which of the following best defines a lightweight process?

A. Process
B. Thread
C. PCB
D. Kernel

✅ **Answer:** B — Thread.

---

### **Q12.** Threads belonging to the same process share:

A. Stack
B. Registers
C. Memory and resources
D. None

✅ **Answer:** C — Memory and OS resources.

---

## **15. Summary Table**

| Category       | Process     | Thread         |
| -------------- | ----------- | -------------- |
| Memory Space   | Separate    | Shared         |
| Creation Time  | High        | Low            |
| Communication  | IPC         | Shared memory  |
| Switching Time | Slow        | Fast           |
| Dependency     | Independent | Interdependent |

---

## **16. Final Notes**

* Threads are the **core of modern multitasking**.
* Understanding **thread models** and **synchronization** is key for OS and concurrency questions.
* Practical thread creation (as shown in code) builds the intuition behind **multithreaded programs** in C++, Java, and OS design.
