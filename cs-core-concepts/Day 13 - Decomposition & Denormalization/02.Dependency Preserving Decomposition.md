# **Day 13 — Dependency Preserving Decomposition (DBMS)**

## **Definition**

In a **DBMS**, a **dependency-preserving decomposition** is the process of breaking a **complex relation** into smaller relations such that:

* **All functional dependencies (FDs) of the original relation are preserved**.
* No additional joins are needed to enforce the original dependencies.
* Helps **minimize redundancy**, **avoid anomalies**, and **improve query efficiency**.

> Goal: Decompose tables without losing the ability to enforce the original FDs.

---

## **Conditions for Dependency-Preserving Decomposition**

Suppose:

* **R** = original relation
* **F** = set of FDs on R
* **R1, R2, …, Rn** = decomposed relations
* **F1, F2, …, Fn** = FDs in R1, R2, …, Rn respectively

Decomposition is **dependency-preserving** if:

[
F' = F1 ∪ F2 ∪ ... ∪ Fn
]
and

[
F'^{+} = F^{+}
]

* This means **all original FDs can be derived** from the FDs in decomposed relations.
* If any FD from F is lost, the decomposition is **not dependency-preserving**.

---

## **Example 1**

**Original Relation:**

| StudentID | CourseID | Instructor |

**Functional Dependencies (F):**

* `CourseID → Instructor`
* `StudentID, CourseID → Instructor`

**Decomposition:**

### **Case 1: FDs preserved**

* R1(StudentID, CourseID): `f1 = {StudentID, CourseID → Instructor}`
* R2(CourseID, Instructor): `f2 = {CourseID → Instructor}`

✅ **f1 ∪ f2 = F** → Dependency-preserving

---

### **Case 2: FDs lost**

* R1(StudentID, CourseID): `f1 = {StudentID, CourseID → Instructor}`
* R2(CourseID, Instructor): `f2 = { }`

❌ **f1 ∪ f2 ⊂ F** → Not dependency-preserving (FD `CourseID → Instructor` is missing)

---

### **Case 3: Extra dependencies**

* R1(StudentID, CourseID): `f1 = {CourseID → Instructor}`
* R2(CourseID, Instructor): `f2 = {Instructor → CourseID}`

⚠ **f1 ∪ f2 ⊃ F** → Extra FDs exist. Doesn’t break dependency preservation directly but may cause confusion.

---

## **Key Concepts**

1. **Functional Dependency Preservation:**
   All original FDs must still hold in decomposed relations.

2. **Lossless Join Property:**
   Decomposition must allow reconstructing the original relation **without data loss**.

3. **Normalization:**
   Often done to achieve **3NF or BCNF** while preserving dependencies.

4. **Minimal Redundancy:**
   Reduces unnecessary repetition of data, avoids anomalies.

---

## **Example 2**

**Original Relation:**

```
R(A, B, C, D)  
FDs: {AB → C, C → D, D → A}
```

**Decomposition:**

* R1(A, B, C)
* R2(C, D)

**Step 1: Find closures of FDs in each relation**

* **F1 in R1:**

  * (A)+ = {A}
  * (B)+ = {B}
  * (C)+ = {C, A}  // D not in R1
  * (AB)+ = {A, B, C}
  * (BC)+ = {B, C, A}
  * F1 = {C → A, AB → C, BC → A}

* **F2 in R2:**

  * F2 = {C → D}

**Step 2: Check if all original FDs are preserved**

* Original FDs: {AB → C, C → D, D → A}
* AB → C ✅ (in F1)
* C → D ✅ (in F2)
* D → A ❌ (not preserved in any relation)

❌ **Conclusion:** Not dependency-preserving

---

## **Benefits of Dependency-Preserving Decomposition**

1. **Eliminates Redundancy:** Smaller, efficient tables.
2. **Maintains Integrity:** Preserves original FDs, avoiding anomalies.
3. **Improves Query Performance:** Smaller tables are faster to process.
4. **Simplifies Updates:** Updates easier and consistent.

---

## **Algorithms**

1. **BCNF Decomposition:**
   Decompose relation into smaller relations in **BCNF** while trying to preserve dependencies.

2. **3NF Decomposition:**
   Decompose relation into **3NF** tables; often guarantees dependency preservation.

> Choice depends on DB requirements and balance between normalization, dependency preservation, and query performance.

---

### **Summary**

* **Dependency-preserving decomposition** ensures FDs are not lost during decomposition.
* Must also be **lossless** to guarantee no data loss.
* Crucial for **efficient, reliable, and consistent database design**.
* BCNF and 3NF are common algorithms to achieve this.
