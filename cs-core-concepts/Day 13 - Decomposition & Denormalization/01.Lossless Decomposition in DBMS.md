# **Day 13 — Decomposition & Denormalization**

## **Lossless Decomposition**

### **Definition**

In **DBMS**, a **lossless decomposition** is a process where a relation schema **R** is decomposed into two or more relations (**R1, R2, ...**) such that:

* No information is lost.
* The **natural join** of the decomposed relations produces **exactly the original relation**.
* No extra or missing tuples are introduced.

> Purpose: Ensures data consistency while optimizing storage and structure.

---

### **How to Check for Lossless Decomposition**

Suppose a relation **R(A, B, C, D)** is decomposed into:

* **R1(A, B, C)**
* **R2(C, D)**

**Check the following:**

1. **Union Condition:**
   [
   R1 ∪ R2 = R
   ]
   The combined attributes of R1 and R2 must cover all attributes of R.

2. **Intersection Condition:**
   [
   R1 ∩ R2 ≠ ∅
   ]
   The relations must share at least one common attribute.

3. **Closure Condition:**
   [
   (R1 ∩ R2)^+ ⊇ R1 \quad \text{or} \quad (R1 ∩ R2)^+ ⊇ R2
   ]
   The **closure of the common attributes** must cover one of the relations to guarantee a **lossless join**.

> ⚠️ Note: Not all decompositions into 1NF, 2NF, 3NF, or BCNF automatically guarantee a lossless decomposition. Always verify using **functional dependencies (FDs)** and **join conditions**.

---

### **Example**

**Original Relation:**

```
Employee(Employee_Id, Ename, Salary, Department_Id, Dname)
```

**Decomposed Relations:**

* **R1: Employee_desc(Employee_Id, Ename, Salary, Department_Id)**
* **R2: Department_desc(Department_Id, Dname)**

**Verification:**

* **Common Attribute:** `Department_Id`
* Check Closure: `(R1 ∩ R2)^+ = Department_Id^+`
* It should cover either **R1** or **R2** to ensure a **lossless join**.

**Result:** ✅

* Decomposition is lossless.

---

### **Armstrong’s Axioms and Lossless Decomposition**

Armstrong’s Axioms help compute **attribute closures** to verify lossless decomposition.

1. **Reflexivity:**
   If Y ⊆ X, then X → Y

2. **Augmentation:**
   If X → Y, then XZ → YZ (for any Z)

3. **Transitivity:**
   If X → Y and Y → Z, then X → Z

> Use these axioms to check whether `(R1 ∩ R2)^+` covers R1 or R2.

---

### **Algorithms for Lossless Decomposition**

1. **BCNF decomposition**
2. **3NF decomposition**

> Both ensure lossless joins when applied correctly.

---

### **Advantages of Lossless Decomposition**

* **Reduced Data Redundancy:** Optimizes storage.
* **Easier Maintenance & Updates:** Smaller, focused tables.
* **Improved Data Integrity:** Only related attributes are together.
* **Better Flexibility:** Individual relations can be modified independently.

---

### **Disadvantages of Lossless Decomposition**

* **Increased Complexity:** More joins needed for queries.
* **Higher Processing Overhead:** Computationally heavier due to joins.
* **Design Effort:** Requires careful planning and validation.
* **Costly Implementation:** Large DBs need more resources to normalize.

---

### **GATE Example Questions**

**Q1:** Let R(A, B, C, D) with FDs:

```
A → B, B → C, C → D, D → B
```

Decompose into `(A, B), (B, C), (B, D)`

Options:

* (A) Lossless & dependency preserving ✅
* (B) Lossless, not dependency preserving
* (C) Not lossless, dependency preserving
* (D) Not lossless, not dependency preserving

---

**Q2:** R(A,B,C,D). Which decomposition **does not** have lossless join, dependency preserving BCNF?

Options:

* (A) A→B, B→CD
* (B) A→B, B→C, C→D
* (C) AB→C, C→AD
* (D) A→BCD

---

### **Key Takeaways**

1. **Lossless decomposition** ensures **no data loss**.
2. Use **intersection + closure** to verify lossless property.
3. **Functional dependencies** and **Armstrong’s axioms** are essential tools.
4. Balances between **redundancy elimination** and **query performance**.

