# **Day 25 – Article 1: View Serializability in DBMS**

## **1. Overview**

**View Serializability (VSR)** ensures that **concurrent execution of transactions** produces the same **final database state** as some **serial execution**, even if the schedule is **not conflict-serializable**.

* Focuses on the **effects of operations** (reads/writes) rather than strict operation ordering.
* Ensures **database consistency** during concurrency.

---

## **2. When is a schedule view serializable?**

A schedule is **view serializable** if it is **view equivalent** to a serial schedule.

### **Three Conditions for View Equivalence**

1. **Initial Read:**

   * Each transaction reads the same initial values as in the serial schedule.
2. **Updated Read:**

   * Each read in the schedule sees the same value as it would in the serial schedule.
3. **Final Write:**

   * Each data item is finally written by the same transaction as in the serial schedule.

---

## **3. Checking View Serializability**

### **Method 1: Direct View Equivalence**

* Check the above three conditions: initial reads, updated reads, and final writes.
* If all satisfied → Schedule is **view serializable**.

### **Method 2: Using Precedence / Dependency Graph**

1. **Check conflict serializability first**:

   * If schedule is **conflict serializable**, it is automatically view serializable.
2. **Check for blind writes**:

   * A **blind write** occurs when a transaction writes a value **without reading it first**.
   * Blind writes can affect view serializability.
3. **Draw dependency graph**:

   * Create edges based on read/write dependencies to ensure correct execution order.
   * **No cycles** → View serializable

---

## **4. Example**

**Schedule S':**
`read1(A), write2(A), read3(A), write1(A), write3(A)`

| Transaction | Operations        |
| ----------- | ----------------- |
| T1          | read(A), write(A) |
| T2          | write(A)          |
| T3          | read(A), write(A) |

**Step 1: Check Conflict Serializability**

* Precedence graph → **contains cycle** → Not conflict serializable

**Step 2: Check for Blind Writes**

* T2 performs a **blind write** `write2(A)` → May or may not affect VSR

**Step 3: Draw Dependency Graph**

* T1 reads A → must execute **before T2** → `T1 → T2`
* Final write on A by T3 → must execute **after T1 and T2** → `(T1,T2) → T3`
* **No cycles** → Schedule is **view serializable** ✅

---

## **5. Key Notes**

* **All conflict-serializable schedules are view serializable**, but **not all view-serializable schedules are conflict serializable**.
* Blind writes are a key factor in determining view serializability.
* Dependency graph analysis ensures consistent final outcomes in concurrent schedules.

---

This article focuses entirely on **view serializability**, which is the **more general form of serializability** compared to conflict serializability.
