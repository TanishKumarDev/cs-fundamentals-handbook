# **Day 21 - SQL Views, Indexes, Cursors, Triggers**

## SQL Cursors

### **1. What is a Cursor?**

A **cursor** in SQL is a **database object** that allows **row-by-row processing** of query results instead of bulk operations.
Useful when **custom logic** needs to be applied to each row individually.

**Use Cases:**

* Conditional row updates
* Calculations per row
* Iterating result sets
* Hierarchical or recursive data
* Cleanup tasks that cannot be done in a single query

---

### **2. Types of Cursors**

#### **2.1 Implicit Cursors**

* Automatically created by SQL during `INSERT`, `UPDATE`, or `DELETE`.
* Managed entirely by the SQL engine.
* Useful attributes:

  * `%FOUND` → True if at least one row affected
  * `%NOTFOUND` → True if no row affected
  * `%ROWCOUNT` → Number of rows affected
  * `%ISOPEN` → Checks if cursor is open

**Example (PL/SQL, Bulk Update):**

```plsql
DECLARE
   total_rows NUMBER;
BEGIN
   UPDATE Emp
   SET Salary = Salary + 1500;

   total_rows := SQL%ROWCOUNT;

   DBMS_OUTPUT.PUT_LINE(total_rows || ' rows updated.');
END;
```

---

#### **2.2 Explicit Cursors**

* User-defined, fully controlled (declare, open, fetch, close, deallocate)
* Useful for:

  * Row-by-row processing
  * Custom logic per row
  * Iterating with access to row attributes

**Lifecycle Steps:**

1. **Declare**

```sql
DECLARE emp_cursor CURSOR FOR
SELECT Name, Salary FROM Employees;
```

2. **Open**

```sql
OPEN emp_cursor;
```

3. **Fetch**

```sql
FETCH NEXT FROM emp_cursor INTO @Name, @Salary;
WHILE @@FETCH_STATUS = 0
BEGIN
   PRINT 'Name: ' + @Name + ', Salary: ' + CAST(@Salary AS VARCHAR);
   FETCH NEXT FROM emp_cursor INTO @Name, @Salary;
END;
```

4. **Close**

```sql
CLOSE emp_cursor;
```

5. **Deallocate**

```sql
DEALLOCATE emp_cursor;
```

---

### **3. Fetch Modes**

| Mode       | Description                              |
| ---------- | ---------------------------------------- |
| FIRST      | Fetches first row                        |
| LAST       | Fetches last row                         |
| NEXT       | Fetches next row (default)               |
| PRIOR      | Fetches previous row                     |
| ABSOLUTE n | Fetches nth row                          |
| RELATIVE n | Fetches row relative to current position |

---

### **4. Implicit Cursor Example**

```plsql
BEGIN
  FOR emp_rec IN SELECT * FROM emp LOOP
    DBMS_OUTPUT.PUT_LINE('Employee name: ' || emp_rec.ename);
  END LOOP;
END;
```

> SQL automatically creates a cursor to iterate over `emp`.

---

### **5. Common Cursor Exceptions**

1. **Duplicate Value Error** – trying to insert an existing record.
   **Solution:** Check before inserting or use TRY-CATCH.
2. **Invalid Cursor State** – fetching from a closed cursor.
   **Solution:** Always open before fetching, close after processing.
3. **Lock Timeout** – row/table locked by another transaction.
   **Solution:** Use proper isolation levels and manage transactions efficiently.

---

### **6. Implicit vs Explicit Cursors**

| Feature    | Implicit Cursor                       | Explicit Cursor                   |
| ---------- | ------------------------------------- | --------------------------------- |
| Creation   | Automatic                             | Manual (DECLARE required)         |
| Management | SQL engine                            | User-managed (open, fetch, close) |
| Attributes | %FOUND, %NOTFOUND, %ROWCOUNT, %ISOPEN | Same attributes available         |
| Use Case   | Simple DML operations                 | Complex row-by-row operations     |

---

### **7. Advantages**

* Row-by-row processing
* Iterative data handling
* Handles complex relationships
* Conditional operations
* Non-straightforward relationships

### **8. Limitations**

* Slower than set-based operations
* High resource consumption (locks, memory)
* Adds code complexity (declare, open, fetch, close, deallocate)
* Performance degrades with large datasets
