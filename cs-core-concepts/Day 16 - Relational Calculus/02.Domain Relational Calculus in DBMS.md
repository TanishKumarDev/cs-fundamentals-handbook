# **Day 16 – Relational Calculus**

---

## **1. Tuple Relational Calculus (TRC)**

### **Definition**

Tuple Relational Calculus (TRC) is a **non-procedural query language** used in DBMS.
It focuses on **what data to retrieve** rather than **how to retrieve it**, describing results using **tuple variables** that represent rows in a table.
It is based on **first-order predicate logic**.

---

### **General Syntax**

```
{ t | P(t) }
```

* **t** → Tuple variable (represents a row)
* **P(t)** → Predicate (logical condition to be satisfied)
* **{}** → Set of resulting tuples that meet the condition

---

### **Logical Operators**

| Symbol | Meaning |
| ------ | ------- |
| ∧      | AND     |
| ∨      | OR      |
| ¬      | NOT     |

---

### **Quantifiers**

| Symbol         | Meaning                | Description                                                      |
| -------------- | ---------------------- | ---------------------------------------------------------------- |
| ∃ t ∈ r (Q(t)) | Existential Quantifier | There exists a tuple **t** in relation **r** satisfying **Q(t)** |
| ∀ t ∈ r (Q(t)) | Universal Quantifier   | For all tuples **t** in relation **r**, **Q(t)** holds true      |

---

### **Example Table Setup**

#### Customer

| Customer Name | Street | City      |
| ------------- | ------ | --------- |
| Saurabh       | A7     | Patiala   |
| Mehak         | B6     | Jalandhar |
| Sumiti        | D9     | Ludhiana  |
| Ria           | A5     | Patiala   |

#### Loan

| Loan Number | Branch Name | Amount |
| ----------- | ----------- | ------ |
| L33         | ABC         | 10000  |
| L35         | DEF         | 15000  |
| L49         | GHI         | 9000   |
| L98         | DEF         | 65000  |

#### Borrower

| Customer Name | Loan Number |
| ------------- | ----------- |
| Saurabh       | L33         |
| Mehak         | L49         |
| Ria           | L98         |

#### Depositor

| Customer Name | Account Number |
| ------------- | -------------- |
| Saurabh       | 1111           |
| Mehak         | 1113           |
| Suniti        | 1114           |

---

### **Examples**

#### 1. Loans with amount ≥ 10000

```
{ t | t ∈ Loan ∧ t[Amount] ≥ 10000 }
```

**Result:**

| Loan Number | Branch Name | Amount |
| ----------- | ----------- | ------ |
| L33         | ABC         | 10000  |
| L35         | DEF         | 15000  |
| L98         | DEF         | 65000  |

---

#### 2. Loan numbers for loans ≥ 10000

```
{ t | ∃ s ∈ Loan (t[Loan Number] = s[Loan Number] ∧ s[Amount] ≥ 10000) }
```

**Result:**

| Loan Number |
| ----------- |
| L33         |
| L35         |
| L98         |

---

#### 3. Customers with both loan and account

```
{ t | ∃ s ∈ Borrower (t[Customer Name] = s[Customer Name]) ∧ ∃ u ∈ Depositor (t[Customer Name] = u[Customer Name]) }
```

**Result:**

| Customer Name |
| ------------- |
| Saurabh       |
| Mehak         |

---

#### 4. Customers with loan at “ABC” branch

```
{ t | ∃ s ∈ Borrower (t[Customer Name] = s[Customer Name]) ∧ ∃ u ∈ Loan (u[Branch Name] = "ABC" ∧ u[Loan Number] = s[Loan Number]) }
```

**Result:**

| Customer Name |
| ------------- |
| Saurabh       |

---

### **Key Points**

* TRC is **declarative**, not procedural.
* Defines **what data to retrieve**, not **how**.
* Uses **tuple variables**, **logical operators**, and **quantifiers**.
* Based on **predicate logic**.
* Common in **theoretical contexts** (e.g., GATE, UGC NET).

---

### **TRC vs Relational Algebra**

| Feature    | Tuple Relational Calculus | Relational Algebra       |
| ---------- | ------------------------- | ------------------------ |
| Type       | Non-procedural            | Procedural               |
| Focus      | What to retrieve          | How to retrieve          |
| Expression | Logical predicates        | Set-based operators      |
| Execution  | Abstract                  | Directly executable      |
| Use        | Theoretical               | Practical (basis of SQL) |

---

## **2. Domain Relational Calculus (DRC)**

### **Definition**

Domain Relational Calculus (DRC) is also a **non-procedural query language** used to specify queries using **domain variables (attributes)** instead of tuples.
It describes what data to retrieve using **predicates** that define conditions.

---

### **General Syntax**

```
{ <x1, x2, x3, …, xn> | P(x1, x2, x3, …, xn) }
```

* `<x1, x2, ...>` → Domain variables representing attributes
* `P(...)` → Predicate defining the condition

---

### **Key Components**

1. **Domain Variables** – Represent attributes (columns) of a relation.
2. **Predicates** – Logical formulas defining conditions using:

   * **Comparison operators**: =, >, <, >=, <=, !=
   * **Logical connectives**: AND, OR, NOT
   * **Quantifiers**: ∃ (Exists), ∀ (For all)
3. **Domains and Relations** – Each variable draws values from the attribute’s domain.

---

### **Example Tables**

#### Loan

| Loan Number | Branch Name | Amount |
| ----------- | ----------- | ------ |
| L01         | Main        | 200    |
| L03         | Main        | 150    |
| L10         | Sub         | 90     |
| L08         | Main        | 60     |

#### Borrower

| Customer Name | Loan Number |
| ------------- | ----------- |
| Ritu          | L01         |
| Debomit       | L08         |
| Soumya        | L03         |

---

### **Examples**

#### 1. Loans with Amount ≥ 100

```
{ <l, b, a> | <l, b, a> ∈ Loan ∧ a ≥ 100 }
```

**Result:**

| Loan Number | Branch Name | Amount |
| ----------- | ----------- | ------ |
| L01         | Main        | 200    |
| L03         | Main        | 150    |

---

#### 2. Loan Numbers where Amount ≥ 150

```
{ <l> | ∃ b, a (<l, b, a> ∈ Loan ∧ a ≥ 150) }
```

**Result:**

| Loan Number |
| ----------- |
| L01         |
| L03         |

---

#### 3. Customers with Loans from “Main” Branch

```
{ <c, a> | ∃ l (<c, l> ∈ Borrower ∧ ∃ b (<l, b, a> ∈ Loan ∧ b = "Main")) }
```

**Result:**

| Customer Name | Amount |
| ------------- | ------ |
| Ritu          | 200    |
| Debomit       | 60     |
| Soumya        | 150    |

---

### **Advantages**

* **Declarative** → Focuses on *what* to retrieve.
* **Mathematically sound** → Based on predicate logic.
* **Supports complex queries** using logic-based structure.

---

### **Limitations**

* **Complex syntax** – Difficult for practical use.
* **No execution details** – Doesn’t specify how data is retrieved.
* **No optimization support** – Unlike SQL.
* **Less user-friendly** – Used mainly in theory, not real DBMS.

---

### **DRC vs TRC**

| Aspect            | DRC                             | TRC                            |
| ----------------- | ------------------------------- | ------------------------------ |
| Focus             | Attributes (Domains)            | Tuples (Rows)                  |
| Syntax            | Domain variables and predicates | Tuple variables and predicates |
| Abstraction Level | More abstract                   | Less abstract                  |
| Usability         | Harder to read                  | Easier to write                |
| Practicality      | Theoretical                     | Slightly more practical        |

---

### **Key Takeaways**

* **Both DRC and TRC** are **non-procedural** and describe *what data to fetch*.
* **TRC** uses **tuple variables (rows)**, while **DRC** uses **domain variables (attributes)**.
* Both form the **theoretical foundation** for **SQL** and **Relational Algebra**.
* Mainly used for **academic and theoretical understanding**, not production systems.
