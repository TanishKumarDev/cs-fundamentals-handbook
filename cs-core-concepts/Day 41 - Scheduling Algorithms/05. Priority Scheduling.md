# **Priority Scheduling**

**Definition:**
Priority Scheduling is a CPU scheduling algorithm where each process is assigned a **priority**. The CPU executes the process with the **highest priority** first.

* If multiple processes share the same priority, **FCFS (First-Come, First-Served)** is used.
* Scheduling can be **preemptive** or **non-preemptive**.

> Priority can be based on factors like CPU burst time, memory requirement, I/O requirements, or a ratio of CPU/I/O usage.

---

## **1. Non-Preemptive Priority Scheduling**

**Characteristics:**

* CPU **cannot be taken away** from the running process.
* Higher-priority processes wait if a lower-priority process is running.

**Example:**

| Process | AT | BT | Priority (lower = higher) |
| ------- | -- | -- | ------------------------- |
| P1      | 0  | 4  | 2                         |
| P2      | 1  | 2  | 1                         |
| P3      | 2  | 6  | 3                         |

**Execution:**

* Time 0–4: P1 (only process available)
* Time 4–6: P2 (highest priority among arrived)
* Time 6–12: P3

**Gantt Chart:**

```
P1 | P2 | P3
0   4   6  12
```

**Calculations:**

| Process | CT | TAT = CT - AT | WT = TAT - BT |
| ------- | -- | ------------- | ------------- |
| P1      | 4  | 4             | 0             |
| P2      | 6  | 5             | 3             |
| P3      | 12 | 10            | 4             |

* **Average TAT** = 6.33 ms
* **Average WT** = 2.33 ms

---

## **2. Preemptive Priority Scheduling**

**Characteristics:**

* CPU can **preempt** the running process if a higher-priority process arrives.
* Ensures **higher-priority processes execute first**, even if a lower-priority process is running.

---

### **Example 1: Same Arrival Time**

| Process | AT | BT | Priority (higher = higher) |
| ------- | -- | -- | -------------------------- |
| P1      | 0  | 7  | 2                          |
| P2      | 0  | 4  | 1                          |
| P3      | 0  | 6  | 3                          |

**Execution Order (Gantt Chart):**

```
P3 | P1 | P2
0   6   13  17
```

**Calculations:**

| Process | CT | TAT = CT - AT | WT = TAT - BT |
| ------- | -- | ------------- | ------------- |
| P1      | 13 | 13            | 6             |
| P2      | 17 | 17            | 13            |
| P3      | 6  | 6             | 0             |

* **Average TAT** = 12 ms
* **Average WT** = 6.33 ms

---

### **Example 2: Different Arrival Times**

| Process | AT | BT | Priority |
| ------- | -- | -- | -------- |
| P1      | 0  | 6  | 2        |
| P2      | 1  | 4  | 3        |
| P3      | 2  | 5  | 1        |

**Execution Order (Gantt Chart):**

```
P1 | P2 | P1 | P3
0   1   5   10  15
```

**Calculations:**

| Process | CT | TAT = CT - AT | WT = TAT - BT |
| ------- | -- | ------------- | ------------- |
| P1      | 10 | 10            | 4             |
| P2      | 5  | 4             | 0             |
| P3      | 15 | 13            | 8             |

* **Average TAT** = 9 ms
* **Average WT** = 4 ms

---

## **Implementation Steps**

1. Input number of processes with **arrival time, burst time, priority**.
2. Initialize **remaining times = burst times**.
3. At each time unit, **check arrived processes**.
4. Select the **highest-priority process** (preempt if necessary).
5. Execute 1 unit of time, decrement remaining time, increment current time.
6. On completion:

   * `CT = current time`
   * `TAT = CT - AT`
   * `WT = TAT - BT`
7. Repeat until all processes are completed.
8. Calculate **average TAT and WT**.

---

## **Advantages**

1. Higher-priority processes execute quickly.
2. Minimizes response time for important tasks.
3. Flexible: Can be preemptive or non-preemptive.

---

## **Disadvantages**

1. **Starvation:** Low-priority processes may wait indefinitely.
2. **Priority inversion:** Low-priority process holds resources needed by high-priority process.
3. **Overhead:** Frequent preemption adds context-switch overhead.

---

If you want, I can make a **clean C++ implementation for both Preemptive and Non-Preemptive Priority Scheduling** with **automatic calculation of WT, TAT, and averages**, where you can input **any number of processes and priorities**.

Do you want me to do that?
Here’s a **structured summary of Priority Scheduling in Operating Systems** based on the GeeksforGeeks content:

---

# **Priority Scheduling**

**Definition:**
Priority Scheduling is a CPU scheduling algorithm where each process is assigned a **priority**. The CPU executes the process with the **highest priority** first.

* If multiple processes share the same priority, **FCFS (First-Come, First-Served)** is used.
* Scheduling can be **preemptive** or **non-preemptive**.

> Priority can be based on factors like CPU burst time, memory requirement, I/O requirements, or a ratio of CPU/I/O usage.

---

## **1. Non-Preemptive Priority Scheduling**

**Characteristics:**

* CPU **cannot be taken away** from the running process.
* Higher-priority processes wait if a lower-priority process is running.

**Example:**

| Process | AT | BT | Priority (lower = higher) |
| ------- | -- | -- | ------------------------- |
| P1      | 0  | 4  | 2                         |
| P2      | 1  | 2  | 1                         |
| P3      | 2  | 6  | 3                         |

**Execution:**

* Time 0–4: P1 (only process available)
* Time 4–6: P2 (highest priority among arrived)
* Time 6–12: P3

**Gantt Chart:**

```
P1 | P2 | P3
0   4   6  12
```

**Calculations:**

| Process | CT | TAT = CT - AT | WT = TAT - BT |
| ------- | -- | ------------- | ------------- |
| P1      | 4  | 4             | 0             |
| P2      | 6  | 5             | 3             |
| P3      | 12 | 10            | 4             |

* **Average TAT** = 6.33 ms
* **Average WT** = 2.33 ms

---

## **2. Preemptive Priority Scheduling**

**Characteristics:**

* CPU can **preempt** the running process if a higher-priority process arrives.
* Ensures **higher-priority processes execute first**, even if a lower-priority process is running.

---

### **Example 1: Same Arrival Time**

| Process | AT | BT | Priority (higher = higher) |
| ------- | -- | -- | -------------------------- |
| P1      | 0  | 7  | 2                          |
| P2      | 0  | 4  | 1                          |
| P3      | 0  | 6  | 3                          |

**Execution Order (Gantt Chart):**

```
P3 | P1 | P2
0   6   13  17
```

**Calculations:**

| Process | CT | TAT = CT - AT | WT = TAT - BT |
| ------- | -- | ------------- | ------------- |
| P1      | 13 | 13            | 6             |
| P2      | 17 | 17            | 13            |
| P3      | 6  | 6             | 0             |

* **Average TAT** = 12 ms
* **Average WT** = 6.33 ms

---

### **Example 2: Different Arrival Times**

| Process | AT | BT | Priority |
| ------- | -- | -- | -------- |
| P1      | 0  | 6  | 2        |
| P2      | 1  | 4  | 3        |
| P3      | 2  | 5  | 1        |

**Execution Order (Gantt Chart):**

```
P1 | P2 | P1 | P3
0   1   5   10  15
```

**Calculations:**

| Process | CT | TAT = CT - AT | WT = TAT - BT |
| ------- | -- | ------------- | ------------- |
| P1      | 10 | 10            | 4             |
| P2      | 5  | 4             | 0             |
| P3      | 15 | 13            | 8             |

* **Average TAT** = 9 ms
* **Average WT** = 4 ms

---

## **Implementation Steps**

1. Input number of processes with **arrival time, burst time, priority**.
2. Initialize **remaining times = burst times**.
3. At each time unit, **check arrived processes**.
4. Select the **highest-priority process** (preempt if necessary).
5. Execute 1 unit of time, decrement remaining time, increment current time.
6. On completion:

   * `CT = current time`
   * `TAT = CT - AT`
   * `WT = TAT - BT`
7. Repeat until all processes are completed.
8. Calculate **average TAT and WT**.

---

## **Advantages**

1. Higher-priority processes execute quickly.
2. Minimizes response time for important tasks.
3. Flexible: Can be preemptive or non-preemptive.

---

## **Disadvantages**

1. **Starvation:** Low-priority processes may wait indefinitely.
2. **Priority inversion:** Low-priority process holds resources needed by high-priority process.
3. **Overhead:** Frequent preemption adds context-switch overhead.

