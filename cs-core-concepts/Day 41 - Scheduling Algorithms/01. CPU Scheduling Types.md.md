# **CPU Scheduling Types**

CPU scheduling decides **which process in the ready queue gets the CPU next**. This ensures efficient CPU utilization and improves system responsiveness.

---

## **1. Preemptive Scheduling**

* **Definition**: The OS can **interrupt a running process** to give the CPU to another process (based on priority or time slice).
* **State Change**: Running → Ready (before completion).
* **Examples**:

  * **Round Robin (RR)**
  * **Shortest Remaining Time First (SRTF)**
  * **Priority Scheduling (preemptive version)**

**Advantages**:

1. Prevents a single process from monopolizing the CPU.
2. Better average **response time** in multi-user systems.
3. Used in modern OS like Windows, Linux, macOS.

**Disadvantages**:

1. More complex to implement.
2. Higher **context switching overhead**.
3. Can cause **starvation** of low-priority processes.
4. Risk of concurrency issues if preempted while accessing shared resources.

---

## **2. Non-Preemptive Scheduling**

* **Definition**: Once a process starts execution, it **runs until it finishes** or voluntarily waits (e.g., for I/O). CPU cannot be forcibly taken.
* **State Change**: Running → Waiting or Terminated (no interruption by OS).
* **Examples**:

  * **First Come First Serve (FCFS)**
  * **Shortest Job First (SJF)**
  * **Priority Scheduling (non-preemptive version)**

**Advantages**:

1. Simple and easy to implement.
2. Minimal scheduling burden.
3. Less computational overhead.

**Disadvantages**:

1. A malicious or long process can monopolize CPU.
2. Average response time can be higher.
3. Cannot implement round-robin style fairness.

---

## **3. Key Differences**

| Parameter          | Preemptive Scheduling                                                  | Non-Preemptive Scheduling                                       |
| ------------------ | ---------------------------------------------------------------------- | --------------------------------------------------------------- |
| CPU Allocation     | Limited time slice; can be taken away                                  | Holds CPU until completion or waiting                           |
| Interrupt          | Allowed                                                                | Not allowed                                                     |
| Starvation         | Low-priority processes may starve if high-priority tasks keep arriving | Long processes may delay shorter ones (convoy effect)           |
| Overhead           | Higher due to context switching                                        | Minimal                                                         |
| Response Time      | Lower average response time                                            | Higher average response time                                    |
| Decision Making    | OS decides based on priority/time slice                                | Process runs as per arrival; OS only schedules when it finishes |
| Concurrency Issues | Possible if preempted during shared resource access                    | Rare, as process is not interrupted                             |
| Examples           | RR, SRTF, Priority (preemptive)                                        | FCFS, SJF, Priority (non-preemptive)                            |

---

**Tip**:

* **Preemptive** → Used in modern multitasking OS for **fair CPU sharing**.
* **Non-Preemptive** → Used in older OS or simple batch systems for **simplicity**.

