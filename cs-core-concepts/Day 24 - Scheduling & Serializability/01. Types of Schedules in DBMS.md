# **Day 24 – Scheduling & Serializability**

## **Article 1: Types of Schedules in DBMS**

### **1. Overview**

Scheduling in DBMS determines **the order in which transactions are executed** when multiple transactions run concurrently. Proper scheduling ensures:

* Avoidance of conflicts or data inconsistencies
* Correctness of final results
* Efficient resource utilization

A **schedule** is a sequence of operations from multiple transactions.

---

### **2. Types of Schedules**

![](https://media.geeksforgeeks.org/wp-content/uploads/20250707183453973406/Types-of-schedules-1024.webp)

#### **A. Serial Schedule**

* Transactions execute **one after another** (non-interleaved).
* No transaction starts until the previous transaction finishes.
* Guarantees **database consistency** automatically.

**Example:**

| T1   | T2   |
| ---- | ---- |
| R(A) |      |
| W(A) |      |
| R(B) |      |
| W(B) |      |
|      | R(A) |
|      | R(B) |

> T1 finishes completely before T2 starts → Serial Schedule.

---

#### **B. Non-Serial Schedule**

* Transactions **interleave operations**.
* Can improve throughput but may cause **concurrency problems**.
* Must ensure **serializability** to maintain correctness.

---

### **3. Serializable Scheduling (Concurrency Control)**

* Ensures that **non-serial schedules behave like serial schedules**.
* Benefits:

  * Prevents anomalies from concurrent execution
  * Better CPU and resource utilization
  * Maintains database consistency

#### **Types of Serializable Scheduling**

1. **Conflict Serializable**

   * Can be transformed into a serial schedule by swapping **non-conflicting operations**.
   * **Conflicting operations** satisfy:

     * Belong to **different transactions**
     * Operate on **same data item**
     * **At least one** is a write operation

2. **View Serializable**

   * Schedule produces **same final database state** as some serial schedule.
   * Includes cases where blind writes occur.
   * **All conflict-serializable schedules are view-serializable**, but not vice versa.

---

### **4. Non-Serializable Scheduling**

* Does not preserve serial equivalence.
* May lead to inconsistencies if not controlled.

#### **Types**

1. **Recoverable Schedule**

   * Transaction commits **only after transactions whose changes it read have committed**.
   * Prevents reading uncommitted data.

   **Example:**

   ```
   T1: R(A), W(A), Commit
   T2: R(A), W(A), Commit
   ```

   T2 reads value updated by T1 → T2 commits **after T1**.

2. **Cascading Schedule**

   * Failure in one transaction causes rollback of dependent transactions.
   * Example of **avoiding cascading aborts** (ACA): disallow reading uncommitted data.

3. **Cascadeless Schedule**

   * Transactions read values **only after previous transactions commit**.
   * Prevents chain rollbacks from cascading aborts.

   **Example:**

   ```
   T1: R(A), W(A), Commit
   T2: R(A), W(A), Commit
   ```

   T2 reads A **after T1 commits** → cascadeless.

4. **Strict Schedule**

   * A transaction can **read/write another transaction's updated value only after it commits/aborts**.
   * Ensures maximum consistency.

5. **Non-Recoverable Schedule**

   * Transaction reads uncommitted data from another transaction that later aborts.
   * Leads to **wrong committed values**.

---

### **5. Relationships Between Schedules**

![](https://media.geeksforgeeks.org/wp-content/uploads/Types-of-schedules.png)

* **Cascadeless ⊆ Recoverable**
* **Strict ⊆ Cascadeless**
* **Serial ⊆ Strict**

> Serial schedules satisfy all constraints automatically.

---

### **6. Example Problem**

Schedule: `S: R1(A), W2(A), Commit2, W1(A), W3(A), Commit3, Commit1`

* Rewriting by transactions:

| T1     | T2     | T3   |
| ------ | ------ | ---- |
| R(A)   |        |      |
|        | W(A)   |      |
| Commit |        |      |
| W(A)   |        |      |
|        |        | W(A) |
|        | Commit |      |
| Commit |        |      |

**Analysis:**

* **View Serializable:** Yes (final state same as serial schedule T1 → T2 → T3)
* **Strict Recoverable:** No (T3 writes A before T1 commits → violates strictness)

✅ **Answer:** Serializable schedule but **not** strict recoverable → Option **D**
