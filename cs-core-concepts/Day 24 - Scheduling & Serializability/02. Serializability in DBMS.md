# **Day 24 – Article 2: Serializability in DBMS**

## **1. Overview**

**Serializability** ensures that concurrent transaction execution in a DBMS results in a **consistent database**, equivalent to some serial (one-by-one) execution.

* A **non-serial schedule** allows transactions to run concurrently.
* To maintain correctness, such schedules must be **serializable**.

**Example:**

| Transaction-1 | Transaction-2 |
| ------------- | ------------- |
| R(a)          |               |
| W(a)          |               |
|               | R(a)          |
|               | W(a)          |
| R(b)          |               |
| W(b)          |               |
|               | R(b)          |
|               | W(b)          |

* `R` = Read, `W` = Write
* Transaction-2 executes before Transaction-1 finishes, operating on the same data items.

---

## **2. Serializability Testing**

* **Goal:** Check if a non-serial schedule can be treated as serial without violating consistency.
* **Method:** Use **Serialization Graph / Precedence Graph**.

### **Precedence Graph**

* **Graph G(V, E):**

  * **Vertices (V):** Transactions (T1, T2, …, Tn)
  * **Edges (E):** Directed edges from Ti → Tj if Ti performs a read/write **before** Tj on the same data item.

* **Rule:** A schedule is **conflict serializable** if the precedence graph has **no cycles**.

---

## **3. Types of Serializability**

### **A. Conflict Serializability**

* Checks if a non-serial schedule can be rearranged into a serial order by swapping **non-conflicting operations**.
* **Conflicting operations:**

  1. Same data item
  2. At least one is a write
  3. Different transactions

**Conflict Equivalency Rules:**

1. **Same Conflicting Operations:** Order must match in both schedules.
2. **Non-Conflicting Operations:** Can appear in any order.
3. **Preserve Transaction Order:** Conflicting operations must maintain order to avoid inconsistencies.

---

### **B. View Serializability**

* Ensures final database state is identical to some serial schedule.
* Checks for **view equivalency** based on:

  1. **Same Transactions**: Both schedules contain same set of transactions.
  2. **Same Writes**: Each data item is last written by the same transaction.
  3. **Same Reads**: Each read gets the same value from the same write.

**View Equivalency Rules:**

* First read of a data item must match.
* Last write of a data item must match.
* Intermediate read/write sequence should also be preserved.

**Note:**

* Every conflict-serializable schedule is **view-serializable**, but not all view-serializable schedules are conflict-serializable.

---

## **4. Example**

**Schedule S:**

| Transaction-1 | Transaction-2 |
| ------------- | ------------- |
| R(a)          |               |
| W(a)          |               |
|               | R(a)          |
|               | W(a)          |
| R(b)          |               |
| W(b)          |               |
|               | R(b)          |
|               | W(b)          |

* Switching mid-read/write operations → **View Equivalent Schedule (S’)**:

  * Transactions still produce the same final state.
* S’ is **view serializable**.

---

## **5. Advantages of Serializability**

1. **Predictable Execution:** Transactions behave consistently without data loss or corruption.
2. **Easier Debugging:** Transactions run independently → easier error tracking.
3. **Lower Costs:** Simplifies concurrency control, reduces hardware/development cost.
4. **Better Performance:** Optimized, consistent execution may outperform non-serial schedules.
