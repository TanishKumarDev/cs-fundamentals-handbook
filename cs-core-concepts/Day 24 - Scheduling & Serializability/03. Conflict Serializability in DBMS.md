# **Day 24 – Article 3: Conflict Serializability in DBMS**


## **1. Overview**

**Conflict Serializability (CSR)** ensures that a concurrent schedule produces the **same result as some serial execution** by reordering **non-conflicting operations**.

* **Stricter than view serializability:** View serializability allows more flexibility, CSR guarantees consistency by preventing conflicting operations from executing out of order.

---

## **2. Non-Conflicting vs Conflicting Operations**

### **Non-Conflicting Operations**

* Operate on **different data items**
* Or operate on the **same data item but both are reads**

### **Conflicting Operations**

Two operations conflict if **all** conditions are true:

1. Belong to **different transactions**
2. Operate on the **same data item**
3. At least **one is a write**

---

## **3. Example of Conflict Serializability**

**Schedule S1:**
`R1(A), W1(A), R2(A), W2(A), R1(B), W1(B), R2(B), W2(B)`

* Transactions extracted:

  * `T1 = R1(A), W1(A), R1(B), W1(B)`
  * `T2 = R2(A), W2(A), R2(B), W2(B)`

* By **swapping non-conflicting operations**, we can transform S1 into:
  `R1(A), W1(A), R1(B), W1(B), R2(A), W2(A), R2(B), W2(B)` → Serial schedule **T1 → T2**

✅ S1 is **conflict serializable**

---

**Schedule S2:**
`R2(A), W2(A), R1(A), W1(A), R1(B), W1(B), R2(B), W2(B)`

* Swapping non-conflicting operations **cannot maintain the order of T1**
* ❌ S2 is **not conflict serializable**

---

## **4. Testing Conflict Serializability**

**Method:** Precedence Graph (Serialization Graph)

**Steps:**

1. Create **nodes** for each transaction.
2. Draw **edges for conflicting operations**:

   * `read_item(X)` after `write_item(X)` → Edge from writer → reader
   * `write_item(X)` after `read_item(X)` → Edge from reader → writer
   * `write_item(X)` after `write_item(X)` → Edge from first writer → second writer

**Rule:**

* **A schedule is conflict serializable if the graph has no cycles**.
* **Topological Sorting** of acyclic graph gives one or more **equivalent serial schedules**.

**Example:**
`S: r1(x) r1(y) w2(x) w1(x) r2(y)` → Graph is **cyclic** → Not conflict serializable

Another example:
`S1: r1(x) r3(y) w1(x) w2(y) r3(x) w2(x)` → Graph is **acyclic** → CSR → Topological Sort: T1 → T3 → T2

---

## **5. Advantages of Conflict Serializability**

1. **Consistency:** Guarantees the same outcome as serial execution.
2. **Correctness:** Ensures transactions are executed correctly regardless of submission order.
3. **Reduced Overhead:** Eliminates unnecessary locking if managed properly.
4. **Enhanced Concurrency:** Allows safe concurrent execution without conflicts.

---

## **6. Disadvantages of Conflict Serializability**

1. **Complexity:** Difficult to implement for large databases.
2. **Reduced Performance:** May introduce delays due to locking.
3. **Limited Concurrency:** Some transactions may be delayed to avoid conflicts.
4. **Increased Overhead:** Extra work to maintain correct operation order.

---

### ✅ **Key Takeaways**

* CSR = strong guarantee of correctness; stricter than view serializability.
* Precedence graph is **essential** for testing conflict serializability.
* Cycles in the graph → Not conflict serializable.
* Acyclic graph → Serial schedule can be constructed using **topological sorting**.

---