## üß† **Two-Phase Locking (2PL) Protocol ‚Äî DBMS**

### **Definition**

Two-Phase Locking (2PL) is a concurrency control protocol that ensures **serializability** by dividing a transaction into two phases ‚Äî **Growing** and **Shrinking** ‚Äî based on how locks are acquired and released.

---

### **Phases**

1. **Growing Phase**

   * Transaction **acquires locks** (S or X).
   * Cannot release any lock in this phase.
   * Ends at the **Lock Point** (when the last lock is acquired).

2. **Shrinking Phase**

   * Transaction **releases locks**.
   * Cannot acquire any new lock after starting to release.

---

### **Types of Locks**

| Type           | Symbol | Description                                                                       |
| -------------- | ------ | --------------------------------------------------------------------------------- |
| Shared Lock    | `S`    | Allows **read-only** access; multiple transactions can hold S-locks on same data. |
| Exclusive Lock | `X`    | Allows **read and write**; only one transaction can hold X-lock on a data item.   |

---

### **Lock Conversions**

* **Upgrade (S ‚Üí X)** ‚Üí during **Growing Phase**
  ‚Üí e.g. Read first, then decide to modify.
* **Downgrade (X ‚Üí S)** ‚Üí during **Shrinking Phase**
  ‚Üí e.g. Modify first, then only read.

---

### **Lock Point**

The moment when a transaction has acquired **all the locks** it will ever need.
After this ‚Üí it can only **release locks** (starts Shrinking Phase).

---

### **Example**

**T1**

```
1. lock-S(A)
3. lock-X(B)
5. unlock(A)
7. unlock(B)
```

* Growing: steps 1‚Äì3
* Shrinking: steps 5‚Äì7
* Lock Point = 3

**T2**

```
2. lock-S(A)
6. lock-X(C)
8. unlock(A)
9. unlock(C)
```

* Growing: 2‚Äì6
* Shrinking: 8‚Äì9
* Lock Point = 6

---

### **Real-World Analogy**

üìö *Library Example*

* User locks book (S) ‚Üí checks availability
* Upgrades lock to (X) ‚Üí borrows it
* Locks record ‚Üí updates details
* After acquiring all locks ‚Üí Lock Point
* Then releases locks ‚Üí Shrinking Phase

---

### ‚ö†Ô∏è **Drawbacks of 2PL**

| Problem                 | Description                                                                  |
| ----------------------- | ---------------------------------------------------------------------------- |
| **Deadlock**            | Two transactions wait for each other‚Äôs locks forever.                        |
| **Cascading Rollback**  | Rollback of one transaction causes others (dependent on it) to rollback too. |
| **Lock Contention**     | Too many transactions compete for same locks.                                |
| **Limited Concurrency** | Strict locking reduces parallelism and system performance.                   |

---

### **Cascading Rollback Example**

* **T1** writes `A` ‚Üí fails ‚Üí rollback
* **T2** reads `A` written by T1 ‚Üí must rollback
* **T3** reads data from T2 ‚Üí also rollback
  ‚Üí Chain reaction of rollbacks

**Solution:**

* **Strict 2PL:** release locks only **after commit**
* **Rigorous 2PL:** hold **both read and write locks** until commit (stronger)

---

### **Deadlock Example**

```
Schedule: Lock-X1(A), Lock-X2(B), Lock-X1(B), Lock-X2(A)
```

* T1 locks A, T2 locks B
* T1 waits for B (held by T2)
* T2 waits for A (held by T1)
  ‚Üí **Deadlock**

---

### **Types of 2PL**

| Type             | Description                                                                              |
| ---------------- | ---------------------------------------------------------------------------------------- |
| **Basic 2PL**    | Ensures **conflict serializability**, but allows **deadlocks** & **cascading rollback**. |
| **Strict 2PL**   | Releases **write locks after commit** ‚Üí prevents cascading rollback.                     |
| **Rigorous 2PL** | Releases **all locks after commit** ‚Üí strongest form, ensures strictest order.           |

---

### üí° **Key Takeaways**

* 2PL = Growing Phase + Shrinking Phase
* Lock Point divides the two phases
* Ensures **conflict-serializable** schedules
* Strict / Rigorous 2PL help avoid **rollback & deadlock** issues
* Deadlocks require detection or prevention mechanisms (like wait-die, wound-wait)

