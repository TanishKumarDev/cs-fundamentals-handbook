# **Day 26 – Article 2: Lock-Based Concurrency Control Protocol in DBMS**

---

## **1. Introduction**

**Lock-Based Concurrency Control** is one of the most common methods used in DBMS to manage simultaneous transaction access to the same data item.

A **lock** ensures that only one transaction can use a data item at a time — maintaining **data integrity**, **consistency**, and **isolation**.

> In simple terms, a lock “reserves” a data item for a transaction until it’s safe for others to use it.

---

## **2. Purpose of Locking**

* Prevents **lost updates**, **dirty reads**, and **inconsistent data**.
* Ensures **serializability** (transactions behave as if executed one after another).
* Controls **access conflicts** between concurrent transactions.

---

## **3. Types of Locks**

### **A. Shared Lock (S-Lock / Read Lock)**

* Allows a transaction to **read** a data item but **not modify** it.
* Multiple transactions can hold **shared locks** on the same item simultaneously.
* Requested using `lock-S(X)`.

**Rules:**

* Can coexist with other shared locks.
* No transaction can acquire a **write (X)** lock on the same item while S-locks exist.

**Example:**

```
T1: lock-S(A)
T2: lock-S(A)
→ Both can read A
```

---

### **B. Exclusive Lock (X-Lock / Write Lock)**

* Allows a transaction to **read and modify** a data item.
* No other transaction can hold **any type of lock** (S or X) on that item.
* Requested using `lock-X(X)`.

**Rules:**

* Only one transaction can hold X-lock at a time.
* Prevents other transactions from even reading the same data until it’s released.

**Example:**

```
T1: lock-X(A)
T2: lock-S(A) → must wait
```

---

## **4. Lock Compatibility Matrix**

![](https://media.geeksforgeeks.org/wp-content/uploads/20250113111425534576/lock_based_protocol.webp)

| Lock Held by T1   | Lock Requested by T2 | Compatible? |
| ----------------- | -------------------- | ----------- |
| **S (Shared)**    | **S (Shared)**       | ✅ Yes       |
| **S (Shared)**    | **X (Exclusive)**    | ❌ No        |
| **X (Exclusive)** | **S (Shared)**       | ❌ No        |
| **X (Exclusive)** | **X (Exclusive)**    | ❌ No        |

**Key Rule:**
A lock can be granted only if it is **compatible** with existing locks.
Otherwise, the transaction must **wait** until the other releases its lock.

---

## **5. Lock-Based Protocol Types**

Lock-based concurrency control can be implemented using various protocols depending on how locks are acquired and released.

---

### **A. Simplistic Lock Protocol**

* The simplest form of locking.
* Transaction **acquires a lock** before accessing a data item and **releases it after completion**.
* Does not handle deadlocks.

**Example:**

```
T1: lock-X(X), read(X), write(X), unlock(X)
T2: lock-S(X), read(X), unlock(X)
```

**Drawback:**
May cause **deadlocks** or **low concurrency**.

---

### **B. Pre-Claiming Lock Protocol**

* A transaction must **request all required locks** before starting execution.
* If all locks are available → transaction proceeds.
* If not → it waits or is rolled back.

**Goal:** Prevent deadlocks by acquiring all locks upfront.

**Example:**

```
T1 needs X-lock on X, S-lock on Y
→ Acquires both before executing.
If any lock unavailable → waits.
```

**Limitation:**
Can reduce concurrency as transactions hold multiple locks longer than necessary.

---

### **C. Two-Phase Locking (2PL) Protocol**

Ensures **serializability** by dividing execution into two phases:

1. **Growing Phase:**

   * Can **acquire locks** but **cannot release** any.

2. **Shrinking Phase:**

   * Can **release locks** but **cannot acquire** new ones.

The point where a transaction has obtained all required locks is called the **Lock Point**.

**Advantages:**

* Guarantees **conflict serializability**.
* Prevents inconsistency.

**Drawback:**

* May still cause **deadlocks**.

---

### **D. Strict Two-Phase Locking (Strict 2PL)**

* Follows the 2PL rules **plus**:
  → A transaction **holds all exclusive (X) locks** until **after commit**.
* Prevents **dirty reads** and **cascading rollbacks**.

**Example:**

```
T1: lock-X(A)
T1: write(A)
→ T1 commits → unlock(A)
```

**Advantages:**

* Easy recovery.
* Ensures **strict schedules** (no uncommitted data is read).

---

## **6. Common Problems in Lock-Based Protocols**

### **A. Deadlock**

Occurs when two or more transactions wait for each other indefinitely.

**Example:**

| Step | T1        | T2        |
| ---- | --------- | --------- |
| 1    | lock-X(B) |           |
| 2    | read(B)   |           |
| 3    | write(B)  |           |
| 4    |           | lock-S(A) |
| 5    |           | read(A)   |
| 6    | lock-S(B) |           |
| 7    |           | lock-X(A) |

→ T1 waits for A, T2 waits for B → **Deadlock**.

**Solution:**

* Deadlock detection and timeout mechanisms.
* Use pre-claiming or timestamp-based protocols.

---

### **B. Starvation**

Occurs when a transaction **waits indefinitely** because other transactions keep getting priority.

**Example:**

* T1 needs X-lock on A.
* T2, T3, T4 keep requesting S-locks before T1 gets access.

**Solution:**
Use **fair scheduling** (FIFO order) in lock granting.

---

## **7. Summary Table**

| Lock Type     | Operation Allowed | Shared with Others? | Used For |
| ------------- | ----------------- | ------------------- | -------- |
| Shared (S)    | Read              | Yes (other S-locks) | Reading  |
| Exclusive (X) | Read + Write      | No                  | Updating |

| Protocol Type   | Prevents Deadlock? | Ensures Serializability? | Allows High Concurrency? |
| --------------- | ------------------ | ------------------------ | ------------------------ |
| Simplistic Lock | ❌ No               | ❌ No                     | ✅ Yes                    |
| Pre-Claiming    | ✅ Yes              | ✅ Yes                    | ⚠️ Moderate              |
| 2PL             | ❌ No               | ✅ Yes                    | ⚠️ Moderate              |
| Strict 2PL      | ✅ Yes (mostly)     | ✅ Yes                    | ⚠️ Moderate              |

---

## **8. Key Takeaways**

* Locks are essential for ensuring **safe concurrent access**.
* **Shared locks** allow read-only access, **exclusive locks** allow updates.
* **2PL** and **Strict 2PL** are the most widely used protocols in real DBMS systems.
* Must handle **deadlocks** and **starvation** for efficient transaction management.
