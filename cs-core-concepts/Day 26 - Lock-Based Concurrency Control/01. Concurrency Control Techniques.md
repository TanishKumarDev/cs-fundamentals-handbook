# **Day 26 – Article 1: Concurrency Control Techniques**

---

## **1. Introduction to Concurrency Control**

**Concurrency Control** in DBMS ensures that multiple transactions can execute **simultaneously** without violating **data consistency** or **isolation**.

When multiple users access or modify data at the same time, **conflicts** such as **lost updates, dirty reads, or deadlocks** can occur.
Concurrency control techniques manage these situations to maintain a consistent database state.

---

## **2. Key Characteristics of Concurrency Control**

* **Ensures Isolation:** Prevents transactions from interfering with each other.
* **Maintains Consistency:** Guarantees that concurrent execution leads to the same result as serial execution.
* **Resolves Conflicts:** Handles **read-write** and **write-write** conflicts safely.
* **Prevents Anomalies:** Avoids issues like **lost updates**, **temporary inconsistency**, and **uncommitted data access**.

---

## **3. Major Concurrency Control Techniques**

Concurrency control mechanisms are generally categorized into **pessimistic** and **optimistic** approaches.

| Category            | Technique                                   | Description                                                  |
| ------------------- | ------------------------------------------- | ------------------------------------------------------------ |
| **Pessimistic**     | Two-Phase Locking (2PL)                     | Locks data items to prevent conflicts before accessing them. |
| **Timestamp-Based** | Timestamp Ordering Protocol                 | Uses transaction timestamps to determine execution order.    |
| **Multi-Version**   | Multi-Version Concurrency Control (MVCC)    | Maintains multiple versions of data to increase concurrency. |
| **Optimistic**      | Validation (Optimistic) Concurrency Control | Assumes low conflict; validates transactions before commit.  |

---

## **4. Techniques Explained**

### **A. Two-Phase Locking Protocol (2PL)**

Locking secures permission to **read or write** a data item.
2PL ensures serializability by dividing a transaction’s execution into two phases:

1. **Growing Phase:**

   * The transaction **acquires locks** but cannot release any.
   * The point where all required locks are obtained is called the **Lock Point**.

2. **Shrinking Phase:**

   * The transaction **releases locks** but cannot acquire any new ones.

**Purpose:**
Guarantees **conflict-serializable schedules**, preventing anomalies by strict ordering of lock acquisition and release.

---

### **B. Timestamp Ordering Protocol**

Each transaction is assigned a unique **timestamp** when it starts.
This ensures transactions execute in **timestamp order**.

Each data item `X` maintains:

* **W-timestamp(X):** Latest time `X` was written.
* **R-timestamp(X):** Latest time `X` was read.

Rules:

* If a transaction tries to **read/write** a value that conflicts with the timestamp order, it is **rolled back** and restarted.

**Goal:**
Maintain a **serial order of transactions** based on timestamps while avoiding deadlocks.

---

### **C. Multi-Version Concurrency Control (MVCC)**

Instead of locking data, MVCC maintains **multiple versions** of each data item.
When a transaction writes, it creates a **new version** with its timestamp.
When a transaction reads, it accesses the **latest version** valid for its timestamp.

**Advantages:**

* Readers don’t block writers and vice versa.
* Increases concurrency significantly.

**Used in:** PostgreSQL, Oracle, MySQL (InnoDB).

---

### **D. Validation (Optimistic) Concurrency Control**

Assumes that conflicts are **rare**, so transactions execute freely without locks.
Before committing, the system validates that no other transaction conflicts occurred.

**Phases:**

1. **Read Phase:**

   * Transaction executes using a local (private) copy of data.

2. **Validation Phase:**

   * Before commit, system checks whether changes conflict with other transactions.

3. **Write Phase:**

   * If validation succeeds, changes are written permanently.
   * If validation fails, the transaction is **rolled back and restarted**.

**Advantages:**

* No locking overhead.
* High concurrency when conflicts are minimal.

---

## **5. Comparison of Techniques**

| Technique          | Type            | Prevents Deadlock? | Allows Concurrent Reads/Writes? | Example Use Case     |
| ------------------ | --------------- | ------------------ | ------------------------------- | -------------------- |
| Two-Phase Locking  | Pessimistic     | ❌ No (can occur)   | Limited                         | Bank transactions    |
| Timestamp Ordering | Timestamp-based | ✅ Yes              | Moderate                        | Distributed DBs      |
| MVCC               | Multi-Version   | ✅ Yes              | High                            | PostgreSQL, MySQL    |
| Validation Control | Optimistic      | ✅ Yes              | Very High                       | Low-conflict systems |

---

## **6. Summary**

Concurrency control ensures that:

* Multiple transactions execute **safely and correctly**.
* The **isolation** property of ACID is maintained.
* **Consistency** is not violated due to concurrent operations.

**Common DBMS implementations:**

* **MySQL (InnoDB):** Uses MVCC.
* **Oracle:** Combines locking + versioning.
* **PostgreSQL:** Fully MVCC-based.

---

✅ **In essence:**
Concurrency control is about **balancing performance and correctness** — ensuring high throughput while preserving data integrity.
