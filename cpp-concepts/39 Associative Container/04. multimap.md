# Multimap in C++ STL

A **multimap** is an **associative container** like `map`, but **allows multiple elements with the same key**.

* Implemented as a **Self-Balancing Binary Search Tree (Red-Black Tree)**.
* Elements are **sorted by key** in ascending order by default (custom comparator can be used).
* Keys **can be duplicated**, unlike `map`.

---

## Syntax

```cpp
#include <map>
multimap<key_type, value_type, comp> mm;
```

Where:

* `key_type` → type of key
* `value_type` → type of value
* `comp` → optional custom comparator
* `mm` → name of the multimap

---

## 1. Declaration and Initialization

```cpp
#include <iostream>
#include <map>
using namespace std;

int main() {
    multimap<int, string> mm1;  // empty multimap

    multimap<int, string> mm2 = {{1, "Geeks"}, {2, "For"}, {1, "C++"}};

    for (auto i : mm2)
        cout << i.first << ": " << i.second << endl;

    return 0;
}
```

**Output:**

```
1: Geeks
1: C++
2: For
```

---

## 2. Inserting Elements

* Use `insert()` → `[]` operator **not allowed** because keys can repeat.
* **Time Complexity:** `O(log n)`

```cpp
mm.insert({1, "Geeks"});
mm.insert({2, "For"});
mm.insert({1, "C++"});
```

---

## 3. Accessing Elements

* Access **only via iterators**: `->first` for key, `->second` for value.
* Use `begin()`, `end()`, `next()`, or `advance()` to navigate.
* **Time Complexity:** `O(n)` to reach a specific element

```cpp
auto it = mm.begin();
cout << it->first << ": " << it->second << endl; // first element
it = next(it, 1);
cout << it->first << ": " << it->second << endl; // second element
```

---

## 4. Updating Elements

* **Key cannot be modified**.
* **Value can be updated** via iterator.

```cpp
auto it = next(mm.begin(), 1);
it->second = "Java"; // update value
```

---

## 5. Traversing a Multimap

* Use **range-based for loop** or iterators with `begin()`/`end()`.
* **Time Complexity:** `O(n)`

```cpp
for(auto it = mm.begin(); it != mm.end(); it++)
    cout << it->first << " " << it->second << "\n";
```

---

## 6. Finding Elements

* `find(key)` → returns iterator to the **first occurrence** of key.
* `equal_range(key)` → returns **range of all elements** with that key.
* **Time Complexity:** `O(log n)`

```cpp
auto it = mm.find(2);
if(it != mm.end())
    cout << it->first << ": " << it->second;
```

---

## 7. Deleting Elements

* `erase(key)` → removes **all elements** with that key.
* `erase(iterator)` → removes **element at iterator**.
* **Time Complexity:** `O(log n)`

```cpp
mm.erase(2);             // delete all elements with key 2
mm.erase(mm.find(1));    // delete first element with key 1
```

---

## 8. Time Complexity Summary

| Operation                         | Complexity |
| --------------------------------- | ---------- |
| Insert an element                 | O(log n)   |
| Delete an element                 | O(log n)   |
| Access an element at any position | O(n)       |
| Find element by key               | O(log n)   |
| Count elements with a key         | O(log n)   |
| Traverse the multimap             | O(n)       |

---

## 9. Multimap vs Map

| Feature        | map                    | multimap                |
| -------------- | ---------------------- | ----------------------- |
| Key Uniqueness | Unique                 | Duplicates allowed      |
| Access         | Supports `[]` / `at()` | Iterator only           |
| Order          | Sorted by key          | Sorted by key           |
| Storage        | One value per key      | Multiple values per key |
| Use Case       | Single value per key   | Multiple values per key |

---
