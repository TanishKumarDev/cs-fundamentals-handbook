# Set in C++ STL

A **set** is a container in C++ that stores **unique elements** in a **sorted order**. It is implemented as a **Self-Balancing Binary Search Tree (Red-Black Tree)**, which provides efficient operations:

* **Search, insert, and delete** in `O(log n)` time.
* **No duplicates** allowed.
* Elements are **sorted in ascending order** by default (can customize with comparator).
* Compared to `unordered_set`, it takes slightly more time for operations but supports **sorted traversal** and functions like `upper_bound()` and `lower_bound()`.

---

## Syntax

```cpp
#include <set>
set<T> s;
```

Where:

* `T` → data type of elements
* `s` → name of the set

---

## 1. Creating and Traversing a Set

```cpp
#include <iostream>
#include <set>
using namespace std;

int main() {
    // Creating empty set
    set<int> s1;

    // Initialize set with elements (duplicates ignored)
    set<int> s2 = {1, 2, 3, 2, 1};

    // Traversing the set
    for (auto x : s2)
        cout << x << " ";
    cout << endl;

    return 0;
}
```

**Output:**

```
1 2 3
```

> Elements are sorted and duplicates are automatically removed.

---

## 2. Inserting Elements

* Use `insert()` to add an element.
* Only inserts if the element is **not already present**.
* **Time Complexity:** `O(log n)`

```cpp
#include <iostream>
#include <set>
using namespace std;

int main() {
    set<int> s = {2, 3};

    s.insert(1);  // Insert new element

    for (auto x : s)
        cout << x << endl;

    return 0;
}
```

**Output:**

```
1
2
3
```

---

## 3. Searching Elements

* `find(value)` → returns iterator if found, else `end()`.
* `count(value)` → returns `1` if element exists, else `0`.
* **Time Complexity:** `O(log n)`

```cpp
#include <iostream>
#include <set>
using namespace std;

int main() {
    set<int> s = {1, 2, 3};

    // Using find()
    auto it = s.find(1);
    if (it != s.end())
        cout << "Element found: " << *it << endl;

    // Using count()
    if (s.count(2))
        cout << "2 exists in the set" << endl;

    return 0;
}
```

**Output:**

```
Element found: 1
2 exists in the set
```

---

## 4. Traversing a Set

* Can use **range-based for loop** or **iterators**.
* Always in **sorted order**.
* **Time Complexity:** `O(n)`

```cpp
#include <iostream>
#include <set>
using namespace std;

int main() {
    set<int> s = {1, 2, 3};

    for (auto it = s.begin(); it != s.end(); ++it)
        cout << *it << endl;

    return 0;
}
```

**Output:**

```
1
2
3
```

---

## 5. Deleting Elements

* Use `erase(value)` → deletes element by value.
* Use `erase(iterator)` → deletes element at iterator position.
* **Time Complexity:** `O(log n)`

```cpp
#include <iostream>
#include <set>
using namespace std;

int main() {
    set<int> s = {1, 2, 3, 4};

    s.erase(2);          // Delete element 2
    s.erase(s.begin());  // Delete first element

    for (auto i : s)
        cout << i << " ";
    cout << endl;

    return 0;
}
```

**Output:**

```
3 4
```

---

## Summary of Key Operations

| Operation   | Function                           | Description                  | Complexity |
| ----------- | ---------------------------------- | ---------------------------- | ---------- |
| Insert      | `insert(x)`                        | Add element if not present   | O(log n)   |
| Search      | `find(x)` / `count(x)`             | Check element existence      | O(log n)   |
| Delete      | `erase(x)`                         | Remove element by value      | O(log n)   |
| Traverse    | `begin()/end()` or range-based for | Visit all elements in order  | O(n)       |
| Check empty | `empty()`                          | Returns true if set is empty | O(1)       |
| Size        | `size()`                           | Returns number of elements   | O(1)       |

---

## Complete Example

```cpp
#include <iostream>
#include <set>
using namespace std;

int main() {
    // Initialize set
    set<int> s = {3, 1, 4, 1, 5};

    // Insert element
    s.insert(2);

    // Search elements
    if (s.count(4))
        cout << "4 exists in set" << endl;

    // Traverse
    cout << "Set elements: ";
    for (auto x : s)
        cout << x << " ";
    cout << endl;

    // Delete element
    s.erase(1);

    // Traverse after deletion
    cout << "After deletion: ";
    for (auto x : s)
        cout << x << " ";
    cout << endl;

    // Size and empty check
    cout << "Size: " << s.size() << endl;
    cout << "Is empty? " << (s.empty() ? "Yes" : "No") << endl;

    return 0;
}
```

**Output:**

```
4 exists in set
Set elements: 1 2 3 4 5
After deletion: 2 3 4 5
Size: 4
Is empty? No
```

---