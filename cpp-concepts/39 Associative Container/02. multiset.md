# Multiset in C++ STL

A **multiset** is an **associative container** that is similar to `set`, but unlike `set`, it **allows duplicate elements**.

* Elements are **sorted in ascending order** by default (custom comparator can change order).
* Supports standard operations: `insert()`, `erase()`, `count()`, `find()`.
* Internally implemented as a **Self-Balancing Binary Search Tree**, handling duplicates by rules to insert in left/right subtree.
* **Time complexity for insert, erase, find:** `O(log n)`

---

## Syntax

```cpp
#include <set>
multiset<T> ms;
```

Where:

* `T` → type of elements
* `ms` → name of the multiset

---

## 1. Creating and Traversing a Multiset

```cpp
#include <iostream>
#include <set>
using namespace std;

int main() {
    // Empty multiset
    multiset<int> ms1;

    // Initialize with duplicates
    multiset<int> ms2 = {5, 3, 3, 1};

    // Traversing multiset (sorted order)
    for (auto i : ms2)
        cout << i << " ";
    cout << endl;

    return 0;
}
```

**Output:**

```
1 3 3 5
```

> Duplicates are allowed and elements are automatically sorted.

---

## 2. Inserting Elements

* Use `insert()` to add elements.
* **Duplicates allowed**.
* **Time Complexity:** `O(log n)`

```cpp
#include <iostream>
#include <set>
using namespace std;

int main() {
    multiset<int> ms;

    ms.insert(5);
    ms.insert(3);
    ms.insert(3);
    ms.insert(1);

    for (auto i : ms)
        cout << i << " ";
    cout << endl;

    return 0;
}
```

**Output:**

```
1 3 3 5
```

---

## 3. Accessing Elements

* Cannot access by index directly.
* Use **iterator** from `begin()`, advance to specific position using `next()`.
* **Time Complexity:** `O(n)` to reach a specific element

```cpp
#include <iostream>
#include <iterator>
#include <set>
using namespace std;

int main() {
    multiset<int> ms = {5, 3, 3, 1};

    auto it1 = ms.begin();          // first element
    cout << *it1 << " ";

    auto it2 = next(it1, 2);        // third element
    cout << *it2;

    return 0;
}
```

**Output:**

```
1 3
```

---

## 4. Finding Elements

* Use `find(value)` → returns iterator if found, otherwise `end()`.
* **Time Complexity:** `O(log n)`

```cpp
#include <iostream>
#include <set>
using namespace std;

int main() {
    multiset<int> ms = {5, 3, 3, 1};

    auto it = ms.find(3);
    if (it != ms.end())
        cout << *it;
    else
        cout << "Not Found!";

    return 0;
}
```

**Output:**

```
3
```

---

## 5. Traversing a Multiset

* Use **range-based for loop** or **iterators**.
* Can use `equal_range()` to traverse all duplicates.
* **Time Complexity:** `O(n)`

```cpp
#include <iostream>
#include <set>
using namespace std;

int main() {
    multiset<int> ms = {5, 3, 3, 1};

    for (auto i : ms)
        cout << i << " ";
    cout << endl;

    return 0;
}
```

**Output:**

```
1 3 3 5
```

---

## 6. Deleting Elements

* `erase(iterator)` → deletes specific element.
* `erase(value)` → deletes **all occurrences** of a value.
* **Time Complexity:** `O(log n)` per deletion

```cpp
#include <iostream>
#include <set>
using namespace std;

int main() {
    multiset<int> ms = {5, 3, 3, 1};

    ms.erase(ms.begin());  // Delete first element
    ms.erase(3);           // Delete all occurrences of 3

    for (auto x : ms)
        cout << x << " ";
    cout << endl;

    return 0;
}
```

**Output:**

```
5
```

> Note: Multiset elements **cannot be updated directly**; need to erase and reinsert to modify.

---

## Summary of Key Operations

| Operation         | Function                       | Description                      | Complexity |
| ----------------- | ------------------------------ | -------------------------------- | ---------- |
| Insert            | `insert(x)`                    | Add element (duplicates allowed) | O(log n)   |
| Search            | `find(x)` / `count(x)`         | Check element existence          | O(log n)   |
| Delete            | `erase(x)` / `erase(iterator)` | Remove element(s)                | O(log n)   |
| Traverse          | `begin()/end()` or range-based | Visit all elements in order      | O(n)       |
| Access first/last | `*begin()` / `*prev(end())`    | Access without index             | O(1)       |

---

## Complete Example

```cpp
#include <iostream>
#include <set>
using namespace std;

int main() {
    multiset<int> ms = {5, 3, 3, 1};

    // Insert element
    ms.insert(2);

    // Find element
    if (ms.count(3))
        cout << "3 exists in multiset" << endl;

    // Traverse
    cout << "Elements: ";
    for (auto x : ms)
        cout << x << " ";
    cout << endl;

    // Delete first element and all occurrences of 3
    ms.erase(ms.begin());
    ms.erase(3);

    cout << "After deletion: ";
    for (auto x : ms)
        cout << x << " ";
    cout << endl;

    // Access first and last element
    cout << "First element: " << *ms.begin() << endl;
    cout << "Last element: " << *prev(ms.end()) << endl;

    return 0;
}
```

**Output:**

```
3 exists in multiset
Elements: 1 3 3 5 2
After deletion: 2 5
First element: 2
Last element: 5
```
