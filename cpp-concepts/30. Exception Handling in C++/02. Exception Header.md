# **Exception Header in C++ (<exception>)**

C++ provides a **standard list of exceptions** defined in the `<exception>` header.
All standard exceptions inherit from `std::exception`, allowing them to be **caught by reference**.

---

## **1. Standard Exceptions in C++**

| Exception Type      | Description                                          |
| ------------------- | ---------------------------------------------------- |
| `bad_alloc`         | Thrown by `new` on memory allocation failure         |
| `bad_cast`          | Thrown by `dynamic_cast` when it fails               |
| `bad_exception`     | Thrown by certain dynamic exception specifiers       |
| `bad_typeid`        | Thrown by `typeid` when invalid                      |
| `bad_function_call` | Thrown by empty function objects                     |
| `bad_weak_ptr`      | Thrown by `shared_ptr` when a bad `weak_ptr` is used |
| `logic_error`       | Error related to program logic                       |
| `runtime_error`     | Error detected during runtime                        |

* All exceptions derive from **`std::exception`**.
* The `.what()` method returns a **description of the error**.

---

## **2. Example 1: `bad_alloc`**

```cpp
#include <exception>
#include <iostream>
using namespace std;

void createArray(int N) {
    try {
        int* array = new int[N];  // Memory allocation
        cout << "Array created of length " << N << endl;
    }
    catch (bad_alloc &e) {
        cout << e.what() << " for array of length " << N << endl;
    }
}

int main() {
    createArray(1000);          // Succeeds
    createArray(1000000000);    // Might fail
    return 0;
}
```

**Output (example):**

```
Array created of length 1000
std::bad_alloc for array of length 1000000000
```

**Key Points:**

* `bad_alloc` is thrown when **memory allocation fails**.
* Catching **by reference** avoids **copying overhead**.
* `what()` gives a **null-terminated string description** of the error.

---

### **Why Catch by Reference?**

```cpp
catch (std::string& s) {
    s += " Additional info";
    throw;
}
```

* Catch by value creates a **local copy** → modifications do not affect original exception.
* Catch by reference allows **modification and rethrowing** of the original exception.

---

## **3. Example 2: `logic_error` / `invalid_argument`**

```cpp
#include <exception>
#include <iostream>
#include <stdexcept>
using namespace std;

void findFactorial(int N) {
    int factorial = 1;
    try {
        if (N < 0)
            throw invalid_argument("negative not allowed"); // Logic error
        for (int i = N; i > 0; i--)
            factorial *= i;
        cout << "Factorial of " << N << " is " << factorial << endl;
    }
    catch (exception &e) {
        cout << e.what() << endl;
    }
}

int main() {
    findFactorial(0);   // 1
    findFactorial(3);   // 6
    findFactorial(-1);  // Exception
    return 0;
}
```

**Output:**

```
Factorial of 0 is 1
Factorial of 3 is 6
negative not allowed
```

**Key Points:**

* `logic_error` or `invalid_argument` can be used for **invalid inputs**.
* Catch **all standard exceptions** using `exception &e` → `.what()` prints the message.

---

## **4. Summary**

* `<exception>` header provides **all standard exception classes**.
* Catch exceptions **by reference** to avoid copying and allow rethrow.
* `.what()` gives **error description**.
* Standard exceptions include **bad_alloc, bad_cast, runtime_error, logic_error**, etc.
* Use **custom logic exceptions** for domain-specific errors.

---

This note complements your **Exception Handling Day 30 notes**, focusing on **standard exceptions, header usage, and practical examples**.

--