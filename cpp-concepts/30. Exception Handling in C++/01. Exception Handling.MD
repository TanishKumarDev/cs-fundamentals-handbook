# **Exception Handling in C++**

## **1. What is Exception Handling?**

Exception Handling is a mechanism in C++ to **detect and manage runtime errors** (errors that occur while the program is running) in a structured and controlled way.

![](https://media.geeksforgeeks.org/wp-content/uploads/20250411180615892273/cpp-exception-hierarchy.png)

It allows programs to **recover from errors or terminate gracefully**, instead of crashing abruptly.

**Examples of runtime errors:**

* Division by zero
* Invalid memory access
* File I/O failures

---

## **2. How Exception Handling Works**

1. **Throwing an Exception**
   When a problem occurs, the program **signals an exception** using the `throw` keyword.
2. **Catching an Exception**
   The program searches for a matching `catch` block to handle the exception.
3. **Handling the Exception**
   The `catch` block executes logic to recover or terminate safely.

---

## **3. try-catch Block**

The **try-catch** block is the basic mechanism in C++:

```cpp
try {
    // Code that might throw an exception
} 
catch (ExceptionType e) {
    // Code to handle the exception
}
```

* Code inside `try` may throw an exception.
* Execution stops when exception occurs and moves to the matching `catch`.
* `catch` handles the exception.

---

## **4. Throwing Exceptions**

### **4.1 Built-in Types**

* Simple integers, characters, etc., can be thrown.
* Minimal information is provided (not recommended for complex errors).

```cpp
#include <iostream>
using namespace std;

int main() {
    int x = 7;
    try {
        if (x % 2 != 0) throw -1;
    }
    catch (int e) {
        cout << "Exception Caught: " << e;
    }
    return 0;
}
```

**Output:**

```
Exception Caught: -1
```

---

### **4.2 Standard Exceptions**

* Predefined classes for common errors, derived from `std::exception` (in `<stdexcept>`).
* `.what()` gives descriptive info.

```cpp
#include <iostream>
#include <vector>
#include <stdexcept>
using namespace std;

int main() {
    vector<int> v = {1, 2, 3};
    try {
        v.at(10);  // Out-of-range access
    }
    catch (out_of_range &e) {
        cout << "Caught: " << e.what();
    }
    return 0;
}
```

**Output:**

```
Caught: vector::_M_range_check: __n (which is 10) >= this->size() (which is 3)
```

---

### **4.3 Custom Exceptions**

* When standard exceptions are insufficient.
* Usually inherit from `std::exception`.

```cpp
#include <iostream>
#include <exception>
using namespace std;

class NegativeValueException : public exception {
    int value;
public:
    NegativeValueException(int val) : value(val) {}
    const char* what() const noexcept override { return "Negative value error!"; }
    int getValue() const { return value; }
};

void checkValue(int x) {
    if (x < 0) throw NegativeValueException(x);
    else cout << "Value: " << x << endl;
}

int main() {
    int nums[] = {10, -5, 20};
    for (int n : nums) {
        try {
            checkValue(n);
        }
        catch (NegativeValueException &e) {
            cout << "Exception: " << e.what() << " Value = " << e.getValue() << endl;
        }
    }
}
```

**Output:**

```
Value: 10
Exception: Negative value error! Value = -5
Value: 20
```

---

## **5. Catching Exceptions**

### **5.1 Single Catch**

```cpp
catch (exceptionType e) {
    // Handle exception
}
```

### **5.2 Multiple Catch Blocks**

```cpp
try { /* ... */ }
catch (type1 e) { /* handle type1 */ }
catch (type2 e) { /* handle type2 */ }
catch (...) { /* catch-all */ }
```

* `catch(...)` handles **any exception not matched** by above.

---

### **5.3 Catch by Value vs Reference**

**Catch by Value:**

* Creates a copy of the exception object.
* Example:

```cpp
catch (runtime_error e) { ... }
```

**Catch by Reference:**

* No copy overhead.
* Essential for **polymorphic exceptions**.

```cpp
catch (exception &e) { ... }
```

**Best practice:** Catch exceptions **by reference to const**:

```cpp
catch (const exception &e) { ... }
```

---

### **5.4 Uncaught Exceptions**

* If no `catch` block matches, program **terminates by default**.
* Can customize using `set_terminate()`.

---

## **6. Exception Propagation (Stack Unwinding)**

* When an exception is thrown, **current block stops execution**.
* Resources are deallocated (destructors run for local objects).
* Search continues **up the call stack** for matching `catch`.
* Example:

```cpp
class Demo {
public:
    Demo() { cout << "Created\n"; }
    ~Demo() { cout << "Destroyed\n"; }
};

int main() {
    try {
        Demo d;
        throw 10;
        cout << "After throw";  // Not executed
    }
    catch (int e) { cout << "Caught Exception\n"; }
    cout << "After catch\n";
}
```

**Output:**

```
Created
Destroyed
Caught Exception
After catch
```

---

## **7. Nested Try-Catch & Rethrowing**

```cpp
try {
    try { throw 1; }
    catch(int e1) { throw; }  // Rethrow to outer catch
}
catch(int e2) { cout << "Caught outer exception\n"; }
```

* Allows **multi-level exception handling**.

---

## **8. Exception Specifications**

* `noexcept` specifies whether a function can throw exceptions.

```cpp
void func1() noexcept { /* won't throw */ }
void func2() noexcept(false) { /* may throw */ }
```

* Deprecated: `throw()` lists in old C++.

---

## **9. Why Use Exception Handling?**

**Advantages over traditional error handling (if-else):**

1. **Separation of error and normal code** → cleaner, maintainable.
2. **Flexible handling** → caller can choose which exceptions to handle.
3. **Categorization of errors** → built-in and custom exception objects.
4. **Automatic cleanup** → destructors run during stack unwinding.

---

## **10. Best Practices**

* Don’t use exceptions for normal flow.
* Catch **by reference to const** whenever possible.
* Prefer **specific exceptions** over generic `catch(...)`.
* Ensure **resources are properly released** (RAII principle).
* Avoid throwing exceptions from destructors (unless careful).

---

## **11. Summary Table**

| Concept            | Usage / Example                      |
| ------------------ | ------------------------------------ |
| `throw`            | Signal an error                      |
| `try`              | Block that might throw               |
| `catch`            | Handle exception                     |
| Built-in type      | `throw -1;`                          |
| Standard exception | `throw out_of_range("msg");`         |
| Custom exception   | Create class inheriting `exception`  |
| Nested try         | Handle inner/outer exceptions        |
| Rethrow            | `throw;` inside catch                |
| Propagation        | Stack unwinding until matching catch |
| `noexcept`         | Function guaranteed not to throw     |

---

### **12. Example Flow**

```cpp
try {
    throw runtime_error("Error!");
} catch (const exception &e) {
    cout << e.what();
}
```

* Exception thrown → stack unwinds → caught by matching catch → handled → program continues.

---

This note contains all the **logic, thinking, why/how/what, examples, and best practices** you need for C++ Exception Handling.
