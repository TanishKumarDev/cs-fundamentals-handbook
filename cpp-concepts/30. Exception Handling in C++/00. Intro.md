# **Exception Handling in C++**

Exception handling in C++ provides a **structured way to detect and manage runtime errors**, such as division by zero, invalid memory access, or file I/O failures. Instead of abruptly terminating the program, exceptions allow **graceful error handling**.

---

## **1. How Exception Handling Works**

1. **Throwing an Exception:** Use `throw` to signal an error.
2. **Catching an Exception:** Use `catch` to handle the thrown exception.
3. **Handling the Exception:** Execute recovery or logging logic in `catch`.

**Syntax:**

```cpp
try {
    // Code that may throw an exception
} 
catch (ExceptionType e) {
    // Handle exception
}
```

---

## **2. Throwing Exceptions**

### **2.1 Built-in Types**

```cpp
#include <iostream>
using namespace std;

int main() {
    int x = 7;
    try {
        if (x % 2 != 0)
            throw -1;  // Throwing int
    }
    catch (int e) {
        cout << "Exception Caught: " << e;
    }
    return 0;
}
```

**Output:**

```
Exception Caught: -1
```

**Observation:**

* Simple, but less informative.

---

### **2.2 Standard Exceptions**

C++ provides standard exceptions in `<stdexcept>` derived from `std::exception`:

| Exception       | Description               |
| --------------- | ------------------------- |
| `bad_alloc`     | Memory allocation failure |
| `bad_cast`      | Failed `dynamic_cast`     |
| `logic_error`   | Program logic errors      |
| `runtime_error` | Runtime errors            |

**Example: Out-of-range access**

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
    vector<int> v = {1,2,3};
    try {
        v.at(10);  // Out-of-range
    }
    catch (out_of_range &e) {
        cout << "Caught: " << e.what();
    }
}
```

**Output:**

```
Caught: vector::_M_range_check: __n (which is 10) >= this->size() (which is 3)
```

---

### **2.3 Custom Exceptions**

**Steps:**

1. Create a class inheriting from `std::exception`.
2. Override `what()` to provide a message.
3. Throw an object of that class.

```cpp
#include <bits/stdc++.h>
using namespace std;

class MyException : public exception {
    string message;
public:
    MyException(const char* msg) : message(msg) {}
    const char* what() const noexcept { return message.c_str(); }
};

int main() {
    try {
        throw MyException("This is a custom exception");
    }
    catch (const MyException &e) {
        cout << e.what();
    }
}
```

**Output:**

```
This is a custom exception
```

---

## **3. Catching Exceptions**

### **3.1 Multiple Catch Blocks**

```cpp
try {
    throw invalid_argument("Invalid argument");
}
catch (invalid_argument &e) { cout << e.what(); }
catch (out_of_range &e) { cout << e.what(); }
catch (...) { cout << "Unknown exception"; }
```

* `catch(...)` handles any unmatched exception.

---

### **3.2 Catch by Value vs Reference**

* **By Value:** Creates a copy (slight overhead, not suitable for polymorphism).
* **By Reference:** Avoids copying, supports polymorphic behavior (preferred).

---

### **3.3 Exception Propagation**

* Exceptions propagate up the **call stack** until a matching catch block is found.
* Objects go out of scope → **destructors are called** (stack unwinding).

```cpp
#include <iostream>
using namespace std;

class GfG {
public:
    GfG() { cout << "Object Created\n"; }
    ~GfG() { cout << "Object Destroyed\n"; }
};

int main() {
    try {
        GfG g;
        throw 10;
    }
    catch(int e) { cout << "Exception Caught\n"; }
    cout << "After catch";
}
```

**Output:**

```
Object Created
Object Destroyed
Exception Caught
After catch
```

---

## **4. User-Defined Custom Exceptions (Class Examples)**

### **4.1 Single Class Exception**

```cpp
class Demo {};
try { throw Demo(); }
catch (Demo d) { cout << "Caught Demo"; }
```

### **4.2 Multiple Classes**

```cpp
class Demo1 {}; class Demo2 {};
try { throw Demo1(); }
catch (Demo1 d1) { cout << "Demo1"; }
catch (Demo2 d2) { cout << "Demo2"; }
```

### **4.3 Inheritance**

```cpp
class Base {}; class Derived : public Base {};
try { throw Derived(); }
catch (Base b) { cout << "Caught Base"; } // Derived caught by Base
```

### **4.4 Constructor Exception**

```cpp
class Demo {
public:
    Demo(int x) {
        try {
            if(x==0) throw "Zero not allowed";
            cout << "Num = " << x << endl;
        } catch(const char* exp) { cout << exp; }
    }
};
Demo d1(0);  // Exception caught
Demo d2(1);  // Normal
```

---

## **5. Best Practices**

1. **Don’t use exceptions for regular flow**, only for errors.
2. **Catch by reference** (`const T&`) to avoid copies and enable polymorphism.
3. **Release resources** properly (use RAII).
4. **Order catch blocks**: derived classes before base classes.
5. Use **custom exceptions** for domain-specific error handling.
