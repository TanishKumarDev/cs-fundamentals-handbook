# **Multithreading in C++**

Multithreading is a **technique where multiple threads execute independently but share the same memory space**. Threads are the smallest units of execution in a program.

**Goal:** Improve CPU utilization, reduce execution time, and keep applications responsive.

---

## **1. Why Multithreading? Use Cases**

**Why use threads?**

1. **Parallel execution:** Run multiple tasks simultaneously on multiple CPU cores.
2. **Responsiveness:** Keep UI or main process active while background operations execute (e.g., auto-saving in Word, loading data in web apps).
3. **Resource efficiency:** Multiple threads share the same memory space, reducing overhead compared to multiple processes.
4. **Real-world example:**

   * Web server: One thread handles requests, another thread logs activity, while another manages DB queries.
   * Video player: One thread decodes video, another decodes audio, yet another handles UI.

**Problem it solves:** Without threads, long-running tasks block execution, reducing responsiveness and performance.

---

## **2. Thread Basics in C++**

C++11 introduced `<thread>` library.
**Syntax to create a thread:**

```cpp
#include <thread>
void func() { /* task */ }
std::thread t(func); // starts thread
t.join(); // waits for thread to finish
```

**Key Points:**

* `join()` → Main thread waits for child thread to finish.
* `detach()` → Thread runs independently; main thread doesn’t wait.
* Each thread has a **unique ID**: `thread.get_id()`.

---

## **3. Creating Threads**

**3.1 Using Functions**

```cpp
#include <iostream>
#include <thread>
using namespace std;

void sayHello() { cout << "Hello from thread\n"; }

int main() {
    thread t(sayHello); // Thread starts
    t.join();           // Wait for it
    cout << "Main thread done\n";
}
```

**Output:**

```
Hello from thread
Main thread done
```

**Logic:** Thread executes `sayHello` in parallel; `join()` ensures main waits.

---

**3.2 Using Lambda Expressions**

```cpp
int n = 5;
thread t([n]() { cout << "Lambda says: " << n << endl; });
t.join();
```

**Why use lambda?**

* Compact code
* Useful for short tasks without defining a separate function

---

**3.3 Using Function Objects (Functors)**

```cpp
class PrintNum {
    int n;
public:
    PrintNum(int num) : n(num) {}
    void operator()() const { cout << n; }
};

thread t(PrintNum(10));
t.join();
```

* Overload `operator()` → Callable object
* Advantage: Maintain internal state for thread tasks

---

**3.4 Using Class Member Functions**

```cpp
class MyClass {
public:
    void f1(int x) { cout << x; } // Non-static
    static void f2(int x) { cout << x; } // Static
};

MyClass obj;
thread t1(&MyClass::f1, &obj, 42); // Pass object & parameters
thread t2(&MyClass::f2, 99);       // Static function
t1.join(); t2.join();
```

**Why important:** Threads can operate on objects and shared state safely when synchronized.

---

## **4. Thread Management**

| Operation       | Purpose                            |
| --------------- | ---------------------------------- |
| `join()`        | Wait for thread to finish          |
| `detach()`      | Let thread run independently       |
| `joinable()`    | Check if thread can be joined      |
| `get_id()`      | Thread’s unique ID                 |
| `sleep_for()`   | Pause thread for time duration     |
| `sleep_until()` | Pause thread until a specific time |

**Dry Run Example:**

```cpp
thread t([](){ cout << "Thread running\n"; });
if(t.joinable()) t.join();
```

* Creates thread → executes lambda → waits for it to finish

---

## **5. Problems in Multithreading**

1. **Race Condition:** Multiple threads modify shared data → unpredictable results
2. **Deadlock:** Two threads wait for each other forever → no progress
3. **Starvation:** Low-priority thread never gets CPU time

**Example: Race Condition**

```cpp
int counter = 0;
void increment() { for(int i=0;i<1000;i++) counter++; }

thread t1(increment), t2(increment);
t1.join(); t2.join();
cout << counter; // < 2000 sometimes
```

**Solution:** Use synchronization mechanisms.

---

## **6. Thread Synchronization**

**6.1 Mutex (Mutual Exclusion)**

```cpp
mutex mtx;
void safeIncrement() {
    mtx.lock();
    counter++;
    mtx.unlock();
}
```

**Better Approach: Lock Guard**

```cpp
void safeIncrement() {
    lock_guard<mutex> lock(mtx); // RAII ensures unlock
    counter++;
}
```

**6.2 Condition Variables**

* Wait until a condition is met before executing
* Example: Producer-consumer problem

```cpp
condition_variable cv;
unique_lock<mutex> lk(mtx);
cv.wait(lk, [](){ return ready; }); // wait for ready==true
```

**Why useful:** Prevents busy waiting; efficiently synchronizes threads.

---

## **7. Context Switch**

* CPU switches execution between threads
* Saves state of current thread → loads state of next thread
* Costly operation, but enables concurrency

---

## **8. Thinking Approach: When to Use Multithreading**

1. **CPU-bound tasks** → Use multithreading to utilize multiple cores
2. **I/O-bound tasks** → Keep main thread responsive (file/network operations)
3. **Background tasks** → Auto-save, logging, monitoring

**Questions to Ask Before Using Threads:**

* Is the task **parallelizable**?
* Are **shared resources** involved? How will I synchronize?
* Could a **race condition, deadlock, or starvation** occur?

---

## **9. Dry Run Example with Multiple Threads**

```cpp
#include <iostream>
#include <thread>
using namespace std;

void pauseThread(string id, int n) {
    this_thread::sleep_for(chrono::seconds(n));
    cout << id << " finished after " << n << " sec\n";
}

int main() {
    thread t1(pauseThread, "t1", 3);
    thread t2(pauseThread, "t2", 2);
    thread t3(pauseThread, "t3", 1);

    t1.join(); t2.join(); t3.join();
}
```

**Output:** (non-deterministic order based on thread execution)

```
t3 finished after 1 sec
t2 finished after 2 sec
t1 finished after 3 sec
```

**Observation:** Threads run concurrently, finish in order determined by sleep times.

---

## **10. Important Points**

1. Threads **share memory**, processes do not.
2. Always **join or detach threads** before destruction.
3. Use **mutexes, locks, atomic variables** to protect shared data.
4. Avoid blocking main thread unnecessarily.
5. **Deadlock & race conditions** are common pitfalls.
6. Use **thread pools** for managing multiple tasks efficiently.
7. **Callable types:** function, lambda, functor, member function.

---

This note now gives you:

✅ Full **concept + why/how/when + syntax + logic + dry run + key points + real-world problems solved**
✅ Covers **functions, lambda, functors, member functions**
✅ Includes **thread management, synchronization, race conditions, deadlocks**