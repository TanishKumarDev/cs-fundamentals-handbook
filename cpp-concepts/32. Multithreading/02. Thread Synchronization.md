# **Thread Synchronization in C++**

Thread synchronization ensures that **multiple threads work predictably and reliably** on shared resources. Without proper synchronization, you can face **race conditions, deadlocks, or inconsistent results**.

---

## **1. Why Thread Synchronization?**

**Problem Scenario (Banking Example):**

* Initial Balance: 300
* Credit Thread: +400 → Balance = 700
* Debit Thread: -500 → Balance = 200

**Without synchronization:**

* Threads may execute in wrong order:

  * Debit executes first: Balance = -200 (or inconsistent)
  * Credit executes after: Balance = 200

**Issue:** The user cannot withdraw properly even if they have sufficient balance.

**Solution:** Synchronize threads to access shared resources (like bank balance) safely.

---

## **2. Common Concurrency Problems**

1. **Race Condition:** Multiple threads access/modify shared data simultaneously → unpredictable results.
2. **Deadlock:** Two or more threads wait for each other indefinitely → no progress.
3. **Starvation:** Some threads never get CPU time because others have higher priority.

---

## **3. Methods of Thread Synchronization in C++**

### **3.1 Mutex (Mutual Exclusion)**

* Locks access to shared resource so only **one thread** can execute critical section at a time.

**Example without Mutex (Race Condition):**

```cpp
#include <iostream>
#include <thread>
using namespace std;

double val = 0;
int cnt = 0;

void add(double num) {
    val += num;
    cnt++;
    cout << "Thread " << cnt << ": " << val << endl;
}

int main() {
    thread t1(add, 300);
    thread t2(add, 600);
    t1.join();
    t2.join();
    cout << "After addition: " << val << endl;
}
```

**Output:** Unpredictable (race condition)

**Fix using Mutex:**

```cpp
#include <iostream>
#include <thread>
#include <mutex>
using namespace std;

double val = 0;
int cnt = 0;
mutex m;

void add(double num) {
    m.lock();        // Lock
    val += num;
    cnt++;
    cout << "Thread " << cnt << ": " << val << endl;
    m.unlock();      // Unlock
}

int main() {
    thread t1(add, 300);
    thread t2(add, 600);
    t1.join();
    t2.join();
    cout << "After addition: " << val << endl;
}
```

**Dry Run Logic:**

* Only one thread enters `add()` at a time.
* Order of thread execution still varies → output order may differ.
* Value of `val` is **always correct**.

**Tip:** Prefer `lock_guard<mutex>` for automatic locking/unlocking:

```cpp
void add(double num) {
    lock_guard<mutex> lock(m);
    val += num;
    cout << "Thread updated val: " << val << endl;
}
```

---

### **3.2 Condition Variable**

* Used to **notify threads about shared resource state**.
* Works with mutex to make threads **wait and resume safely**.

**Example: Addition/Subtraction Synchronization**

```cpp
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
using namespace std;

int val = 0;
mutex m;
condition_variable cv;

void add(int num) {
    lock_guard<mutex> lock(m);
    val += num;
    cout << "After addition: " << val << endl;
    cv.notify_one();  // Notify waiting thread
}

void sub(int num) {
    unique_lock<mutex> lock(m);
    cv.wait(lock, [] { return val != 0; });  // Wait until val != 0
    if(val >= num) val -= num;
    cout << "After subtraction: " << val << endl;
}

int main() {
    thread t2(sub, 600);
    thread t1(add, 900);
    t1.join();
    t2.join();
}
```

**Logic & Dry Run:**

1. `t2` waits for `val != 0`.
2. `t1` adds 900 → notifies `t2`.
3. `t2` subtracts 600 → val = 300.
4. Threads synchronize safely.

**Use Case:** Producer-Consumer problem.

**Important:** Always notify **after unlocking** to avoid missed signals:

```cpp
{
    lock_guard<mutex> lock(m);
    val += num;
}
cv.notify_one(); // notify outside lock
```

---

### **3.3 Promise and Future**

* Allows **one thread to send data** to another safely.
* `std::promise` → sends value.
* `std::future` → receives value (blocks until available).

**Example: Count Even Numbers**

```cpp
#include <iostream>
#include <thread>
#include <future>
using namespace std;

void EvenNosFind(promise<int>&& p, int begin, int end) {
    int count = 0;
    for(int i=begin; i<=end; i++)
        if(i%2==0) count++;
    p.set_value(count);
}

int main() {
    promise<int> p;
    future<int> f = p.get_future();
    thread t(EvenNosFind, move(p), 0, 1000);

    cout << "Even numbers count: " << f.get() << endl;
    t.join();
}
```

**Logic:**

1. `promise` sends value from child thread.
2. `future.get()` blocks main thread until value is ready.
3. Safe data communication without explicit locking.

**Use Case:** One-time result from a background task.

---

## **4. Best Practices in Thread Synchronization**

1. Always **lock shared resources** when accessed by multiple threads.
2. Prefer **RAII-style locking** (`lock_guard` or `unique_lock`) to avoid deadlocks.
3. Use **condition_variable** for producer-consumer type problems.
4. Use **promise/future** for single-result thread communication.
5. **Avoid holding locks while performing long computations**.
6. Avoid nested locks or inconsistent lock orders → prevents deadlocks.

---

## **5. Thinking Approach**

**When to synchronize:**

* Threads **modify or read shared data**.
* Multiple threads **depend on sequence/order of execution**.
* Task requires **notification when a resource is ready**.

**Questions to ask:**

1. Which part of the code is **critical section**?
2. Which threads can **wait safely**?
3. How to **notify waiting threads** efficiently?
4. Can I use **atomic variables** instead of mutex for lightweight tasks?
