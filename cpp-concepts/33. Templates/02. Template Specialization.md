# **Template Specialization in C++**

C++ **Template Specialization** allows us to **customize the behavior** of a template (class or function) for a **specific data type** while keeping the **generic template** for all other types.

---

## **1. Why Template Specialization?**

* Generic templates handle **all types**, but sometimes **specific types need custom behavior**.
* Without specialization, you'd need **if conditions** in your generic code → breaks clean design.
* Example: Printing `char` differently from `int` or `string`.

---

## **2. General Syntax**

### **General Template**

```cpp
template <typename T>
class ClassName {
    // Generic implementation
};
```

### **Specialized Template (for int)**

```cpp
template <>
class ClassName<int> {
    // Custom implementation for int
};
```

**Key points:**

* Use `template <>` (empty angle brackets) for specialization.
* Specify the type for which you want to specialize.

---

## **3. Class Template Specialization Example**

```cpp
#include <iostream>
using namespace std;

// Generic Template
template <typename T>
class Printer {
public:
    void print(T data) {
        cout << "Generic Printing: " << data << endl;
    }
};

// Specialization for char
template <>
class Printer<char> {
public:
    void print(char data) {
        cout << "Character Printing: " << data << endl;
    }
};

int main() {
    Printer<int> p1;     p1.print(100);       // Generic Printing
    Printer<string> p2;  p2.print("Hello");   // Generic Printing
    Printer<char> p3;    p3.print('A');       // Character Printing
}
```

**Output:**

```
Generic Printing: 100
Generic Printing: Hello
Character Printing: A
```

---

## **4. Function Template Specialization**

* Allows defining **custom versions of function templates** for specific types.
* Keep the same **function name** but different behavior.

```cpp
#include <iostream>
using namespace std;

// Generic template
template <typename T>
void display(T value) {
    cout << "Generic display: " << value << endl;
}

// Specialized version for char
template <>
void display<char>(char value) {
    cout << "Specialized display for char: '" << value << "'" << endl;
}

int main() {
    display(42);      // Generic
    display(3.14);    // Generic
    display('A');     // Specialized
    display("Hello"); // Generic
}
```

**Output:**

```
Generic display: 42
Generic display: 3.14
Specialized display for char: 'A'
Generic display: Hello
```

---

## **5. Key Observations**

1. **Prefer Overloading Over Function Specialization:**

   * Compilers **ignore template specialization** if an **overloaded function** exists for the type.

```cpp
void fun(int a) { cout << "Overloaded function\n"; }
template <> void fun<int>(int a) { cout << "Specialized template\n"; }
```

* Calling `fun(10)` → invokes **overload**, not specialization.

2. **Non-type Template Parameters**

   * Can also be specialized, but values must be **const** and known at **compile-time**.

3. **Use Cases:**

   * Printing, formatting, sorting, or type-specific optimizations.

---

## **6. Quick Recap**

| Feature                         | Usage / Notes                                   |
| ------------------------------- | ----------------------------------------------- |
| **Generic template**            | Handles all types                               |
| **Class specialization**        | Custom behavior for specific type               |
| **Function specialization**     | Custom behavior for function of a specific type |
| **Prefer overloads**            | For functions, over specialization              |
| **Non-type template parameter** | Must be `const` and known at compile-time       |
