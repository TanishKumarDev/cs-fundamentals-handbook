# **Templates in C++**

C++ **templates** allow writing **generic code** that works for **any data type**, reducing code duplication and improving **type safety**.

---

## **1. Key Features of Templates**

* Avoid code duplication.
* Type-safe (unlike `void*` or macros).
* Can specialize for specific types.
* Basis for **STL containers** (`vector`, `map`, `set`) and algorithms (`sort`, `max`, `min`).

---

## **2. Template Syntax**

```cpp
template <typename T1, typename T2, ...>
entity_definition
```

* `template` → defines a template.
* `typename` or `class` → type parameter placeholder (interchangeable).
* Can define templates for:

  1. **Functions**
  2. **Classes**
  3. **Variables** (C++14+)

---

## **3. Function Templates**

Allows functions to work with multiple data types.

```cpp
#include <iostream>
using namespace std;

template <typename T>
T myMax(T x, T y) {
    return (x > y) ? x : y;
}

int main() {
    cout << myMax<int>(3, 7) << endl;
    cout << myMax<double>(3.5, 7.5) << endl;
    cout << myMax<char>('g', 'e') << endl;
}
```

**Output:**

```
7
7.5
g
```

**Observation:** The compiler substitutes `T` with the type provided.

---

## **4. Class Templates**

Useful when a class should work with multiple types.

```cpp
template <typename T>
class Geek {
public:
    T x, y;
    Geek(T a, T b) : x(a), y(b) {}
    void getValues() { cout << x << " " << y << endl; }
};

int main() {
    Geek<int> intGeek(10, 20);
    Geek<double> doubleGeek(3.14, 6.28);
    intGeek.getValues();
    doubleGeek.getValues();
}
```

**Output:**

```
10 20
3.14 6.28
```

---

### **4.1 Multiple Type Parameters**

```cpp
template <typename T1, typename T2, typename T3>
class Geek {
public:
    T1 x; T2 y; T3 z;
    Geek(T1 a, T2 b, T3 c) : x(a), y(b), z(c) {}
    void getValues() { cout << x << " " << y << " " << z << endl; }
};

int main() {
    Geek<int, double, string> g1(10, 3.14, "Hello");
    Geek<char, float, bool> g2('A', 5.67f, true);
    g1.getValues();
    g2.getValues();
}
```

**Output:**

```
10 3.14 Hello
A 5.67 1
```

---

## **5. Template Variables (C++14+)**

```cpp
template <typename T> constexpr T pi = T(3.14159);

int main() {
    cout << "Pi as float: " << pi<float> << endl;
    cout << "Pi as double: " << pi<double> << endl;
}
```

**Output:**

```
Pi as float: 3.14159
Pi as double: 3.14159
```

* `constexpr` ensures **compile-time evaluation**.

---

## **6. Default Template Arguments**

```cpp
template <typename T1, typename T2 = double, typename T3 = string>
class Geek {
    T1 x; T2 y; T3 z;
public:
    Geek(T1 a, T2 b, T3 c) : x(a), y(b), z(c) {}
    void getValues() { cout << x << " " << y << " " << z << endl; }
};

int main() {
    Geek<char> g('A', 3.14, "World");
    g.getValues();
}
```

**Output:**

```
A 3.14 World
```

---

## **7. Non-Type Template Parameters**

* Must be **const** and known at **compile-time**.

```cpp
template <class T, int max>
int arrMin(T arr[], int n) {
    int m = max;
    for (int i = 0; i < n; i++)
        if (arr[i] < m) m = arr[i];
    return m;
}

int main() {
    int arr[] = {10, 20, 15, 12};
    cout << arrMin<int, 10000>(arr, 4) << endl;  // Output: 10
}
```

---

## **8. Template Argument Deduction**

* **Function Templates:** auto-deduction since **C++98**.

```cpp
template <typename T>
T multiply(T a, T b) { return a * b; }

int main() {
    cout << multiply(3, 4); // T deduced as int
}
```

* **Class Templates:** auto-deduction since **C++17**.

```cpp
template <typename T>
class Geek {
public:
    T x, y;
    Geek(T a, T b) : x(a), y(b) {}
    void getValues() { cout << x << " " << y << endl; }
};

int main() {
    Geek g1(10, 20);        // T deduced as int
    Geek g2(3.14, 6.28);    // T deduced as double
    g1.getValues();
    g2.getValues();
}
```

---

## **9. Template Metaprogramming**

* Computation at **compile-time** using **recursive templates**.

```cpp
template <int N> struct Factorial {
    static const int value = N * Factorial<N - 1>::value;
};

template <> struct Factorial<0> {
    static const int value = 1;
};

int main() {
    cout << "Factorial of 5 is: " << Factorial<5>::value;  // 120
}
```

* Useful for **optimizations** and **compile-time constants**.

---

### ✅ **Summary Table**

| Template Type      | Example Use Case                    |
| ------------------ | ----------------------------------- |
| Function Template  | Generic functions (max, multiply)   |
| Class Template     | Generic classes (Stack, Queue)      |
| Variable Template  | Constants (pi)                      |
| Non-type Parameter | Compile-time constants (array size) |
| Template Deduction | Auto-detect type (C++17+)           |
| Metaprogramming    | Compile-time computation            |
