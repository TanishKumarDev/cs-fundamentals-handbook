# **Advanced Pointers in C++**

## **Topic 2: Void Pointer in C++**

---

## **1. What is a Void Pointer?**

A **void pointer** (declared using `void*`) is a **generic pointer** that can store the **address of any data type** — integer, float, char, struct, etc.
It does **not have a specific data type** associated with it.

### **Syntax:**

```cpp
void* ptr;
```

It means — `ptr` is a pointer that can hold the address of any variable type.

---

### **Example:**

```cpp
#include <iostream>
using namespace std;

int main() {
    int a = 10;

    void* myptr = &a;  // void pointer storing address of an int

    cout << "Value of a: " << a << endl;
    cout << "Address stored in myptr: " << myptr << endl;

    return 0;
}
```

**Output:**

```
Value of a: 10
Address stored in myptr: 0x7ffd9ac02a64
```

---

## **2. Why Void Pointers Are Needed**

Normally, a pointer type is bound to a specific data type.
For example:

```cpp
int* p;    // can point only to int
float* q;  // can point only to float
```

If you try this:

```cpp
int* p;
float f = 9.5;
p = &f; // ❌ Error: cannot convert float* to int*
```

This fails because pointer types are strongly typed in C++.
But — a **void pointer** can solve this because it’s **type-agnostic**.

---

## **3. How to Use a Void Pointer**

You **can’t directly dereference** a void pointer because its data type is unknown to the compiler.
You must **typecast** it first.

### **Example:**

```cpp
#include <iostream>
using namespace std;

int main() {
    int x = 42;
    void* ptr = &x;  // generic pointer

    // cout << *ptr; ❌ Error: type unknown

    cout << "Value using typecasting: " << *(int*)ptr << endl;
    return 0;
}
```

**Output:**

```
Value using typecasting: 42
```

**Explanation:**
We typecast `void*` → `int*` before dereferencing.
`(int*)ptr` tells the compiler to treat `ptr` as an integer pointer.

---

## **4. Application 1 – Generic Coding**

Void pointers are extremely useful for **generic code**, where one pointer may need to handle **different data types dynamically**.

### **Example:**

```cpp
#include <iostream>
using namespace std;

int main() {
    int n = 10;
    float f = 25.25;
    char c = '$';

    void* ptr;

    ptr = &n;
    cout << "Int value: " << *(int*)ptr << endl;

    ptr = &f;
    cout << "Float value: " << *(float*)ptr << endl;

    ptr = &c;
    cout << "Char value: " << *(char*)ptr << endl;

    return 0;
}
```

**Output:**

```
Int value: 10
Float value: 25.25
Char value: $
```

**Explanation:**

* `ptr` can store addresses of int, float, and char sequentially.
* We just typecast it properly before dereferencing.

This is how **generic programming** is achieved in C/C++ before templates or polymorphism.

---

## **5. Application 2 – Dynamic Memory Allocation**

When you allocate memory dynamically using `new` or `malloc()`, the **returned pointer is of type `void*`** in C (in C++, `new` returns typed pointer).

Still, void pointers are used when **allocating memory generically** and **casting later**.

### **Example:**

```cpp
#include <iostream>
using namespace std;

int main() {
    void* voidPtr = new int;  // allocate memory

    int* intPtr = static_cast<int*>(voidPtr); // typecast

    *intPtr = 42;

    cout << "Value stored: " << *intPtr << endl;

    delete intPtr;  // release memory

    return 0;
}
```

**Output:**

```
Value stored: 42
```

**Explanation:**

* `voidPtr` stores address returned by `new`.
* We cast it to `int*` using `static_cast<int*>` before using it.

This pattern is common in **low-level libraries**, **memory management systems**, and **type-agnostic data structures**.

---

## **6. Application 3 – Callback Functions**

A **callback function** is a function passed as an argument to another function.
When callbacks must handle **different types of data**, `void*` helps make them generic.

### **Example:**

```cpp
#include <iostream>
using namespace std;

// Callback function
void CallbackFunction(void* data, char dataType) {
    switch (dataType) {
        case 'i':
            cout << "Callback for integer: " << *(int*)data << endl;
            break;
        case 'd':
            cout << "Callback for double: " << *(double*)data << endl;
            break;
        default:
            cout << "Unsupported data type" << endl;
    }
}

// Function that accepts callback
void PerformOperation(void* data, char dataType,
                      void (*callback)(void*, char)) {
    callback(data, dataType);
}

int main() {
    int intValue = 7;
    double doubleValue = 8.12;

    PerformOperation(&intValue, 'i', CallbackFunction);
    PerformOperation(&doubleValue, 'd', CallbackFunction);

    return 0;
}
```

**Output:**

```
Callback for integer: 7
Callback for double: 8.12
```

**Explanation:**

* The function `PerformOperation()` takes:

  * `void* data` (generic data)
  * `char dataType` (type identifier)
  * function pointer `callback()`
* The callback uses a `switch` to cast and process data based on type.

This concept is widely used in:

* **Event handling**
* **Threading APIs**
* **Signal processing**
* **C-style generic library functions**

---

## **7. Key Points About Void Pointers**

| Property              | Description                                          |
| --------------------- | ---------------------------------------------------- |
| **Declaration**       | `void* ptr;`                                         |
| **Dereferencing**     | Requires typecasting before use                      |
| **Generic Use**       | Can store addresses of any data type                 |
| **Memory Allocation** | Common in dynamic allocation (`malloc`, `new`)       |
| **Callback Systems**  | Used to pass arbitrary data types                    |
| **Size**              | Same size as any other pointer on given architecture |
| **Caution**           | Incorrect typecasting may cause undefined behavior   |

---

## **8. Advantages of Void Pointers**

1. **Code Reusability:** Write generic functions or code blocks for multiple data types.
2. **Polymorphism Support (Pre-template era):** Helps simulate type abstraction.
3. **Platform Independence:** Works well when data type sizes vary across architectures.
4. **Callback Flexibility:** Simplifies data passing in callback functions.
5. **Low-level System Code:** Useful in drivers, operating systems, or hardware programming where type information may not be known.

---

## **9. Limitations**

* Cannot perform arithmetic directly (`ptr++` invalid).
* Cannot dereference without typecasting.
* Easy to make mistakes if casted incorrectly.
* Less safe than using templates or `std::any` in modern C++.

---

## **10. Summary**

| Concept          | Explanation                                         |
| ---------------- | --------------------------------------------------- |
| **What**         | A generic pointer that can point to any data type   |
| **Why**          | To write type-independent, flexible code            |
| **How to use**   | Store any address → typecast before dereferencing   |
| **Applications** | Generic functions, dynamic memory, callback systems |
| **Caution**      | Always cast properly before use                     |
