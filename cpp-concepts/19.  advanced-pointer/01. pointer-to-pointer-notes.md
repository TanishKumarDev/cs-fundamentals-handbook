# **Advanced Pointers in C++**

## **Topic 1: Pointer to Pointer (Double Pointer)**

---

## **1. Concept Overview**

A **pointer** stores the address of a variable.
A **pointer to pointer** (also called a **double pointer**) stores the address of another pointer.

That means:

* The **first pointer** points to a normal variable.
* The **second pointer** points to the **first pointer**.

This chain can even go further — you can have **triple pointers** (pointer to double pointer), etc.

![](https://media.geeksforgeeks.org/wp-content/uploads/20221111110818/DoublePointer.png)
![](https://media.geeksforgeeks.org/wp-content/uploads/20221111111142/PointersinC.png)
---

### **Example Analogy**

Think of:

* A **variable** as a house.
* A **pointer** as someone holding the **house address**.
* A **double pointer** as someone holding the **address of the person** who knows the house address.

So:

```
variable -> actual value
pointer1 -> address of variable
pointer2 -> address of pointer1
```

---

## **2. Syntax**

```cpp
data_type **pointer_name;
```

You assign it like this:

```cpp
int var = 10;
int *ptr1 = &var;   // pointer to variable
int **ptr2 = &ptr1; // pointer to pointer
```

Here:

* `ptr1` holds the address of `var`
* `ptr2` holds the address of `ptr1`

---

## **3. Example Code**

```cpp
#include <iostream>
using namespace std;

int main() {
    int variable = 169;

    int *pointer1;     // pointer to int
    int **pointer2;    // pointer to pointer

    pointer1 = &variable;
    pointer2 = &pointer1;

    cout << "Value of variable: " << variable << endl;
    cout << "Value using single pointer: " << *pointer1 << endl;
    cout << "Value using double pointer: " << **pointer2 << endl;

    return 0;
}
```

---

### **Output**

```
Value of variable: 169
Value using single pointer: 169
Value using double pointer: 169
```

---

## **4. Memory Visualization (Conceptually)**

Let’s assume memory addresses:

| Variable | Address | Value |
| -------- | ------- | ----- |
| variable | 1000    | 169   |
| pointer1 | 2000    | 1000  |
| pointer2 | 3000    | 2000  |

So:

```
pointer2 → pointer1 → variable → 169
```

Accessing the value:

* `variable` = 169
* `*pointer1` = value at address 1000 = 169
* `**pointer2` = value at address (value at 3000 = 2000) → (value at 2000 = 1000) → (value at 1000 = 169)

---

## **5. How it Works Internally**

* When you use `*pointer1`, you **dereference** one level — it gives the value of the variable.
* When you use `**pointer2`, you **dereference twice** — it gives the value of the original variable through two levels of indirection.

---

## **6. Size of Pointer to Pointer**

The **size of a pointer**, whether it’s a single, double, or triple pointer, **is the same** on a given system.
It depends on the **architecture**, not on what it points to.

### **Example:**

```cpp
#include <iostream>
using namespace std;

int main() {
    int val = 169;
    int *ptr = &val;
    int **double_ptr = &ptr;

    cout << "Size of normal pointer: " << sizeof(ptr) << endl;
    cout << "Size of double pointer: " << sizeof(double_ptr) << endl;

    return 0;
}
```

---

### **Output (on 64-bit system)**

```
Size of normal pointer: 8
Size of double pointer: 8
```

---

### **Explanation**

* On a 64-bit system → pointer size = 8 bytes.
* On a 32-bit system → pointer size = 4 bytes.
* Because they store a memory address, and address width depends on architecture.

---

## **7. Where Are Double Pointers Used?**

1. **Dynamic Memory Allocation of 2D Arrays**

   * Example: `int **arr = new int*[rows];`

2. **Passing Pointers to Functions**

   * Example: To modify a pointer inside a function, you pass its address (i.e., use double pointer).

3. **Linked List / Tree Manipulation**

   * To update `head` pointer inside a function.

4. **Command-Line Arguments**

   * In `main(int argc, char **argv)`, `argv` is a double pointer — array of C-strings.

---

## **8. Example: Modify Pointer Inside a Function**

```cpp
#include <iostream>
using namespace std;

void changePointer(int **pptr) {
    static int newVal = 50;
    *pptr = &newVal;
}

int main() {
    int x = 10;
    int *ptr = &x;

    cout << "Before: " << *ptr << endl;

    changePointer(&ptr); // passing address of pointer (double pointer used)
    
    cout << "After: " << *ptr << endl;

    return 0;
}
```

### **Output**

```
Before: 10
After: 50
```

**Explanation:**

* We pass the address of `ptr` to `changePointer()`.
* Inside the function, we modify `*pptr` (which is `ptr`) to point to a new variable.

---

## **9. Key Points to Remember**

| Concept               | Explanation                                                                          |
| --------------------- | ------------------------------------------------------------------------------------ |
| **Declaration**       | `int **ptr2;` means ptr2 is a pointer to pointer to int                              |
| **Dereference once**  | Gives address stored in pointer1                                                     |
| **Dereference twice** | Gives actual variable value                                                          |
| **Size**              | Same for all pointer levels                                                          |
| **Common Uses**       | 2D arrays, dynamic memory, function pointer manipulation, argv                       |
| **Caution**           | Always initialize before using; uninitialized pointers can cause segmentation faults |

---

## **10. Summary**

* A **double pointer** points to another pointer.
* `*` dereferences one level; `**` dereferences two levels.
* The **size** of a pointer is **independent of its level**.
* Crucial in **dynamic memory**, **function arguments**, and **data structure manipulation**.
