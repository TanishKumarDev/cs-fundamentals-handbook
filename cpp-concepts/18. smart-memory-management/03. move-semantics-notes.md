# Move Semantics in C++

## **Move Semantics in C++ (Simplified Notes)**

### **1Ô∏è‚É£ Concept**

> Move semantics allow **transferring ownership** of resources (like memory, files, etc.) **from one object to another** instead of copying them.

‚úÖ **Goal:**
Avoid unnecessary deep copies ‚Üí improve speed and memory efficiency.

---

### **2Ô∏è‚É£ Why Move Semantics?**

üß† Without move semantics:

* Copying big objects (e.g. `std::vector`, `std::string`) is **expensive**.
* Each copy allocates new memory and duplicates data.

‚ö° With move semantics:

* Instead of copying data, it just **moves the resource pointer**.
* The source object becomes **empty / moved-from**, but valid.

---

### **3Ô∏è‚É£ Example**

```cpp
#include <iostream>
#include <string>
using namespace std;

int main() {
    string original = "Hello, World!";

    // Copy
    string copy = original;

    // Move
    string moved = move(original);

    cout << "Original: '" << original << "'\n";
    cout << "Copy:     '" << copy << "'\n";
    cout << "Moved:    '" << moved << "'\n";
}
```

**Output:**

```
Original: ''
Copy:     'Hello, World!'
Moved:    'Hello, World!'
```

üß© After move:

* `original` becomes empty (moved-from).
* `moved` now owns the resource.

---

### **4Ô∏è‚É£ Copy vs Move (Summary Table)**

| Feature       | Copy                      | Move                         |
| ------------- | ------------------------- | ---------------------------- |
| Action        | Creates full duplicate    | Transfers ownership          |
| Speed         | Slow (allocates + copies) | Fast (just moves pointer)    |
| Source Object | Still valid & full        | Becomes ‚Äúmoved-from‚Äù (empty) |
| When to Use   | When both objects needed  | When source disposable       |
| Example       | `string b = a;`           | `string b = move(a);`        |

---

### **5Ô∏è‚É£ Core Concept ‚Äî Lvalues & Rvalues**

To understand move semantics, we must know **expression categories**.

| Concept    | Meaning                                | Example                            |
| ---------- | -------------------------------------- | ---------------------------------- |
| **Lvalue** | Object with a name & memory            | `int x = 10;`                      |
| **Rvalue** | Temporary value / result of expression | `x + 5`, `10`, `std::string("Hi")` |

#### **Lvalue Reference (T&)**

* Binds to **named** objects (lvalues).

```cpp
int x = 10;
int& ref = x;  // valid
```

#### **Rvalue Reference (T&&)**

* Binds to **temporary** objects.

```cpp
int&& rref = 5;
int&& rref2 = x + 2;
```

---

### **6Ô∏è‚É£ Why Move Semantics Works Only with Rvalues**

* **Rvalues** are **temporary** ‚Üí safe to ‚Äústeal‚Äù resources.
* **Lvalues** may be needed again ‚Üí unsafe to move from them.

---

### **7Ô∏è‚É£ Lvalue Reference vs Rvalue Reference**

| Feature       | Lvalue Ref (`T&`)       | Rvalue Ref (`T&&`)                    |
| ------------- | ----------------------- | ------------------------------------- |
| Binds to      | Named variables         | Temporary values                      |
| Can Appear On | Both sides              | Right side only                       |
| Purpose       | Modify existing objects | Enable move semantics                 |
| Example       | `int& a = x;`           | `int&& b = 10;`                       |
| Use Case      | Pass by reference       | Implement move constructor/assignment |

---

### **8Ô∏è‚É£ Move Constructor & Move Assignment**

Used when an object is **initialized** or **assigned** with an rvalue.

```cpp
class Example {
    int* data;
public:
    Example(int val) {
        data = new int(val);
    }

    // Move Constructor
    Example(Example&& other) noexcept {
        data = other.data;
        other.data = nullptr;
    }

    // Move Assignment
    Example& operator=(Example&& other) noexcept {
        if (this != &other) {
            delete data;
            data = other.data;
            other.data = nullptr;
        }
        return *this;
    }

    ~Example() { delete data; }
};
```

‚úÖ Prevents deep copy
‚úÖ Transfers ownership safely
‚úÖ `noexcept` recommended for STL compatibility

---

### **9Ô∏è‚É£ Move Semantics in STL Containers**

Used heavily in containers (`vector`, `map`, `set`, etc.) for:

* **Reallocation:** Moving instead of copying old elements.
* **Insertion:** Avoiding deep copies with `push_back(move(x))` or `emplace_back()`.

```cpp
vector<string> names;
string temp = "Alice";

names.push_back(move(temp));     // moves temp
names.emplace_back("Bob");       // constructs directly
```

---

### **üîü Summary**

| Concept                   | Description                                          |
| ------------------------- | ---------------------------------------------------- |
| Move semantics            | Transfer ownership instead of copying                |
| Rvalue references (`T&&`) | Enable move semantics                                |
| Move constructor          | Initialize new object by stealing resources          |
| Move assignment           | Transfer ownership during assignment                 |
| Moved-from object         | Valid but empty                                      |
| STL use                   | `std::move`, `emplace_back`, reallocation efficiency |
