# Risks of Using Raw Pointers in C++

##  **1. What Are Raw Pointers?**

Raw pointers are the **basic pointer type** in C++.
They store **memory addresses** directly and give full control of memory ‚Äî but also full **responsibility**.

```cpp
int x = 10;
int* ptr = &x;  // ptr holds address of x
```

They do **not** manage memory automatically.
You must manually allocate (`new`) and deallocate (`delete`).

---

##  **2. Common Risks with Raw Pointers**

Let‚Äôs look at the key dangers one by one üëá

---

### **1Ô∏è‚É£ Memory Leaks**

**What happens:**
You allocate memory with `new`, but forget to `delete`.
That memory is *never freed*, wasting RAM.

```cpp
int* p = new int(42);
cout << *p;      // ‚úÖ works
// forgot delete p ‚ùå ‚Üí memory leak
```

‚û° **Problem:**
In long-running programs (like servers or games), leaks accumulate and crash the system.

‚úÖ **Fix:**
Always `delete` what you `new` ‚Äî or use **smart pointers**.

```cpp
delete p;  // ‚úÖ frees memory
```

---

### **2Ô∏è‚É£ Dangling Pointers**

**What happens:**
You `delete` memory but still use the pointer pointing to it.

```cpp
int* p = new int(99);
delete p;          // memory freed
cout << *p;        // ‚ùå undefined behavior (dangling)
```

‚û° **Problem:**
Using a freed pointer can lead to **crashes or corrupted data**.

‚úÖ **Fix:**
After deleting, **set pointer to `nullptr`:**

```cpp
delete p;
p = nullptr;  // safe
```

---

### **3Ô∏è‚É£ Double Deletion**

**What happens:**
Deleting the same pointer twice.

```cpp
int* p = new int(7);
delete p;
delete p;   // ‚ùå double delete ‚Üí crash
```

‚û° **Problem:**
Undefined behavior, often a runtime abort.

‚úÖ **Fix:**
Set to `nullptr` after first deletion:

```cpp
delete p;
p = nullptr;
```

---

### **4Ô∏è‚É£ Wild Pointers**

**What happens:**
Using an **uninitialized pointer**.

```cpp
int* p;   // not initialized ‚ùå
*p = 10;  // writing to unknown memory
```

‚û° **Problem:**
Could write to random memory ‚Üí crash or corruption.

‚úÖ **Fix:**
Always initialize:

```cpp
int* p = nullptr;  // safe default
```

---

### **5Ô∏è‚É£ Ownership Confusion (Aliasing)**

**What happens:**
Two or more raw pointers own the same heap memory.

```cpp
int* p1 = new int(100);
int* p2 = p1;

delete p1;  // frees memory
delete p2;  // ‚ùå double free (same address)
```

‚û° **Problem:**
No one knows ‚Äúwho owns‚Äù the memory ‚Üí chaos.

‚úÖ **Fix:**
Use **smart pointers** (`unique_ptr` / `shared_ptr`) to define clear ownership.

---

### **6Ô∏è‚É£ No Bounds Checking**

**What happens:**
Accessing array elements outside allocated range.

```cpp
int* arr = new int[3]{1, 2, 3};
arr[5] = 42;   // ‚ùå out of bounds
```

‚û° **Problem:**
Overwrites random memory, causes crashes or bugs.

‚úÖ **Fix:**
Use `std::vector` or smart pointer arrays (`std::unique_ptr<int[]>`).

---

##  **3. Summary Table**

| Risk                    | Description               | Example Problem  | Fix                           |
| ----------------------- | ------------------------- | ---------------- | ----------------------------- |
| **Memory Leak**         | Memory not freed          | Missing `delete` | Use `delete` or smart pointer |
| **Dangling Pointer**    | Pointer to freed memory   | Use-after-delete | Set pointer to `nullptr`      |
| **Double Delete**       | Delete same pointer twice | Crash            | Set to `nullptr`              |
| **Wild Pointer**        | Uninitialized pointer     | Random write     | Initialize to `nullptr`       |
| **Ownership Confusion** | Two pointers, one memory  | Double delete    | Use smart pointers            |
| **No Bounds Checking**  | Out of range access       | Corrupted memory | Use vector                    |

---

##  **4. Smart Alternatives**

‚úÖ **Use Smart Pointers (Modern C++)**

```cpp
#include <memory>
using namespace std;

int main() {
    unique_ptr<int> p1 = make_unique<int>(10);  // auto-deletes
    cout << *p1;  // no need for manual delete
}
```

#### Types:

| Smart Pointer | Ownership                    | Auto Delete               | Use Case         |
| ------------- | ---------------------------- | ------------------------- | ---------------- |
| `unique_ptr`  | Single owner                 | ‚úÖ Yes                     | Default choice   |
| `shared_ptr`  | Multiple owners              | ‚úÖ When last one destroyed | Shared ownership |
| `weak_ptr`    | Non-owning ref to shared_ptr | ‚ùå No                      | Break cycles     |

---

##  **5. Key Takeaways**

* **Raw pointers = power + risk**
* Common issues: leaks, double frees, dangling refs
* Always initialize, delete once, or prefer **smart pointers**
* **Modern C++ (C++11+) ‚Üí Use `unique_ptr` / `shared_ptr` instead of raw pointers**

---
