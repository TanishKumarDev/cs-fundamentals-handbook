# **Smart Pointers in C++ (Easy Notes)**

### **1Ô∏è‚É£ Why Smart Pointers?**

üëâ Normal pointers can cause:

* **Memory leaks** ‚Üí forget to `delete` memory.
* **Dangling pointers** ‚Üí pointer referring to freed memory.
* **Wild pointers** ‚Üí pointer not initialized properly.

**Smart Pointers** solve this ‚Äî they automatically free memory when not used.

üì¶ Defined in `<memory>` header.

---

### **2Ô∏è‚É£ Concept**

> A **smart pointer** is a C++ class (template) that behaves like a normal pointer but automatically manages the lifetime of the object it points to (via destructor).

When the smart pointer goes **out of scope**,
‚Üí the memory is **automatically released** (RAII ‚Äì Resource Acquisition Is Initialization).

---

### **3Ô∏è‚É£ Types of Smart Pointers**

| Type         | Ownership  | Copy Allowed              | Reference Count               | Header     | Introduced                  |
| ------------ | ---------- | ------------------------- | ----------------------------- | ---------- | --------------------------- |
| `auto_ptr`   | Single     | Yes (transfers ownership) | No                            | `<memory>` | C++98 (Deprecated in C++11) |
| `unique_ptr` | Single     | No (only move)            | No                            | `<memory>` | C++11                       |
| `shared_ptr` | Shared     | Yes                       | Yes                           | `<memory>` | C++11                       |
| `weak_ptr`   | Non-owning | N/A                       | Refers to `shared_ptr` object | `<memory>` | C++11                       |

---

### **4Ô∏è‚É£ Types Explained**

#### **(a) `auto_ptr` ‚Äî Deprecated**

* Transfers ownership on copy (dangerous).
* Deleted after C++17.

```cpp
auto_ptr<int> p1(new int(5));
auto_ptr<int> p2 = p1; // Ownership moves to p2
```

‚ö†Ô∏è Now use `unique_ptr` instead.

---

#### **(b) `unique_ptr`**

* **Sole ownership** ‚Üí only one pointer to an object.
* **Cannot copy**, only **move** using `std::move()`.

```cpp
#include <iostream>
#include <memory>
using namespace std;

class Rectangle {
    int l, b;
public:
    Rectangle(int x, int y): l(x), b(y) {}
    int area() { return l * b; }
};

int main() {
    unique_ptr<Rectangle> p1(new Rectangle(10, 5));
    cout << p1->area() << endl;   // 50

    unique_ptr<Rectangle> p2;
    p2 = move(p1);                // Transfer ownership
    cout << p2->area();           // 50
}
```

‚úÖ **Use Case:** Exclusive ownership of a resource.
‚è∞ **Auto deletion** when it goes out of scope.

---

#### **(c) `shared_ptr`**

* **Multiple pointers** can share the same object.
* Uses **reference counting** (via `use_count()`).

```cpp
shared_ptr<Rectangle> p1(new Rectangle(10, 5));
shared_ptr<Rectangle> p2 = p1;

cout << p1->area() << endl;    // 50
cout << p2->use_count();       // 2
```

‚úÖ **Use Case:** Shared ownership (like multiple users referring to same object).

---

#### **(d) `weak_ptr`**

* **Non-owning** reference to an object managed by `shared_ptr`.
* Avoids **circular reference** problem.

```cpp
shared_ptr<Rectangle> p1(new Rectangle(10, 5));
weak_ptr<Rectangle> p2 = p1;   // Doesn't increase count

cout << p1->area() << endl;
cout << p2.use_count();        // 1

auto temp = p2.lock();         // Convert weak_ptr ‚Üí shared_ptr
if (temp)
    cout << temp->area();
```

‚úÖ **Use Case:** Break circular dependencies in graphs, trees, etc.

---

### **5Ô∏è‚É£ Key Differences (Pointer vs Smart Pointer)**

| Feature          | Normal Pointer       | Smart Pointer       |
| ---------------- | -------------------- | ------------------- |
| Memory Release   | Manual (`delete`)    | Automatic           |
| Memory Leak Risk | High                 | Low                 |
| Efficiency       | Manual tracking      | Auto managed        |
| Lifetime         | Need explicit delete | Ends with scope     |
| Syntax           | `int* p`             | `unique_ptr<int> p` |

---

### **6Ô∏è‚É£ Summary Table**

| Smart Pointer | Ownership | Copy           | Reference Count      | Released Automatically | Use Case            |
| ------------- | --------- | -------------- | -------------------- | ---------------------- | ------------------- |
| `auto_ptr`    | Single    | Transfers      | No                   | Yes                    | Deprecated          |
| `unique_ptr`  | Single    | No (move only) | No                   | Yes                    | Exclusive ownership |
| `shared_ptr`  | Shared    | Yes            | Yes                  | Yes                    | Shared ownership    |
| `weak_ptr`    | None      | N/A            | Refers to shared_ptr | No                     | Avoid circular refs |

---

### **7Ô∏è‚É£ Example of Problem Solved**

üëâ Suppose two objects hold `shared_ptr` to each other ‚Äî memory leak (cyclic reference).
‚úÖ Use `weak_ptr` for one of them.

