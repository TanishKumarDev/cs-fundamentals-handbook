# **Dynamic Objects in C++**

C++ allows creation of **objects at runtime**, called **dynamic objects**.
These are created using the `new` operator and destroyed using `delete`.

### **Syntax:**

```cpp
ClassName *ptr_obj;    // pointer to object
ptr_obj = new ClassName; // dynamic object creation
delete ptr_obj;         // delete object dynamically
```

### **Example:**

```cpp
#include<iostream>
using namespace std;

class Test {
    int a, b;
public:
    Test() { cout << "Constructor called\n"; a=1; b=2; }
    ~Test() { cout << "Destructor called\n"; }
    void show() { cout << "a=" << a << ", b=" << b << endl; }
};

int main() {
    Test *ptr = new Test;  // dynamic object creation
    ptr->show();           // access members through pointer
    delete ptr;            // free memory
}
```

**Output:**

```
Constructor called
a=1, b=2
Destructor called
```

---

# **Reference to Dynamic Objects**

* The **address returned by `new`** can be dereferenced and assigned to a **reference**.
* This allows using the reference like a normal object.
* **Limitation:** The memory allocated **cannot be freed** except at program termination.

### **Syntax:**

```cpp
ClassName &refObj = *(new ClassName);
```

### **Example:**

```cpp
#include<iostream>
#include<string.h>
using namespace std;

class Student {
    int roll_no;
    char name[20];
public:
    void setData(int r, char n[20]) {
        roll_no = r;
        strcpy(name, n);
    }
    void outData() {
        cout << "Roll No: " << roll_no << ", Name: " << name << endl;
    }
};

int main() {
    // Reference to dynamic objects
    Student &s1 = *(new Student);
    s1.setData(1, "Ajay");
    s1.outData();

    Student &s2 = *(new Student);
    s2.setData(2, "Aman");
    s2.outData();

    Student &s3 = *(new Student);
    s3.setData(3, "Akshay");

    // Reference to another static object
    Student &s4 = s3;
    s3.outData();
    s4.outData();
}
```

**Output:**

```
Roll No: 1, Name: Ajay
Roll No: 2, Name: Aman
Roll No: 3, Name: Akshay
Roll No: 3, Name: Akshay
```

---

# **Key Points**

1. **Dynamic Objects**:

   * Created at runtime using `new`.
   * Must be deleted using `delete` to avoid memory leaks.
   * Accessed via pointers.

2. **References to Dynamic Objects**:

   * Use dereference `*` with `new`.
   * Behave like normal objects.
   * Memory **cannot be explicitly freed** unless stored in a pointer for `delete`.

3. **When to use**:

   * Useful for **large objects or variable-sized arrays**.
   * Needed when object lifetime must **extend beyond the current scope**.

4. **Memory Management Warning**:

   * If only a reference is used (`Student &s = *(new Student);`) without keeping a pointer, memory **cannot be freed explicitly**.
   * This can cause **memory leaks** in long-running programs.

---