# **Introduction to Object-Oriented Programming (OOP) in C++**

## **1. Background and Motivation**

Before OOP, most programs were written using the **Procedural Programming** approach — where the focus was on **functions and procedures** operating on data.
Example languages: C, Pascal, FORTRAN.

**Problem with procedural approach:**

* As projects grew, managing and debugging code became difficult.
* Data and functions were separated, leading to less security.
* Code reuse was limited; duplication increased.
* No natural mapping to real-world entities.

To solve these, **Object-Oriented Programming (OOP)** was introduced.

---

## **2. What is Object-Oriented Programming (OOP)?**

**Definition:**
OOP is a programming paradigm based on the concept of **objects** — which are instances of **classes**.
Each object contains:

* **Data (attributes)**
* **Methods (functions)** that operate on that data.

In C++, OOP allows you to:

* Combine **data and behavior** into a single unit.
* Represent **real-world entities** in code.
* Create modular, reusable, and maintainable programs.

---

## **3. Key Features of OOP**

| Concept           | Description                                                                                     |
| ----------------- | ----------------------------------------------------------------------------------------------- |
| **Class**         | Blueprint defining structure and behavior.                                                      |
| **Object**        | Instance of a class. Represents real-world entities.                                            |
| **Encapsulation** | Wrapping of data and methods into a single unit (class).                                        |
| **Abstraction**   | Hiding internal implementation details, showing only necessary parts.                           |
| **Inheritance**   | Deriving new classes from existing ones to promote reuse.                                       |
| **Polymorphism**  | One interface, many forms – allows functions or objects to behave differently based on context. |

---

## **4. Why OOP? (Advantages)**

1. **Code Reusability:** Inheritance allows reuse of existing code.
2. **Data Security:** Data is hidden and accessed only through well-defined interfaces.
3. **Modularity:** Each class is independent and reusable.
4. **Scalability:** Easier to extend and maintain large codebases.
5. **Real-world Mapping:** Objects mirror real-world entities.

---

## **5. Core Concepts of OOP**

Let’s go one by one in-depth.

---

### **(1) Class**

A **class** is a **blueprint** for creating objects.
It defines **data members (attributes)** and **member functions (methods)**.

**Syntax:**

```cpp
class ClassName {
private:
    // data members
public:
    // methods
};
```

**Explanation:**

* `Access Specifiers`: Control access (`public`, `private`, `protected`).
* `Body`: Contains variables (data) and methods (functions).
* Acts as a **template** from which multiple objects can be created.

**Example:**

```cpp
#include <iostream>
#include <string>
using namespace std;

class Employee {
private:
    string name;
    float salary;

public:
    Employee(string name, float salary) {
        this->name = name;
        this->salary = salary;
    }

    void displayDetails() {
        cout << "Employee: " << name << endl;
        cout << "Salary: " << salary << endl;
    }
};

int main() {
    Employee emp("Geek", 10000.0f);
    emp.displayDetails();
    return 0;
}
```

**Output:**

```
Employee: Geek
Salary: 10000
```

**Explanation:**

* The class `Employee` defines data and functions.
* `emp` is an object created from `Employee`.
* `this->` keyword differentiates between class members and parameters.

---

### **(2) Object**

An **object** is an **instance** of a class.
It represents a specific real-world entity.

Each object has:

* **State:** Values of data members.
* **Behavior:** Defined by member functions.
* **Identity:** Unique memory reference.

**Example Visualization:**

| Object | name     | salary  |
| ------ | -------- | ------- |
| emp1   | "Geek"   | 10000.0 |
| emp2   | "Tanish" | 25000.0 |

---

### **(3) Abstraction**

**Definition:**
Abstraction is the process of **hiding implementation details** and showing only **essential features**.

**Goal:**
Focus on *what an object does*, not *how it does it*.

**Achieved Using:**

* **Abstract Classes** (contain at least one pure virtual function)
* **Interfaces (conceptually)**

**Example:**

```cpp
#include <iostream>
using namespace std;

class Vehicle {
public:
    virtual void accelerate() = 0;  // Pure virtual function
    virtual void brake() = 0;

    void startEngine() {
        cout << "Engine started!" << endl;
    }
};

class Car : public Vehicle {
public:
    void accelerate() override {
        cout << "Car: Pressing gas pedal..." << endl;
    }

    void brake() override {
        cout << "Car: Applying brakes..." << endl;
    }
};

int main() {
    Vehicle* myCar = new Car();
    myCar->startEngine();
    myCar->accelerate();
    myCar->brake();

    delete myCar;
    return 0;
}
```

**Output:**

```
Engine started!
Car: Pressing gas pedal...
Car: Applying brakes...
```

**Explanation:**

* `Vehicle` is an abstract class.
* `Car` provides actual implementations.
* We use a **base class pointer** to achieve **runtime polymorphism**.

---

### **(4) Encapsulation**

**Definition:**
Encapsulation means **bundling data and methods** into one unit (class) and restricting direct access.

**Achieved By:**

* Declaring variables as **private**.
* Providing **public getters and setters** for controlled access.

**Example:**

```cpp
#include <iostream>
#include <string>
using namespace std;

class Employee {
private:
    int id;
    string name;

public:
    void setId(int id) { this->id = id; }
    void setName(string name) { this->name = name; }

    int getId() { return id; }
    string getName() { return name; }
};

int main() {
    Employee emp;
    emp.setId(101);
    emp.setName("Geek");

    cout << "Employee ID: " << emp.getId() << endl;
    cout << "Employee Name: " << emp.getName() << endl;

    return 0;
}
```

**Output:**

```
Employee ID: 101
Employee Name: Geek
```

**Explanation:**

* Data members are hidden (`private`).
* Controlled access through public methods.

---

### **(5) Inheritance**

**Definition:**
Inheritance allows one class (**child**) to **derive** properties and methods from another class (**parent**).

**Purpose:**
Promotes **reusability** and **hierarchical classification**.

**Syntax:**

```cpp
class Derived : public Base {
    // Additional members
};
```

**Example:**

```cpp
#include <iostream>
using namespace std;

class Animal {
public:
    void eat() { cout << "Animal is eating..." << endl; }
    void sleep() { cout << "Animal is sleeping..." << endl; }
};

class Dog : public Animal {
public:
    void bark() { cout << "Dog is barking!" << endl; }
};

int main() {
    Dog myDog;
    myDog.eat();   // from Animal
    myDog.sleep(); // from Animal
    myDog.bark();  // from Dog
    return 0;
}
```

**Output:**

```
Animal is eating...
Animal is sleeping...
Dog is barking!
```

**Explanation:**

* `Dog` inherits features of `Animal`.
* Demonstrates **"is-a" relationship**: Dog is an Animal.

---

### **(6) Polymorphism**

**Definition:**
Polymorphism means **many forms** — one interface behaving differently based on context.

**Types:**

1. **Compile-time Polymorphism:** Function Overloading, Operator Overloading.
2. **Runtime Polymorphism:** Function Overriding using virtual functions.

---

#### **Example: Function Overloading & Overriding**

```cpp
#include <iostream>
using namespace std;

class Parent {
public:
    void func() {
        cout << "Parent.func()" << endl;
    }

    virtual void func(int a) {
        cout << "Parent.func(int): " << a << endl;
    }
};

class Child : public Parent {
public:
    void func(int a) override {
        cout << "Child.func(int): " << a << endl;
    }
};

int main() {
    Parent parent;
    Child child;
    Parent* ptr = new Child();

    parent.func();      // Overloaded
    parent.func(10);    // Parent version
    child.func(20);     // Overridden
    ptr->func(30);      // Runtime polymorphism

    delete ptr;
    return 0;
}
```

**Output:**

```
Parent.func()
Parent.func(int): 10
Child.func(int): 20
Child.func(int): 30
```

---

## **6. Advantages of OOP**

1. **Reusability:** Use existing code through inheritance.
2. **Modularity:** Classes are independent units.
3. **Security:** Data hidden inside classes.
4. **Maintainability:** Changes in one class do not affect others.
5. **Extensibility:** Easy to add new functionality.

---

## **7. Disadvantages of OOP**

1. **Complexity:** Harder for beginners to understand.
2. **Overhead:** More code for small tasks.
3. **Debugging:** Multiple classes and hierarchies can complicate tracing.
4. **Memory Usage:** More objects mean more memory.

---

## **8. Summary Table**

| Concept       | Definition                | Example Keyword       |
| ------------- | ------------------------- | --------------------- |
| Class         | Blueprint for objects     | `class`               |
| Object        | Instance of a class       | `obj`                 |
| Encapsulation | Binding data and methods  | `private/public`      |
| Abstraction   | Hiding implementation     | `virtual`             |
| Inheritance   | Reuse base class features | `:`                   |
| Polymorphism  | One interface, many forms | `virtual`, `override` |
