# **Size of an Empty Class in C++**

In C++:

* An **empty class** is a class with **no data members**, but it may have **member functions**.
* Even though it has no members, its **size is not zero**.
  **Reason:** Each object must have a **unique address** in memory. The **minimum allocatable size** is **1 byte**, so the compiler ensures distinct addresses for different objects.

---

### **Example: Empty Class Size**

```cpp
#include <iostream>
using namespace std;

class Empty_class {
};

int main() {
    cout << "Size of Empty Class = " << sizeof(Empty_class);
    return 0;
}
```

**Output:**

```
Size of Empty Class = 1
```

---

### **Why not zero?**

* If size were zero, **different objects would share the same memory address**, which is invalid.
* Each object requires a **unique memory location**, even if it stores no data.

---

### **Example: Different objects have different addresses**

```cpp
Empty a, b;
if (&a == &b)
    cout << "Impossible" << endl;
else
    cout << "Fine" << endl;
```

**Output:**

```
Fine
```

---

### **Dynamic allocation of empty objects**

```cpp
Empty* p1 = new Empty;
Empty* p2 = new Empty;

if (p1 == p2)
    cout << "Impossible" << endl;
else
    cout << "Fine" << endl;
```

**Output:**

```
Fine
```

> `new` always returns pointers to **distinct memory locations**, even for empty classes.

---

# **Empty Base Class Optimization (EBCO)**

* When a class **inherits from an empty base class**, the compiler may **optimize** and **not allocate extra space** for the base class.
* Example:

```cpp
class Empty { };
class Derived : Empty {
    int a;
};

int main() {
    cout << sizeof(Derived);  // Usually 4 (size of int)
}
```

* The compiler **does not allocate extra byte** for the empty base class here.

---

### **Example: Sizes with virtual inheritance and members**

```cpp
class Empty { };
class Derived1 : public Empty { };
class Derived2 : virtual public Empty { };
class Derived3 : public Empty { char c; };
class Derived4 : virtual public Empty { char c; };
class Dummy { char c; };

int main() {
    cout << "sizeof(Empty) " << sizeof(Empty) << endl;
    cout << "sizeof(Derived1) " << sizeof(Derived1) << endl;
    cout << "sizeof(Derived2) " << sizeof(Derived2) << endl;
    cout << "sizeof(Derived3) " << sizeof(Derived3) << endl;
    cout << "sizeof(Derived4) " << sizeof(Derived4) << endl;
    cout << "sizeof(Dummy) " << sizeof(Dummy) << endl;
}
```

**Typical Output:**

```
sizeof(Empty) 1
sizeof(Derived1) 1
sizeof(Derived2) 8
sizeof(Derived3) 1
sizeof(Derived4) 16
sizeof(Dummy) 1
```

**Observations:**

1. **Empty class:** 1 byte
2. **Derived1:** Optimized; empty base may take no extra space
3. **Virtual inheritance (Derived2, Derived4):** Requires extra space for **virtual table pointers (vptr)**
4. **Classes with members:** Size increases depending on **members and padding**

---

### **Key Takeaways**

* **Empty class always â‰¥ 1 byte**.
* **Unique addresses** for objects are guaranteed.
* **Virtual inheritance adds extra size** due to vtable pointers.
* **Empty Base Class Optimization (EBCO)** allows the compiler to **reuse memory** for empty base classes.

---