# **Move Constructors in C++**

**Definition:**
A **move constructor** is a special constructor that **transfers resources** from one object to another **without copying**, improving performance.

**Syntax:**

```cpp
ClassName(ClassName&& other);
```

* `ClassName&&` is an **rvalue reference** to another object of the same class.
* The double ampersand `&&` allows binding to **temporary (rvalue) objects**.
* The `other` object is the **source** whose resources will be moved, not copied.

---

## **Basic Example**

```cpp
#include <iostream>
using namespace std;

class Geeks {
private:
    int* ptr;

public:
    // Constructor
    Geeks(int value) {
        ptr = new int(value);
        cout << "Constructor called\n";
    }

    // Move Constructor
    Geeks(Geeks&& obj) {
        cout << "Move Constructor called\n";
        ptr = obj.ptr;      // Transfer ownership
        obj.ptr = nullptr;  // Source becomes empty
    }

    // Destructor
    ~Geeks() {
        delete ptr;
    }

    void display() {
        if(ptr) cout << "Value: " << *ptr << endl;
        else cout << "No data\n";
    }
};

int main() {
    Geeks obj1(42);              
    Geeks obj2 = std::move(obj1); 

    obj1.display(); // No data
    obj2.display(); // Value: 42
}
```

**Output:**

```
Constructor called
Move Constructor called
obj1: No data
obj2: Value: 42
```

---

## **Why Move Constructors?**

* To **transfer resources** instead of copying → faster & efficient
* Useful with **temporary objects** or **large data**
* Avoids **expensive deep copies** required by copy constructors

---

## **Example Without Move Constructor**

* `std::vector` internally copies objects when growing → slow
* Copy constructor creates **deep copies** every time

```cpp
vec.push_back(Move{10});  // triggers copy if move not available
```

---

## **Example With Move Constructor**

* `std::vector` can now **move objects** instead of copying → faster

```cpp
vec.push_back(Move{10});  // uses move constructor
vec.emplace_back(20);     // constructs in-place
```

**Benefit:** Reduces unnecessary copying → better performance

---

## **Noexcept Move Constructor**

* A **`noexcept` move constructor** guarantees **no exceptions** will be thrown
* Important for STL optimizations (e.g., `std::vector` resizing)

### **Without `noexcept`:**

* STL may fallback to **slower copy operations** to avoid exceptions

### **With `noexcept`:**

```cpp
class Test {
public:
    Test() {}
    Test(Test&& other) noexcept { cout << "Move constructor" << endl; }
    Test(const Test& other) { cout << "Copy constructor" << endl; }
};
```

* STL safely moves objects → faster, optimized code

---

**Key Takeaways:**

* Move constructors **steal resources** from rvalues
* Avoid unnecessary deep copies for **performance**
* Use `noexcept` when possible to **enable STL optimizations**
* Essential when working with **large data structures** or **containers**
