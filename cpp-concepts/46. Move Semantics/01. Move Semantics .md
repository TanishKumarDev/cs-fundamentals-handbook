# **Move Semantics in C++**

**Definition:**
Move semantics allows a program to **transfer ownership of resources** (memory, files, etc.) from one object to another **instead of copying** them.

**Benefits:**

* Faster performance
* Less memory usage
* Better efficiency, especially for large objects (`std::vector`, `std::string`, file streams)

---

## **Why Use Move Semantics?**

* Copying objects that own resources is **expensive** (memory & CPU).
* Move semantics **transfers ownership** from one object to another.
* The original object becomes a **“moved-from” state** (valid but no longer owns the resource).

**Example:**

```cpp
#include <iostream>
#include <string>

int main() {
    std::string original = "Hello, World!";

    // Copy
    std::string copy = original;

    // Move
    std::string moved = std::move(original);

    std::cout << "Original: '" << original << "'\n";
    std::cout << "Copy:     '" << copy << "'\n";
    std::cout << "Moved:    '" << moved << "'\n";

    return 0;
}
```

**Output:**

```
Original: ''
Copy:     'Hello, World!'
Moved:    'Hello, World!'
```

---

## **Copy vs Move**

| Feature      | Copy                      | Move                            |
| ------------ | ------------------------- | ------------------------------- |
| What it does | Creates a full duplicate  | Transfers ownership             |
| Speed        | Slower (copies resources) | Faster (moves pointers)         |
| Old object   | Still valid               | Empty / “moved-from”            |
| When used    | Original still needed     | Original temporary / disposable |
| Code example | `std::string b = a;`      | `std::string b = std::move(a);` |

---

## **Lvalues and Rvalues**

* **Lvalue Reference (`T&`)**
  Refers to a **named object** with a stable memory location.

  ```cpp
  int x = 10;
  int& ref = x;
  ref = 20; // x becomes 20
  ```

* **Rvalue Reference (`T&&`)**
  Can bind to **temporary objects** (about to be destroyed).

  ```cpp
  int&& rref = 5;
  int x = 10;
  int&& rref2 = x + 2; // temporary
  ```

**Move semantics only applies to rvalues** because we can safely transfer resources from objects that will disappear.

---

## **Lvalue vs Rvalue References**

| Feature         | Lvalue Reference (`T&`)     | Rvalue Reference (`T&&`)           |
| --------------- | --------------------------- | ---------------------------------- |
| Binds to        | Named objects (lvalues)     | Temporary objects (rvalues)        |
| Appears on      | Left or right of assignment | Usually right side only            |
| Syntax          | `&`                         | `&&`                               |
| Usage           | Refer existing variables    | Move semantics, bind temporaries   |
| Modifies        | Original named object       | Can “steal” resources              |
| Common use case | Pass objects by reference   | Move constructor / move assignment |

---

## **Move Semantics in STL Containers**

* **STL containers** (`std::vector`, `std::map`, `std::set`) use move semantics internally to improve performance.

**Use Cases:**

1. **During Reallocation**

   * Container grows → transfers existing elements
   * If type supports move → moves instead of copies → faster

2. **Inserting Elements**

   * `push_back(std::move(obj))` → moves object into container
   * `emplace_back(args...)` → constructs object **in-place** avoiding copies

**Example:**

```cpp
std::vector<std::string> names;
std::string temp = "Alice";

// Move temp into vector
names.push_back(std::move(temp));

// Construct in-place
names.emplace_back("Bob");
```

**Benefit:** Avoids unnecessary copying → improves performance

---