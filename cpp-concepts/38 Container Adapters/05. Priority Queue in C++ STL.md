# Priority Queue in C++ STL

A **priority queue** is a **container adapter** in C++ that manages elements based on **priority** rather than the order they are inserted. The element with the **highest priority** is always at the front. Internally, it uses a **heap** data structure.

By default, a **max-heap** is implemented, meaning higher values have higher priority. This behavior can be changed to a **min-heap** or custom order using a comparator.

---

## 1. Syntax

```cpp
#include <queue>
using namespace std;

priority_queue<T, Container, Compare> pq;
```

* `T` → Type of elements
* `Container` → Underlying container (`vector` by default)
* `Compare` → Comparison function (`greater<T>` for min-heap)

### Example: Max-heap (default)

```cpp
priority_queue<int> pq;
```

### Example: Min-heap

```cpp
priority_queue<int, vector<int>, greater<int>> pq;
```

---

## 2. Basic Operations

### 2.1 Inserting Elements

* Use `push()`
* Automatically maintains heap order
* **Time Complexity:** O(log n)

```cpp
pq.push(10);
pq.push(5);
pq.push(20);
```

---

### 2.2 Accessing Elements

* Use `top()` → Returns element with **highest priority**
* **Time Complexity:** O(1)

```cpp
cout << pq.top(); // Prints 20 in max-heap
```

---

### 2.3 Deleting Elements

* Use `pop()` → Removes the **top element**
* **Time Complexity:** O(log n)

```cpp
pq.pop(); // Removes 20 in max-heap
cout << pq.top(); // Now prints 10
```

---

### 2.4 Checking Empty

* `empty()` → Returns `true` if the priority queue is empty

```cpp
if (pq.empty()) {
    cout << "Priority queue is empty\n";
} else {
    cout << "Top element: " << pq.top() << endl;
}
```

---

### 2.5 Size of Priority Queue

* `size()` → Returns number of elements

```cpp
cout << "Size: " << pq.size() << endl;
```

---

### 2.6 Pseudo-Traversal

* Only `top()` is accessible; cannot iterate directly.
* Use a **copy** to traverse:

```cpp
priority_queue<int> temp(pq);
while (!temp.empty()) {
    cout << temp.top() << " ";
    temp.pop();
}
```

---

### 2.7 Custom Priority (Min-Heap)

* Using `greater<T>`:

```cpp
priority_queue<int, vector<int>, greater<int>> pq;
pq.push(9);
pq.push(8);
pq.push(6);

priority_queue<int, vector<int>, greater<int>> temp(pq);
while (!temp.empty()) {
    cout << temp.top() << " ";
    temp.pop();
}
```

**Output:**

```
6 8 9
```

---

## 3. Time Complexity

| Operation                 | Time Complexity |
| ------------------------- | --------------- |
| Insertion                 | O(log n)        |
| Deletion                  | O(log n)        |
| Access top element        | O(1)            |
| Initialize from container | O(n)            |

---

## 4. Priority Queue vs Queue

| Feature          | Queue                        | Priority Queue                       |
| ---------------- | ---------------------------- | ------------------------------------ |
| Removal Order    | FIFO                         | Based on priority                    |
| Element Priority | All equal                    | Each element has priority            |
| Use Case         | Task scheduling, print queue | CPU scheduling, Dijkstra's Algorithm |
| Default Behavior | Insert at rear, remove front | Remove element with highest priority |

---

## 5. All Member Functions


| Function    | Definition                                                  |
| ----------- | ----------------------------------------------------------- |
| `empty()`   | Returns whether the priority queue is empty.                |
| `size()`    | Returns the size of the priority queue.                     |
| `top()`     | Returns the top element of the priority queue.              |
| `push()`    | Adds an element into the priority queue.                    |
| `pop()`     | Deletes the top element of the priority queue.              |
| `swap()`    | Swaps the contents of two priority queues of the same type. |
| `emplace()` | Inserts a new element into the priority queue container.    |

## 6. Complete Example Code (All Operations)

```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    // Max-heap priority queue
    priority_queue<int> pq;

    // Insert elements
    pq.push(30);
    pq.push(10);
    pq.push(20);
    pq.push(40);

    cout << "Top element: " << pq.top() << endl; // 40

    // Remove top element
    pq.pop();
    cout << "Top after pop: " << pq.top() << endl; // 30

    // Size
    cout << "Size of priority queue: " << pq.size() << endl; // 3

    // Empty check
    if (!pq.empty())
        cout << "Priority queue is not empty." << endl;

    // Pseudo-traversal
    cout << "Elements in priority order: ";
    priority_queue<int> temp(pq); // copy
    while (!temp.empty()) {
        cout << temp.top() << " ";
        temp.pop();
    }
    cout << endl;

    // Min-heap
    priority_queue<int, vector<int>, greater<int>> minHeap;
    minHeap.push(9);
    minHeap.push(8);
    minHeap.push(6);

    cout << "Min-heap elements: ";
    priority_queue<int, vector<int>, greater<int>> t(minHeap);
    while (!t.empty()) {
        cout << t.top() << " ";
        t.pop();
    }
    cout << endl;

    return 0;
}
```

**Output:**

```
Top element: 40
Top after pop: 30
Size of priority queue: 3
Priority queue is not empty.
Elements in priority order: 30 20 10
Min-heap elements: 6 8 9
```