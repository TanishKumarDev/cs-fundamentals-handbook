# Queue in C++ STL

A **queue** is a **container adapter** that stores elements in **FIFO (First In First Out)** order. The element inserted first is removed first, similar to a real-life queue (like waiting in line).

* **Insertion:** at the **back** (`enqueue`)
* **Deletion:** from the **front** (`dequeue`)

---

## 1. Syntax

```cpp
#include <queue>
using namespace std;

queue<T> q;
```

* `T` → Data type of elements
* `q` → Name of the queue

---

## 2. Basic Operations

### 2.1 Inserting Elements

* Use `push()` to insert at the **back**.
* **Time Complexity:** O(1)

```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    queue<int> q;

    q.push(3);
    q.push(4);
    q.push(5);

    cout << "Queue size after insertion: " << q.size() << endl;
    return 0;
}
```

**Output:**

```
Queue size after insertion: 3
```

---

### 2.2 Accessing Elements

* `front()` → Access the **first element**
* `back()` → Access the **last element**
* **Time Complexity:** O(1)

```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    queue<int> q;
    q.push(3);
    q.push(4);
    q.push(5);

    cout << "Front element: " << q.front() << endl;
    cout << "Back element: " << q.back() << endl;

    return 0;
}
```

**Output:**

```
Front element: 3
Back element: 5
```

---

### 2.3 Deleting Elements

* Use `pop()` to remove the **front element**.
* **Time Complexity:** O(1)

```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    queue<int> q;
    q.push(3);
    q.push(4);
    q.push(5);

    q.pop(); // removes 3

    cout << "Elements after pop: ";
    while(!q.empty()) {
        cout << q.front() << " ";
        q.pop();
    }
    return 0;
}
```

**Output:**

```
Elements after pop: 4 5
```

---

### 2.4 Checking Empty

* `empty()` → Returns true if the queue is empty

```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    queue<int> q;

    if(q.empty())
        cout << "Queue is empty" << endl;

    q.push(100);

    if(!q.empty())
        cout << "Queue is not empty. Front element: " << q.front() << endl;

    return 0;
}
```

**Output:**

```
Queue is empty
Queue is not empty. Front element: 100
```

---

### 2.5 Queue Size

* `size()` → Returns number of elements

```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    queue<int> q;
    q.push(10);
    q.push(5);

    cout << "Queue size: " << q.size() << endl;
    q.pop();
    cout << "Queue size after pop: " << q.size() << endl;

    return 0;
}
```

**Output:**

```
Queue size: 2
Queue size after pop: 1
```

---

### 2.6 Pseudo-Traversal

* Only `front` and `back` are accessible; the queue **cannot be directly traversed**.
* Solution: create a **copy** and pop elements from it.

```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    queue<int> q;
    q.push(3);
    q.push(4);
    q.push(5);

    queue<int> temp(q); // copy queue

    while(!temp.empty()) {
        cout << temp.front() << " ";
        temp.pop();
    }

    return 0;
}
```

**Output:**

```
3 4 5
```

* **Time Complexity:** O(n)
* Original queue remains **unchanged**.

---

## 3. Summary of Member Functions

| Function    | Description                          |
| ----------- | ------------------------------------ |
| `push(elm)` | Insert element at back               |
| `pop()`     | Remove element from front            |
| `front()`   | Access front element                 |
| `back()`    | Access back element                  |
| `empty()`   | Check if queue is empty              |
| `size()`    | Return number of elements            |
| `swap()`    | Swap two queues                      |
| `emplace()` | Construct and insert element at back |

---

## 4. Why Use Queue?

* **Task Scheduling:** First come, first served

* **Breadth-First Search (BFS)** in graphs

* **Order Processing** systems

* **Advantage:** Controlled access prevents accidental modification of middle elements.

* **Limitation:** Cannot traverse or access arbitrary elements directly.

