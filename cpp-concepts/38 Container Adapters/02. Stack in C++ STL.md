# Container Adapters in C++ STL

## Focus Topic: **Stack**

---

## 1. Introduction

### What is a Stack?

A **stack** is a **container adapter** that follows **LIFO (Last In, First Out)** order.

* The **last element inserted** is the **first one to be removed**.
* Operations are performed **only at one end**, called the **top** of the stack.

### Why Stack?

Stacks are essential in problems where **reverse order processing** is required, such as:

* Undo/Redo in editors
* Expression evaluation (infix, postfix, prefix)
* Function call stack (recursion)
* Balanced parentheses checking

### How it Works Internally

* STL `stack` is usually implemented using **deque** internally, but it can also be built using **vector** or **list**.
* Only the **top element** is directly accessible.

---

## 2. Syntax and Declaration

```cpp
#include <stack>
using namespace std;

stack<int> st;  // Empty stack
stack<char> st2; // Stack of characters
```

**Template Format:**

```cpp
stack<datatype> name;
```

**Optional: Specify underlying container**

```cpp
stack<int, vector<int>> st; // Using vector
stack<int, deque<int>> st;  // Using deque
```

---

## 3. Basic Operations

### 3.1 Insertion: `push()`

Adds a new element **to the top** of the stack.

```cpp
stack<int> st;
st.push(10);
st.push(20);
st.push(30);
```

**Time Complexity:** O(1)

---

### 3.2 Accessing Top Element: `top()`

Returns the **top element** without removing it.

```cpp
cout << st.top(); // Output: 30
```

**Note:** Only the top element is accessible.

**Time Complexity:** O(1)

---

### 3.3 Deletion: `pop()`

Removes the **top element** from the stack.

```cpp
st.pop(); // Removes 30
```

**Time Complexity:** O(1)

---

### 3.4 Checking Empty: `empty()`

Returns `true` if the stack is empty, otherwise `false`.

```cpp
if (st.empty())
    cout << "Stack is empty";
else
    cout << "Stack is not empty";
```

---

### 3.5 Size of Stack: `size()`

Returns the **number of elements** in the stack.

```cpp
cout << st.size();
```

---

### 3.6 Pseudo-Traversal

Since stack only allows **top access**, to traverse without modifying the original stack:

```cpp
stack<int> st = {10, 20, 30, 40};
stack<int> temp(st);  // Copy stack

while (!temp.empty()) {
    cout << temp.top() << " ";
    temp.pop();
}
```

**Output:** `40 30 20 10`

**Time Complexity:** O(n)
**Use Case:** Debugging, inspection without affecting original stack

---

## 4. Time Complexity Summary

| Operation          | Time Complexity |
| ------------------ | --------------- |
| push()             | O(1)            |
| pop()              | O(1)            |
| top()              | O(1)            |
| size()             | O(1)            |
| empty()            | O(1)            |
| Traversal (pseudo) | O(n)            |

---

## 5. Example: Basic Stack Program

```cpp
#include <iostream>
#include <stack>
using namespace std;

int main() {
    stack<int> st;

    st.push(10);
    st.push(20);
    st.push(30);

    cout << "Top element: " << st.top() << endl;

    st.pop();
    cout << "Top element after pop: " << st.top() << endl;

    cout << "Stack elements (pseudo-traversal): ";
    stack<int> temp(st);
    while (!temp.empty()) {
        cout << temp.top() << " ";
        temp.pop();
    }
    return 0;
}
```

**Output:**

```
Top element: 30
Top element after pop: 20
Stack elements (pseudo-traversal): 20 10
```

---

## 6. When to Use Stack

| Scenario                | Why Stack                              |
| ----------------------- | -------------------------------------- |
| Expression Evaluation   | LIFO is natural for operators          |
| Undo/Redo Systems       | Most recent action is reversed first   |
| Recursion Simulation    | Tracks function calls in reverse order |
| Backtracking Algorithms | DFS uses stack for state storage       |

---

Stacks are **simple but powerful**, forming the basis for **many algorithms**.
They complement **queues** and **deques**, offering **single-end insertion/deletion** with O(1) efficiency.

