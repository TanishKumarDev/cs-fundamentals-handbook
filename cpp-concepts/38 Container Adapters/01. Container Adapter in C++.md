# Container Adapters in C++ STL

Container adapters are **specialized containers** that provide **restricted interfaces** to existing sequential containers (like `vector`, `deque`, or `list`). They **simplify operations** for specific use cases without exposing all functionalities of the underlying container.

---

## 1. What is a Container Adapter?

* A **container adapter** modifies the interface of an existing container to provide **specific functionality**.
* You **cannot access all elements** like in `vector` or `list`; you only use the operations the adapter allows.
* Advantages:

  * **Simplified usage** for common operations
  * **Time-saving** with built-in operations
  * Built on existing containers (reliable, tested)
  * Controlled access, reducing errors

**Underlying Containers**:

* `stack` → usually uses `deque`
* `queue` → usually uses `deque`
* `priority_queue` → usually uses `vector`

---

## 2. Types of Container Adapters

### 2.1 Stack

* **Principle:** LIFO (Last In First Out)
* **Operations:**

  * `push(elm)` → Insert element at the top
  * `pop()` → Remove top element
  * `top()` → Access top element
  * `empty()` → Check if stack is empty
  * `size()` → Number of elements

**Example: Stack in C++**

```cpp
#include <iostream>
#include <stack>
using namespace std;

int main() {
    stack<int> myStack;

    myStack.push(10);
    myStack.push(20);
    myStack.push(30);

    cout << "Size of stack: " << myStack.size() << endl;

    cout << "Elements in stack: ";
    while(!myStack.empty()) {
        cout << myStack.top() << " ";
        myStack.pop();
    }

    return 0;
}
```

**Output:**

```
Size of stack: 3
Elements in stack: 30 20 10
```

* **Time Complexity:** `O(1)` for push/pop/top
* **Space Complexity:** `O(n)`

---

### 2.2 Queue

* **Principle:** FIFO (First In First Out)
* **Operations:**

  * `push(elm)` → Insert element at the back
  * `pop()` → Remove element from front
  * `front()` → Access first element
  * `back()` → Access last element
  * `empty()` → Check if queue is empty
  * `size()` → Number of elements

**Example: Queue in C++**

```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    queue<int> myQueue;

    myQueue.push(10);
    myQueue.push(20);
    myQueue.push(30);

    cout << "Size of queue: " << myQueue.size() << endl;

    cout << "Elements in queue: ";
    while(!myQueue.empty()) {
        cout << myQueue.front() << " ";
        myQueue.pop();
    }

    return 0;
}
```

**Output:**

```
Size of queue: 3
Elements in queue: 10 20 30
```

* **Time Complexity:** `O(1)` for push/pop/front/back
* **Space Complexity:** `O(n)`

---

### 2.3 Priority Queue

* **Principle:** Highest priority element always at the top (max-heap by default)
* **Operations:**

  * `push(elm)` → Insert element
  * `pop()` → Remove top (highest priority)
  * `top()` → Access top element
  * `empty()` → Check if empty
  * `size()` → Number of elements

**Example: Priority Queue in C++**

```cpp
#include <iostream>
#include <queue>
using namespace std;

int main() {
    priority_queue<int> pq; // Max-heap

    pq.push(30);
    pq.push(10);
    pq.push(20);

    cout << "Size of priority queue: " << pq.size() << endl;

    cout << "Elements in priority queue: ";
    while(!pq.empty()) {
        cout << pq.top() << " ";
        pq.pop();
    }

    return 0;
}
```

**Output:**

```
Size of priority queue: 3
Elements in priority queue: 30 20 10
```

* **Time Complexity:** `O(log n)` for push/pop
* **Space Complexity:** `O(n)`

---

## 3. Comparison of Container Adapters

| Feature              | Stack           | Queue                | Priority Queue                        |
| -------------------- | --------------- | -------------------- | ------------------------------------- |
| Principle            | LIFO            | FIFO                 | Max-heap (priority-based)             |
| Insert/Remove        | Top only        | Push back, pop front | Push any, pop top                     |
| Access               | Top only        | Front and back       | Top only                              |
| Underlying container | deque (default) | deque (default)      | vector (default)                      |
| Use case             | Undo, recursion | Task scheduling      | Event management, sorting by priority |

---

## 4. Summary

* **Container adapters** simplify usage for specific patterns.
* **Stack:** LIFO → last inserted, first removed
* **Queue:** FIFO → first inserted, first removed
* **Priority Queue:** max-priority first → heap-based

