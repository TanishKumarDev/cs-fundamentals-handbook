# **Policy-Based Data Structures (PBDS) in C++**

**Definition:**
PBDS are **advanced STL-like data structures** provided by **GNU C++ extensions**. They allow **ordered sets/maps** with extra functionalities like:

* Finding the **k-th smallest element** in O(log n)
* Finding the **number of elements less than a value** in O(log n)

These operations are **not possible** using standard `std::set` or `std::map` directly.

---

## **1. Required Headers**

```cpp
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace __gnu_pbds;
```

---

## **2. PBDS Containers**

### **Ordered Set**

```cpp
template<typename T>
using ordered_set = tree<
    T, 
    null_type, 
    less<T>, 
    rb_tree_tag, 
    tree_order_statistics_node_update>;
```

* `T` → type of element
* `null_type` → no mapped value (for sets)
* `less<T>` → order by ascending
* `rb_tree_tag` → Red-Black tree
* `tree_order_statistics_node_update` → enables `find_by_order()` & `order_of_key()`

### **Ordered Map**

```cpp
template<typename Key, typename Value>
using ordered_map = tree<
    Key, 
    Value, 
    less<Key>, 
    rb_tree_tag, 
    tree_order_statistics_node_update>;
```

* Works like `map<Key, Value>` but supports advanced operations.

---

## **3. Basic Operations**

### **Insertion**

```cpp
ordered_set<int> s;
s.insert(10);
s.insert(20);
s.insert(30);

for (int x : s) cout << x << " ";  // Output: 10 20 30
```

* Elements **automatically sorted**
* Duplicate insertion is ignored

### **Deletion**

```cpp
s.erase(20);
```

* Removes element if exists, otherwise no error.

### **Search / Find**

```cpp
if(s.find(30) != s.end())
    cout << "Found 30\n";
```

---

## **4. Bound Functions**

* **Lower Bound** → First element ≥ x

```cpp
auto it = s.lower_bound(15); // Points to 20
```

* **Upper Bound** → First element > x

```cpp
auto it = s.upper_bound(20); // Points to 30
```

---

## **5. Size**

```cpp
cout << s.size(); // Number of elements
```

---

## **6. Advanced PBDS Functions**

### **Find by Order**

```cpp
auto it = s.find_by_order(1); // 0-indexed
cout << *it; // 2nd smallest element
```

### **Order of Key**

```cpp
int rank = s.order_of_key(25); 
cout << rank; // Number of elements < 25 → Output: 2
```

**Logic:**

* `find_by_order(k)` → iterator to k-th smallest element
* `order_of_key(x)` → counts how many elements are strictly smaller than `x`

---

## **7. Advantages**

1. **K-th smallest element in O(log n)**
2. **Count of elements smaller than x in O(log n)**
3. **Efficient insert, delete, and search**
4. **Keeps data sorted**
5. **More powerful than standard STL `set` or `map`**

---

## **8. Use Cases**

1. **Rank Queries**

   * Find the rank of a number in a dynamic array.

2. **Order Statistics**

   * Find the median or percentile in streaming data.

3. **K-th element problems**

   * Competitive programming (e.g., “k-th largest element” problems).

4. **Dynamic Counting**

   * Count how many numbers are less than a given value quickly.

---

## **9. Complete Example**

```cpp
#include <bits/stdc++.h>
#include <ext/pb_ds/assoc_container.hpp>
#include <ext/pb_ds/tree_policy.hpp>
using namespace std;
using namespace __gnu_pbds;

template<typename T>
using ordered_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

int main() {
    ordered_set<int> s;

    s.insert(10);
    s.insert(20);
    s.insert(30);

    cout << "Elements: ";
    for(int x : s) cout << x << " ";
    cout << "\n";

    cout << "2nd smallest element: " << *s.find_by_order(1) << "\n"; // 0-indexed
    cout << "Elements smaller than 25: " << s.order_of_key(25) << "\n";

    return 0;
}
```

**Output:**

```
Elements: 10 20 30 
2nd smallest element: 20
Elements smaller than 25: 2
```

---

PBDS is **extremely handy in competitive programming** and scenarios requiring **rank-based queries** or **dynamic order statistics**.

