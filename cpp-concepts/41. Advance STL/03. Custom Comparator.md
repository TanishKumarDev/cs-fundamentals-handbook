# **Custom Comparator in C++**

A **custom comparator** allows you to define your own **comparison logic** for sorting or ordering elements in STL containers like `vector`, `set`, `priority_queue`, etc.

Instead of the default **ascending order**, you can sort:

* In **descending order**
* By **specific properties** of objects
* Using **complex criteria** like frequency or parity

---

## **1. How to Create a Comparator**

There are **3 main ways** to create a custom comparator:

### **a) Function Pointer**

Define a function that implements your comparison logic:

```cpp
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

// Custom comparison function
bool customComparison(int a, int b) {
    return a < b; // ascending order
}

int main() {
    vector<int> myVec = {7, 5, 2, 1, 4, 3};

    sort(myVec.begin(), myVec.end(), customComparison);

    for (int num : myVec)
        cout << num << " ";
}
```

**Output:**

```
1 2 3 4 5 7
```

---

### **b) Lambda Expression**

Inline anonymous function for sorting:

```cpp
vector<int> myVec = {4, 3, 8, 1, 7, 2};

sort(myVec.begin(), myVec.end(), [](int a, int b){
    return a < b; // ascending
});
```

**Advantages:**

* Cleaner syntax
* Can capture variables from surrounding scope

---

### **c) Functor (Function Object)**

Define a struct or class with `operator()`:

```cpp
struct Comparator {
    bool operator()(int a, int b) const {
        return a < b; // ascending
    }
};

vector<int> myVec = {9, 2, 4, 1, 6, 3};
sort(myVec.begin(), myVec.end(), Comparator());
```

**Advantages:**

* Reusable across multiple containers
* Can maintain internal state if needed

---

## **2. Applications of Custom Comparator**

### **a) Sort characters by increasing frequency**

```cpp
string s = "Heellloooo";
map<char,int> freq;
for(char c : s) freq[c]++;

auto compare = [&](char a, char b) { return freq[a] > freq[b]; };
sort(s.begin(), s.end(), compare);

cout << s; // Output: oooollleeH
```

**Logic:**

* Count frequency using `map`
* Sort using a lambda comparator based on frequency

---

### **b) Sort by frequency + secondary order**

```cpp
string s = "hellloooo geek";
map<char,int> freq;
for(char c : s) freq[c]++;

auto compare = [&](char a, char b) {
    if(freq[a] == freq[b]) return a > b; // same freq â†’ descending alphabet
    return freq[a] > freq[b];           // primary: frequency
};

sort(s.begin(), s.end(), compare);
cout << s; // Output: oooollleeekhg
```

---

### **c) Sort numbers by number of set bits**

```cpp
vector<int> p = {1, 5, 8, 13, 2, 17};

sort(p.begin(), p.end(), [&](int a, int b){
    return __builtin_popcount(a) < __builtin_popcount(b);
});

for(int x : p) cout << x << " ";
```

**Output:**

```
1 8 2 5 17 13
```

**Logic:**

* Use `__builtin_popcount` to count set bits
* Sort based on the count

---

### **d) Segregate even and odd numbers**

```cpp
vector<int> p = {1, 2, 3, 4, 5, 6, 7};

sort(p.begin(), p.end(), [&](int a, int b){
    return a % 2 < b % 2; // even first
});

for(int x : p) cout << x << " ";
```

**Output:**

```
2 4 6 1 3 5 7
```

**Logic:**

* Comparator moves **even numbers before odd numbers** using modulo

---

## **3. Advantages of Custom Comparators**

1. **Custom Sorting Logic:** Define how elements are compared.
2. **Works with Complex Data:** Sort objects by multiple properties.
3. **Flexible with STL:** Works with `sort`, `set`, `priority_queue`, etc.
4. **Improves Code Reusability:** Functors or lambdas can be reused.

---

## **4. Summary Table**

| Method                 | Syntax / Example                 | Use Case                   |
| ---------------------- | -------------------------------- | -------------------------- |
| Function Pointer       | `bool cmp(int a,int b)`          | Simple sorting functions   |
| Lambda Expression      | `[](int a,int b){return a<b;}`   | Inline, can capture scope  |
| Functor / Function Obj | `struct CMP{bool operator()...}` | Reusable across containers |

---

Custom comparators are **essential for complex sorting tasks** in **competitive programming**, **data processing**, and **any scenario where STL containers need special ordering**.

