# C++ Friend Class and Friend Function

## Overview

* **Friend functions** and **friend classes** allow **access to private and protected members** of a class.
* Friendship is **not mutual** and **not inherited**.
* Declared using the `friend` keyword.

---

## 1. Friend Class

* A **friend class** can access **private/protected members** of another class.
* Friendship is **one-way**: if `A` is friend of `B`, `B` cannot access `A`â€™s private members unless declared friend.

**Example:**

```cpp
#include <iostream>
using namespace std;

class Geeks {
private:
    int private_variable;

protected:
    int protected_variable;

public:
    Geeks() : private_variable(10), protected_variable(99) {}

    // Declare GFG as a friend class
    friend class GFG;
};

class GFG {
public:
    void display(Geeks& t) {
        cout << "Private Variable = " << t.private_variable << endl;
        cout << "Protected Variable = " << t.protected_variable << endl;
    }
};

int main() {
    Geeks g;
    GFG fri;
    fri.display(g);
    return 0;
}
```

**Output:**

```
Private Variable = 10
Protected Variable = 99
```

> Note: `friend class` can be declared anywhere inside the class (private, protected, or public section).

---

## 2. Friend Function

* **Friend functions** are **non-member functions** that can access private/protected members.
* Can be **global functions** or **member functions of another class**.

---

### 2.1 Global Function as Friend

```cpp
#include <iostream>
using namespace std;

class Base {
private:
    int private_variable;

protected:
    int protected_variable;

public:
    Base() : private_variable(10), protected_variable(99) {}

    // Friend function declaration
    friend void friendFunction(Base& obj);
};

void friendFunction(Base& obj) {
    cout << "Private Variable: " << obj.private_variable << endl;
    cout << "Protected Variable: " << obj.protected_variable << endl;
}

int main() {
    Base obj;
    friendFunction(obj);
    return 0;
}
```

**Output:**

```
Private Variable: 10
Protected Variable: 99
```

---

### 2.2 Member Function of Another Class as Friend

* Requires **forward declaration**.
* Example:

```cpp
#include <iostream>
using namespace std;

class Base; // Forward declaration

class GFG {
public:
    void GFG_Function(Base& obj);
};

class Base {
private:
    int private_variable;
protected:
    int protected_variable;

public:
    Base() : private_variable(10), protected_variable(99) {}

    friend void GFG::GFG_Function(Base&);
};

void GFG::GFG_Function(Base& obj) {
    cout << "Private Variable: " << obj.private_variable << endl;
    cout << "Protected Variable: " << obj.protected_variable << endl;
}

int main() {
    Base obj1;
    GFG obj2;
    obj2.GFG_Function(obj1);
    return 0;
}
```

**Output:**

```
Private Variable: 10
Protected Variable: 99
```

> Note: Order of class and function definitions matters for member functions as friends.

---

### 2.3 Friend Function Friendly to Multiple Classes

```cpp
#include <iostream>
using namespace std;

class ABC; // Forward declaration

class XYZ {
    int x;
public:
    void set_data(int a) { x = a; }
    friend void max(XYZ, ABC);
};

class ABC {
    int y;
public:
    void set_data(int a) { y = a; }
    friend void max(XYZ, ABC);
};

void max(XYZ t1, ABC t2) {
    if (t1.x > t2.y) cout << t1.x;
    else cout << t2.y;
}

int main() {
    ABC _abc;
    XYZ _xyz;
    _xyz.set_data(20);
    _abc.set_data(35);

    max(_xyz, _abc); 
    return 0;
}
```

**Output:**

```
35
```

---

## Advantages of Friend Functions

* Access members **without inheritance**.
* Acts as a **bridge** between classes.
* Useful for **operator overloading**.
* Can be declared in any access section (public/private/protected).

---

## Demerits

* Violates **encapsulation** (accesses private data from outside).
* Cannot use **run-time polymorphism**.
* Overusing friend functions/classes reduces **encapsulation effectiveness**.
* **Friendship is not inherited**.

---