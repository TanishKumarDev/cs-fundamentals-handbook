# Day 3/100 - Database Modeling and Relationships

[Database Modeling and Relationships](https://www.tldraw.com/f/vSBHcDMKkhVVCzCmu5UQV?d=v-504.1024.1536.695.MkB9KCqVaZbUN5ohKBEru)

## Overview / Introduction
Database relationships model real-world connections between entities, enabling scalable and organized data storage. Just as people connect with objects and other people in daily life, database tables connect through defined relationships to solve practical data storage problems efficiently.

## What, Why, How

### What are Database Relationships?
Database relationships define how different data entities connect and interact with each other. They mirror real-world connections, such as a person and their passport, or a singer and their songs.

### Why Relationships Matter
- **Scalability**: Prevent table bloat and column explosion
- **Organization**: Logical separation of related data
- **Efficiency**: Optimized storage and faster queries
- **Data Integrity**: Maintain consistency across connected data
- **Real-world Mapping**: Directly model actual business scenarios

### How Relationships Work
Relationships are implemented using foreign keys that reference primary keys in other tables. The three fundamental relationship types handle different connection scenarios between entities.

## Core Concepts

### Three Fundamental Relationship Types

#### 1. One-to-One Relationship
- One record in Table A relates to exactly one record in Table B
- **Example**: User and Passport
- **Implementation**: Foreign key in either table referencing the other

#### 2. One-to-Many Relationship
- One record in Table A relates to multiple records in Table B
- **Example**: Course and Modules, Mother and Children
- **Implementation**: Foreign key on the "many" side table

#### 3. Many-to-Many Relationship
- Multiple records in Table A relate to multiple records in Table B
- **Example**: Doctors and Patients, Students and Courses
- **Implementation**: Requires a pivot/junction table with foreign keys from both tables

### Key Database Elements
- **Primary Key**: Unique identifier for each table record
- **Foreign Key**: Reference to a primary key in another table
- **Pivot Table**: Intermediate table for many-to-many relationships
- **Entities**: Real-world objects represented as database tables

## Examples / Use-Cases

### Real-World Analogies
- **One-to-One**: Person ↔ Passport, User ↔ Contact Details
- **One-to-Many**: Singer ↔ Songs, Course ↔ Modules, Mother ↔ Children
- **Many-to-Many**: Doctors ↔ Patients, Students ↔ Courses, Books ↔ Authors

### Practical Database Scenarios

#### Music Application Example
**Problem**: Store singers and their songs without column explosion
**Solution**: Separate tables with one-to-many relationship
- Singers table (ID, Name)
- Songs table (ID, Title, SingerID - foreign key)

#### LMS (Learning Management System) Example
- **Users ↔ Contacts**: One-to-one (user contact details)
- **Courses ↔ Modules**: One-to-many (course structure)
- **Students ↔ Courses**: Many-to-many (enrollments via pivot table)

## Observations

### Design Considerations
- **Avoid Column Explosion**: Don't keep adding columns for similar data
- **JSON/Array Limitations**: While possible, large lists can hit database limits
- **Query Performance**: Proper relationships enable efficient data retrieval
- **Business Logic Mapping**: Relationships should mirror actual business rules

### Implementation Patterns
- Foreign key naming convention: `table_name_id`
- Pivot tables for many-to-many relationships
- Separation of concerns through table normalization
- Use of JOIN operations to retrieve related data

## Advantages / Disadvantages

### Advantages
- **Scalable Design**: Handles growing data efficiently
- **Data Integrity**: Prevents duplication and inconsistencies
- **Flexible Queries**: Enables complex data retrieval
- **Maintainable**: Easier to update and modify
- **Performance**: Optimized storage and indexing

### Disadvantages
- **Complexity**: More tables to manage
- **Learning Curve**: Requires understanding of relationships
- **JOIN Overhead**: Complex queries may require multiple JOINs
- **Design Time**: Requires careful planning and analysis

## Key Takeaways

### Fundamental Principles
1. **Identify Real-world Connections**: Map actual relationships between entities
2. **Choose Appropriate Relationship Type**: Select based on business rules
3. **Implement with Foreign Keys**: Establish connections between tables
4. **Use Pivot Tables for Many-to-Many**: Essential for complex relationships

### Practical Implementation
- One-to-one: Foreign key in either table
- One-to-many: Foreign key on the "many" side
- Many-to-many: Create pivot table with both foreign keys
- Always consider scalability during design

### Design Process
1. Identify entities from requirements
2. Determine relationships between entities
3. Choose appropriate relationship types
4. Implement with proper foreign keys
5. Test with sample data and queries

## Interview Insights
- Be able to explain all three relationship types with examples
- Understand when to use each relationship type
- Know how to implement many-to-many relationships
- Be prepared to discuss trade-offs of different designs
- Demonstrate understanding of foreign keys and pivot tables

## Summary
Database relationships provide a systematic way to model real-world connections between data entities. The three fundamental types—one-to-one, one-to-many, and many-to-many—cover all possible connection scenarios. Proper implementation using foreign keys and pivot tables enables scalable, efficient, and maintainable database designs that can handle complex business requirements while maintaining data integrity.

# PRACTICE - Database Relationships: Library Management System

## Overview / Introduction
This practical example demonstrates how to apply database relationships to build a complete Library Management System. We'll model real-world entities like users, books, authors, and borrowing activities using the three fundamental relationship types.

## Core Concepts Applied

### Entities Identified
- **Users**: Library members who borrow books
- **Books**: Items available in the library
- **Authors**: Writers of the books
- **Borrows**: Tracking book lending transactions

## Database Schema Design

### 1. Users Table (One-to-One with Contact Details)
```sql
CREATE TABLE users (
    user_id INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE user_contacts (
    contact_id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT UNIQUE,  -- One-to-one relationship
    email VARCHAR(100),
    phone VARCHAR(15),
    address TEXT,
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);
```

**Sample Data:**
```
Users:
user_id | username
1       | alice_johnson
2       | bob_smith

User_Contacts:
contact_id | user_id | email               | phone       | address
1          | 1       | alice@email.com     | 1234567890  | 123 Main St
2          | 2       | bob@email.com       | 0987654321  | 456 Oak Ave
```

### 2. Authors Table (One-to-Many with Books)
```sql
CREATE TABLE authors (
    author_id INT PRIMARY KEY AUTO_INCREMENT,
    author_name VARCHAR(100) NOT NULL,
    nationality VARCHAR(50)
);

CREATE TABLE books (
    book_id INT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(200) NOT NULL,
    isbn VARCHAR(20) UNIQUE,
    publication_year INT,
    author_id INT,  -- Many books, one author
    FOREIGN KEY (author_id) REFERENCES authors(author_id)
);
```

**Sample Data:**
```
Authors:
author_id | author_name    | nationality
1         | J.K. Rowling   | British
2         | George Orwell  | British

Books:
book_id | title               | isbn       | publication_year | author_id
1       | Harry Potter 1      | 123456789  | 1997             | 1
2       | Harry Potter 2      | 123456790  | 1998             | 1
3       | 1984                | 123456791  | 1949             | 2
4       | Animal Farm         | 123456792  | 1945             | 2
```

### 3. Borrows Table (Many-to-Many between Users and Books)
```sql
CREATE TABLE borrows (
    borrow_id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT,
    book_id INT,
    borrow_date DATE NOT NULL,
    due_date DATE NOT NULL,
    return_date DATE NULL,
    FOREIGN KEY (user_id) REFERENCES users(user_id),
    FOREIGN KEY (book_id) REFERENCES books(book_id)
);
```

**Sample Data:**
```
Borrows:
borrow_id | user_id | book_id | borrow_date | due_date    | return_date
1         | 1       | 1       | 2024-01-15  | 2024-01-29  | 2024-01-28
2         | 1       | 3       | 2024-01-20  | 2024-02-03  | NULL
3         | 2       | 2       | 2024-01-18  | 2024-02-01  | 2024-01-25
4         | 2       | 4       | 2024-01-22  | 2024-02-05  | NULL
```

## Relationship Analysis

### 1. One-to-One Relationship
**Users ↔ User_Contacts**
- Each user has exactly one contact record
- Each contact record belongs to exactly one user
- Implemented with unique foreign key constraint

### 2. One-to-Many Relationship  
**Authors ↔ Books**
- One author can write many books
- Each book has exactly one author
- Foreign key on the "many" side (books table)

### 3. Many-to-Many Relationship
**Users ↔ Books** (through Borrows table)
- One user can borrow many books
- One book can be borrowed by many users (over time)
- Requires pivot table (borrows) with foreign keys to both tables

## Practical Queries

### Find all books borrowed by a specific user
```sql
SELECT u.username, b.title, a.author_name, br.borrow_date, br.due_date
FROM users u
JOIN borrows br ON u.user_id = br.user_id
JOIN books b ON br.book_id = b.book_id
JOIN authors a ON b.author_id = a.author_id
WHERE u.username = 'alice_johnson';
```

### Find all books by a specific author
```sql
SELECT b.title, b.publication_year
FROM books b
JOIN authors a ON b.author_id = a.author_id
WHERE a.author_name = 'J.K. Rowling';
```

### Find currently borrowed books
```sql
SELECT u.username, b.title, br.borrow_date, br.due_date
FROM borrows br
JOIN users u ON br.user_id = u.user_id
JOIN books b ON br.book_id = b.book_id
WHERE br.return_date IS NULL;
```

## Observations

### Business Rules Enforced
1. **User Validation**: Only registered users can borrow books
2. **Book Availability**: Same book can be borrowed by different users at different times
3. **Contact Management**: Each user has dedicated contact information
4. **Author Attribution**: Clear book-to-author relationships maintained

### Scalability Benefits
- **Users**: Can add unlimited users without table structure changes
- **Books**: Easy to add new books and authors
- **Borrowing History**: Complete tracking of all transactions
- **Contact Updates**: Modify contact info without affecting user data

## Advantages Demonstrated

### Data Integrity
- No duplicate contact records per user
- Clear book authorship maintained
- Complete borrowing history preserved

### Query Flexibility
- Easy to find user borrowing history
- Simple author bibliography queries
- Efficient overdue book tracking

### Maintenance
- Add new relationship types easily
- Modify individual entities independently
- Scale to thousands of records efficiently

## Key Takeaways

### Relationship Implementation
1. **One-to-One**: Use unique foreign key constraint
2. **One-to-Many**: Foreign key on the "many" side
3. **Many-to-Many**: Pivot table with both foreign keys

### Design Principles
- Each entity gets its own table
- Relationships implemented through foreign keys
- Business logic reflected in relationship types
- Consider future scalability during design

### Real-World Mapping
The library system perfectly mirrors actual library operations:
- Members have unique identities (one-to-one)
- Authors produce multiple works (one-to-many)  
- Books circulate among members (many-to-many)

This implementation provides a solid foundation that can scale to handle thousands of users, books, and transactions while maintaining data integrity and enabling powerful query capabilities.

**Assignment Complete**: This Library Management System demonstrates practical application of all three database relationship types in a real-world scenario.
