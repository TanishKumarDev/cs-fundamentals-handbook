# Multi-tasking vs Multi-threading OS

## **1. Key Definitions**

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1749314398514/4f53c546-fcc4-4ccd-b7a6-487b32ba0249.png)

### **Program vs Process vs Thread**

| Term | Definition | Example |
| --- | --- | --- |
| **Program** | Static executable file (e.g., `.exe`). | `paint.exe` on disk. |
| **Process** | Program **under execution** in RAM. | Running `paint.exe` in Task Manager. |
| **Thread** | **Lightweight sub-process** within a process. Independent execution path. | Auto-save in Word, spell-check in Chrome. |

**Analogy**:

- **Program =** The **user file** on disk is just data saved ‚Äî like the recipe book.
- **Process =** When you **open the file in MS Word**, it becomes a **process** ‚Äî active editing environment with allocated memory, handles, and CPU time.
- **Thread =** nside that process, MS Word creates **multiple threads** to perform tasks concurrently:
    - Main thread handles user input and UI.
    - Background threads handle spell check, auto-save, formatting updates, grammar checking ‚Äî all working in parallel without freezing the UI.

---

## **2. Multi-Tasking (Process-Level)**

### **What?**

- Running **multiple processes** on a **single CPU** using **time-sharing**.
- *Example*: Switching between Chrome, Word, and Spotify.

### **How?**

- **Context Switching**: Saves/restores process states (PCB) to share CPU time.
- **Goals**:
    - Maximize CPU utilization.
    - Prevent starvation (all processes get turns).

### **Pros & Cons**

‚úÖ **Isolation**: Processes can‚Äôt access each other‚Äôs memory (security).

‚ùå **Overhead**: Context switching is slower (due to memory swaps).

<aside>
üí°

## PCB ?

Process Control Block (PCB) is **a data structure that holds all the essential information about a process**. It's like a file cabinet for each process, containing data needed to manage and execute it effectively. The PCB is used by the operating system to track the state of a process, manage its resources, and switch between different processes.

![Process Table and Process Control Block (PCB) | GeeksforGeeks](https://media.geeksforgeeks.org/wp-content/uploads/20241122132710403798/process---------control---------block.webp)

Here's a more detailed look at what a PCB does:

**Key Functions of a PCB:**

- **Process Identification:** Each process has a unique identifier (PID) stored in its PCB.
- **Process State:** The PCB keeps track of the current state of a process, such as running, waiting, or ready.
- **Program Counter:** This value indicates the next instruction to be executed by the CPU.
- **CPU Registers:** The PCB stores the values of CPU registers, which are used to hold data and instructions during processing.
- **Memory Management:** The PCB tracks the memory allocated to a process, including its base address and size.
- **Resource Management:** It also stores information about the resources used by the process, such as open files and network connections.
- **Scheduling Information:** The PCB contains data relevant to process scheduling, such as priority and waiting time.

**Why are PCBs important?**

- **Process Management:**
    
    The operating system uses PCBs to manage and control processes, including creating, deleting, and suspending them.
    
- **Context Switching:**
    
    PCBs are essential for context switching, which allows the operating system to quickly switch between different processes.
    
- **Resource Allocation:**
    
    The PCB helps the operating system allocate and manage resources efficiently.
    
- **Process Scheduling:**
    
    PCBs provide the necessary information for the scheduler to make decisions about which process to run next.
    

In essence, the PCB is a crucial data structure that allows the operating system to manage and control multiple processes concurrently.

</aside>

---

## **3. Multi-Threading (Thread-Level)**

### **What?**

- Dividing **one process** into **multiple threads** for parallel execution.
- *Example*:
    - **Chrome**: Each tab runs as a thread.
    - **Word**: Typing + spell-check + auto-save threads.

### **How?**

- Threads **share the same memory space** of their parent process.
- **Requirement**: Multi-core CPU for true parallelism.

### **Pros & Cons**

‚úÖ **Faster**: No memory switching overhead (threads share RAM).

‚ùå **No Isolation**: Threads can corrupt shared data (requires synchronization).

## Multithreading ?

Multithreading, specifically at the thread-level, refers to **a technique where a single process is divided into multiple threads, allowing these threads to execute concurrently within the same process space**. This concurrency enables more efficient utilization of system resources, especially CPU cores, and can improve application responsiveness and performance.

**Key Concepts:**

- **Concurrency:**
    
    The ability of multiple threads to execute seemingly at the same time, even if they are actually being switched between rapidly by the CPU.
    
- **Thread:**
    
    A lightweight unit of execution within a process, sharing the process's resources like memory, code, and data.
    
- **Process:**
    
    A program in execution, with its own memory space, code, and data.
    
- **Sharing:**
    
    Threads within the same process can share resources like memory and file handles, enabling communication and collaboration between them.
    

**Benefits of Multithreading:**

- **Improved CPU Utilization:**
    
    Multiple threads can be executed in parallel, especially on multi-core processors, increasing overall CPU utilization.
    
- **Enhanced Application Responsiveness:**
    
    By offloading tasks to background threads, the main application thread can remain responsive to user interactions.
    
- **Simplified Program Design:**
    
    Multithreading can break down complex tasks into smaller, manageable threads, making the program structure more modular and easier to maintain.
    
- **Efficient Resource Sharing:**
    
    Threads within the same process can share resources like code and data, reducing resource wastage.
    
- **Reduced Context Switching Overhead:**
    
    Compared to process creation, thread creation and context switching are typically faster.
    

**Multithreading Models:**

There are several multithreading models that define how user-level threads are mapped to kernel-level threads. The most common models include:

- **Many-to-One:** Many user-level threads are mapped to a single kernel thread.
- **One-to-One:** Each user-level thread is mapped to a distinct kernel thread.
- **Many-to-Many:** Many user-level threads can be mapped to a smaller number of kernel threads, and the operating system can dynamically manage the mapping.

**Examples of Multithreading:**

- **Web Browsers:**
    
    Multiple tabs can be handled as separate threads, allowing for concurrent loading and display of web pages.
    
- **Image Processing:**
    
    Complex image processing tasks can be parallelized using multiple threads for faster results.
    
- **Video Encoding:**
    
    Encoding video streams can be accelerated by using multithreading to process different parts of the video concurrently.
    
- **Graphical User Interfaces (GUIs):**
    
    Background tasks can be handled by separate threads to prevent the UI from freezing.
    

**Drawbacks of Multithreading:**

- **Complexity:**
    
    Managing multiple threads and their interactions can be complex, especially when dealing with shared resources.
    
- **Debugging:**
    
    Identifying and fixing issues related to race conditions and deadlocks in multithreaded applications can be challenging.
    
- **Overhead:**
    
    Creating and managing threads can have some overhead, especially if the number of threads is too high.
    

---

## **4. Key Differences**

![](https://cdn.hashnode.com/res/hashnode/image/upload/v1749314360761/86810943-4a95-4044-9c66-3d13c4bd30e9.png)

| Feature | Multi-Tasking | Multi-Threading |
| --- | --- | --- |
| **Unit** | Processes (independent). | Threads (within one process). |
| **Memory** | Isolated (protected). | Shared (no isolation). |
| **CPU Cores** | Works on single-core. | Needs multi-core for speed gain. |
| **Context Switch** | Slow (memory swapped). | Fast (same memory space). |
| **Use Case** | Running multiple apps. | Parallel tasks in one app (e.g., gaming: rendering + AI). |

---

## **5. Why Does It Matter?**

### **Multi-Tasking Use Cases**

- OS runs **multiple apps** simultaneously.
- *Example*: Browsing while listening to music.

### **Multi-Threading Use Cases**

1. **Performance Boost**:
    - *Example*: Converting 100 images ‚Üí 10 threads = 10x faster (on 10 cores).
2. **Responsiveness**:
    - *Example*: UI stays responsive while a thread handles background saves.

---

## **6. Common Interview Questions**

1. **Can multi-threading work on a single-core CPU?**
    - Yes, but threads **time-share** the core (no speed gain).
2. **Why is thread context switching faster?**
    - No memory swaps (threads share the same address space).
3. **What‚Äôs a "lightweight process"?**
    - Thread (lighter than a process due to shared resources).

---

## **7. Practical Example: Image Converter**

### **Sequential (Single Thread)**

1. Convert Image A ‚Üí 10 sec.
2. Convert Image B ‚Üí 10 sec.
    
    **Total**: 20 sec.
    

### **Multi-Threaded (2 Threads on 2 Cores)**

1. Thread 1: Convert Image A.
2. Thread 2: Convert Image B.
    
    **Total**: 10 sec (parallel execution).
    

---

## **8. Key Takeaways**

1. **Process** = Whole program. **Thread** = Sub-task.
2. **Multi-Tasking**: For multiple apps (isolated).
3. **Multi-Threading**: For speed within one app (shared memory).
4. **Hardware Matters**: Multi-threading needs multi-core CPUs.