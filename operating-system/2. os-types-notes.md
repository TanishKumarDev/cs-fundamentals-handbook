# OS Types
## **1. Goals of an OS**

**Why do we need different OS types?**

To achieve:

1. **Maximum CPU Utilization**: Keep CPU busy (no idle time).
    - *Example*: If Process 1 waits for I/O, run Process 2.
2. **No Process Starvation**: All processes get fair CPU time.
    - *Example*: Prevent one infinite loop (`while(1)`) from blocking other apps.
3. **High-Priority Job Execution**: Critical tasks (e.g., antivirus) jump the queue.

<aside>
💡

In an operating system, starvation refers to **a situation where a process is indefinitely blocked from accessing a resource or executing due to other processes, often higher-priority processes, repeatedly using that resource**

**Key aspects of starvation in OS:**

- **Indefinite blocking:**
    
    Starvation is characterized by a process being blocked for an indefinite amount of time, waiting for a resource or CPU allocation.
    
- **Priority-based scheduling:**
    
    It often arises in priority-based scheduling systems where higher-priority processes are constantly favored, potentially neglecting lower-priority processes.
    
- **Resource contention:**
    
    Starvation occurs when multiple processes contend for the same resources, and one process is consistently overlooked.
    
- **Impact on progress:**
    
    Starvation prevents a process from making progress, as it is repeatedly denied access to the resources it needs.
    

**Solutions to mitigate starvation:**

- **Aging:**
    
    Periodically increasing the priority of long-waiting processes to ensure they eventually get a chance to execute.
    
- **Fair-sharing algorithms:**
    
    Implementing scheduling algorithms that allocate resources more fairly, preventing any process from being indefinitely blocked.
    
- **Resource ordering:**
    
    Designing systems where processes acquire resources in a specific order, reducing the likelihood of one process monopolizing access.
    
</aside>

---

## **2. Types of OS**

### **1. Single-Process OS**

**What?** Runs **one job at a time** (e.g., MS-DOS).

**Why?** Early hardware could only handle one task.

**Problems**:

- CPU sits idle during I/O.
- **Starvation**: Long jobs block others.
- No priority support.

---

### **2. Batch Processing OS**

![Batch Operating System](https://media.geeksforgeeks.org/wp-content/uploads/20230511130815/types1-(1).webp)

**What?** Groups similar jobs into **batches** (e.g., ATLAS).

**How?**

- Operator sorts jobs (e.g., by estimated runtime) → Submits batches sequentially.
    
    **Problems**:
    
- Still no CPU utilization during I/O.
- **Batch Starvation**: Long batches delay others.

**Analogy**:

- Like a teacher grading papers **batch by batch** (Math first, then Science).

---

### **3. Multiprogramming OS**

![MultiProgramming operating system](https://media.geeksforgeeks.org/wp-content/uploads/20230516182714/Types-of-OS-03-660.webp)

**What?** Runs **multiple jobs** in memory; switches when one waits for I/O.

**Key Concept**: **Context Switching**

- Saves current process state (in **PCB**) → Loads another.
- *Real-life Example*: Switching from Physics to Chemistry books (bookmarking each).

**Why Better?**

- CPU never idle during I/O.
    
    **Limitation**:
    
- No time limits → Long jobs can still hog CPU.

<aside>
💡

### Context Switching in OS

Context switching in an operating system (OS) **allows the CPU to rapidly switch between different processes, giving the illusion of simultaneous execution**. It involves saving the current state of one process and loading the state of another, enabling the OS to efficiently manage and utilize system resources.

**Here's a more detailed explanation:**

1. **1. Saving the State:**
    
    When the OS decides to switch to a different process, it first saves the current state of the running process. This includes information like:
    
    - The program counter (which indicates the next instruction to be executed).
    - The values of CPU registers.
    - Other process-specific data.
2. **2. Storing the State:**
    
    The saved process state is stored in a data structure called the Process Control Block (PCB). The PCB is a data structure that contains all the necessary information about a process, including its current state, memory allocation, and resources.
    
3. **3. Loading the New State:**
    
    The OS then selects the next process to run, typically based on a scheduling algorithm. It loads the PCB of the selected process into the CPU.
    
4. **4. Resuming Execution:**
    
    The CPU resumes execution from the point where the selected process was previously suspended. This happens because the program counter is loaded from the PCB, which points to the next instruction to be executed.
    

**Why is context switching important?**

- **Multitasking:** It enables the OS to effectively manage multiple processes concurrently.
- **Resource Sharing:** It allows different processes to share system resources, such as CPU time and memory.
- **Improved Responsiveness:** By switching between processes quickly, the OS can provide a more responsive user experience.

**Potential drawbacks:**

**Overhead:**

***OS Overhead**** refers to the **additional work and resources**** used by the **Operating System (OS)**** to manage and support the execution of programs, rather than the actual work done by the programs themselves.*

Frequent context switching can increase CPU overhead due to the time spent saving and restoring process states.

- **Cache Invalidation:**
    
    Switching between processes can lead to cache misses, which can impact performance.
    
- **Thrashing:**
    
    Excessive context switching can lead to a phenomenon called "thrashing," where the system spends more time switching between processes than actually executing them.
    

**Example:**

Imagine you're working on a word processor and you decide to open a web browser. The OS uses context switching to quickly switch between the word processor and the browser, allowing you to work on both applications simultaneously.

</aside>

---

### **4. Multitasking (Time-Sharing) OS**

![Types-of-OS-01](https://media.geeksforgeeks.org/wp-content/uploads/20230516183620/Types-of-OS-01.webp)

**What?** Adds **time quanta** (e.g., 100ms per job).

**How?**

- Forces context switch after each time slice.
- *Example*: CPU cycles between Chrome, Word, and Spotify.

**Why Best?**

✅ **Max CPU utilization** (no idle time).

✅ **No starvation** (every job gets turns).

✅ **Priority support** (e.g., antivirus interrupts).

**Used in**: Modern OS (Windows, Linux).

---

### **5. Multiprocessing OS**

![Multiprocessing operating system](https://media.geeksforgeeks.org/wp-content/uploads/20230516183450/Types-of-OS-02-660.webp)

**What?** Uses **multiple CPUs/cores**.

**How?**

- Jobs distributed across CPUs.
- *Example*: Gaming (CPU1: Physics, CPU2: AI).

**Advantages**:

- Higher speed + **reliability** (if one CPU fails, others work).

## 💡 What is a “Core” in a CPU?

A **core** is an **independent processing unit** inside a CPU.

Think of it like a **mini-CPU** — capable of executing its own instructions, threads, or processes.

> 🧠 So, a quad-core processor = 4 cores = can execute 4 tasks in parallel.
> 

---

## 🧵 Core vs Thread vs Process (Quick Comparison)

| Term | What it is | Example |
| --- | --- | --- |
| **Core** | Physical processing unit | Hardware: 4-core CPU |
| **Thread** | Lightweight execution unit | A browser tab, a game physics engine |
| **Process** | A program in execution | Chrome, VS Code |

---

## 🧠 Why Multiple Cores?

More cores = more **parallelism**, better **performance** — especially for multitasking or **multi-threaded programs**.

---

### **6. Distributed OS**

![Distributed OS](https://media.geeksforgeeks.org/wp-content/uploads/20230516183602/Types-of-OS-04.webp)

**What?** Manages **networked computers** (e.g., cloud systems).

**How?**

- Jobs split across machines (e.g., LeetCode executes code on remote servers).
    
    **Key Term**: **Loosely coupled** (independent but collaborative).
    

---

### **7. Real-Time OS (RTOS)**

![Real-Time Operating System](https://media.geeksforgeeks.org/wp-content/uploads/20230511145635/Types8.webp)

**What?** **Error-free, instant response** systems.

**Used in**:

- Air Traffic Control (ATC), Nuclear plants.
    
    **Why Critical?**
    
- Lives depend on **zero delays/errors**.

---

## **3. Key Concepts Simplified**

| Concept | What? | Example |
| --- | --- | --- |
| **Context Switching** | Saving/restoring process states | Bookmarking textbooks |
| **Time Quantum** | Fixed CPU time per job (e.g., 100ms) | Traffic light timers |
| **PCB** | Process Control Block (stores state) | Resume of a paused job |

---

## **4. Why Learn This?**

- **Interview Qs**: Differences between multitasking vs. multiprogramming.
- **Real-World**: Your phone uses **multitasking**; clouds use **distributed OS**.

---

## **5. Test Your Understanding**

1. **How does multitasking prevent starvation?**
2. **Why can’t RTOS tolerate delays?**
3. **What’s the role of a PCB?**

---

## **6. Homework**

Find examples for each OS type:

- Distributed OS: ?
- RTOS: ? *(Hint: Medical devices)*

### 1. **Distributed Operating System**

A Distributed OS manages a group of independent computers and makes them appear to the users as a single system.

**Example:**

- **Amoeba OS** — a research distributed OS that transparently manages a cluster of machines.
- **Google’s Borg** (not strictly an OS but a cluster management system acting like a distributed OS)
- **Apache Hadoop YARN** (resource manager in distributed systems)
- **Plan 9 from Bell Labs** — designed for distributed computing.

---

### 2. **Real-Time Operating System (RTOS)**

An RTOS is designed to serve real-time applications that process data as it comes in, typically without buffer delays.

**Example (Medical devices):**

- **VxWorks** — widely used RTOS in medical devices like MRI machines, pacemakers, and infusion pumps.
- **QNX** — another popular RTOS used in medical instrumentation and critical systems.
- **FreeRTOS** — used in embedded medical devices (like portable patient monitors).

---

### **Final Notes**

OS evolved to solve:

1. **Idle CPU** → **Multiprogramming**.
2. **Unfairness** → **Multitasking**.
3. **Hardware limits** → **Multiprocessing/Distributed**.