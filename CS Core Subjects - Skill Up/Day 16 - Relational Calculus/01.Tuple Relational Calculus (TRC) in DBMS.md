# Day 16 – Relational Calculus

---

## **1. Introduction to Relational Calculus**

### **What is Relational Calculus?**

Relational Calculus is a **non-procedural query language** used in DBMS to retrieve data by **specifying what data is required**, not **how to get it**.
It is based on **first-order predicate logic** and is used to express queries using logical formulas.

* It represents a **mathematical and declarative approach** to query formulation.
* It focuses on **conditions and properties** that the result tuples should satisfy.

### **Why Do We Need It?**

Relational Calculus provides the **theoretical foundation** for SQL and helps define **safe and declarative queries**.
It plays an important role in understanding **query optimization** and **formal database theory**.

### **Key Point**

* **Relational Algebra:** Describes *how* to obtain data.
* **Relational Calculus:** Describes *what* data to obtain.

---

## **2. Types of Relational Calculus**

There are **two forms** of Relational Calculus:

1. **Tuple Relational Calculus (TRC)** – Works with *tuples (rows)*.
2. **Domain Relational Calculus (DRC)** – Works with *domains (columns or attributes)*.

Both describe the same queries logically but use different notations.

---

## **3. Tuple Relational Calculus (TRC)**

### **Definition**

Tuple Relational Calculus is a **non-procedural query language** where queries describe the **properties of tuples (rows)** to be retrieved from a relation.

### **Syntax**

```
{ t | P(t) }
```

* `t`: Tuple variable (represents a row).
* `P(t)`: Predicate or condition that must be true for the tuple to be included.
* `{}`: Denotes the **set of tuples** satisfying the condition.

### **Logical Operators**

* **∧ (AND)** – Both conditions must hold true.
* **∨ (OR)** – At least one condition must hold true.
* **¬ (NOT)** – Negates a condition.

### **Quantifiers**

Used to express existence or universality:

* **∃ t ∈ r (Q(t))** → “There exists” a tuple t in relation r such that Q(t) holds true.
* **∀ t ∈ r (Q(t))** → “For all” tuples t in relation r, Q(t) must hold true.

---

## **4. Example to Understand TRC**

Consider the **Employees** table:

| EmployeeID | Name | Salary | DepartmentID |
| ---------- | ---- | ------ | ------------ |
| 1          | Alex | 60000  | D1           |
| 2          | Sam  | 40000  | D2           |
| 3          | Ryan | 80000  | D1           |

### **Query:**

Find names of employees earning more than 50,000.

**TRC Expression:**

```
{ t | Employees(t) ∧ t.Salary > 50000 }
```

**Explanation:**

* `Employees(t)` means t is a tuple from the Employees table.
* The condition `t.Salary > 50000` filters only those tuples with Salary > 50000.
* The result will include only those tuples where this condition holds.

**Output:**

| Name |
| ---- |
| Alex |
| Ryan |

---

## **5. Detailed Example Using Banking Schema**

### **Tables**

**Customer**

| Customer_Name | Street | City      |
| ------------- | ------ | --------- |
| Saurabh       | A7     | Patiala   |
| Mehak         | B6     | Jalandhar |
| Sumiti        | D9     | Ludhiana  |
| Ria           | A5     | Patiala   |

**Branch**

| Branch_Name | Branch_City |
| ----------- | ----------- |
| ABC         | Patiala     |
| DEF         | Ludhiana    |
| GHI         | Jalandhar   |

**Account**

| Account_No | Branch_Name | Balance |
| ---------- | ----------- | ------- |
| 1111       | ABC         | 50000   |
| 1112       | DEF         | 10000   |
| 1113       | GHI         | 9000    |
| 1114       | ABC         | 7000    |

**Loan**

| Loan_No | Branch_Name | Amount |
| ------- | ----------- | ------ |
| L33     | ABC         | 10000  |
| L35     | DEF         | 15000  |
| L49     | GHI         | 9000   |
| L98     | DEF         | 65000  |

**Borrower**

| Customer_Name | Loan_No |
| ------------- | ------- |
| Saurabh       | L33     |
| Mehak         | L49     |
| Ria           | L98     |

**Depositor**

| Customer_Name | Account_No |
| ------------- | ---------- |
| Saurabh       | 1111       |
| Mehak         | 1113       |
| Suniti        | 1114       |

---

### **Example 1:**

Find the loan number, branch, and amount for all loans greater than or equal to 10,000.

**TRC Query:**

```
{ t | t ∈ Loan ∧ t.Amount ≥ 10000 }
```

**Output:**

| Loan_No | Branch_Name | Amount |
| ------- | ----------- | ------ |
| L33     | ABC         | 10000  |
| L35     | DEF         | 15000  |
| L98     | DEF         | 65000  |

---

### **Example 2:**

Find the loan number for each loan amount greater than or equal to 10,000.

**TRC Query:**

```
{ t | ∃ s ∈ Loan (t.Loan_No = s.Loan_No ∧ s.Amount ≥ 10000) }
```

**Output:**

| Loan_No |
| ------- |
| L33     |
| L35     |
| L98     |

---

### **Example 3:**

Find names of customers who have **both a loan and an account**.

**TRC Query:**

```
{ t | ∃ s ∈ Borrower (t.Customer_Name = s.Customer_Name)
     ∧ ∃ u ∈ Depositor (t.Customer_Name = u.Customer_Name) }
```

**Output:**

| Customer_Name |
| ------------- |
| Saurabh       |
| Mehak         |

---

### **Example 4:**

Find the names of all customers having a loan at the "ABC" branch.

**TRC Query:**

```
{ t | ∃ s ∈ Borrower (t.Customer_Name = s.Customer_Name
     ∧ ∃ u ∈ Loan (u.Branch_Name = "ABC" ∧ u.Loan_No = s.Loan_No)) }
```

**Output:**

| Customer_Name |
| ------------- |
| Saurabh       |

---

## **6. Key Concepts in TRC**

| Concept                   | Description                                                       |
| ------------------------- | ----------------------------------------------------------------- |
| **Tuple Variable (t)**    | Represents a row in the table                                     |
| **Predicate (P(t))**      | Logical condition that must hold true                             |
| **Quantifiers (∃, ∀)**    | Describe existence or universality                                |
| **Non-Procedural Nature** | Describes *what* data is needed, not *how* to get it              |
| **Domain Independence**   | Safe queries return results independent of the actual domain size |

---

## **7. Domain Relational Calculus (DRC)**

### **Definition**

Domain Relational Calculus works on **domains (attributes)** rather than entire tuples.
It lists the **values of attributes** that satisfy a condition.

### **Syntax**

```
{ <a1, a2, a3, ... , an> | P(a1, a2, a3, ... , an) }
```

* `a1, a2, ... an` are **attribute variables** (column values).
* `P` is the **condition or predicate** describing relationships among attributes.

### **Example**

Find customer names living in “Patiala”:

```
{ <cname> | ∃ s ∈ Customer (s.City = "Patiala" ∧ cname = s.Customer_Name) }
```

**Output:**

| Customer_Name |
| ------------- |
| Saurabh       |
| Ria           |

---

## **8. Comparison: TRC vs Relational Algebra**

| Feature       | Tuple Relational Calculus           | Relational Algebra              |
| ------------- | ----------------------------------- | ------------------------------- |
| Type          | Non-Procedural                      | Procedural                      |
| Focus         | Describes what to retrieve          | Describes how to retrieve       |
| Basis         | Logical expressions                 | Set and relational operators    |
| Output        | Set of tuples satisfying conditions | Relation obtained through steps |
| Practical Use | Theoretical, conceptual             | Used for actual query execution |

---

## **9. Why & How Relational Calculus Solves Problems**

| Problem                 | How Relational Calculus Solves It                  |
| ----------------------- | -------------------------------------------------- |
| Procedural complexity   | Eliminates need for specifying query steps         |
| Query safety            | Restricts to domain-independent queries            |
| Logical precision       | Defines queries using exact mathematical logic     |
| Theoretical consistency | Provides foundation for SQL and query optimization |

---

## **10. Key Takeaways**

* Relational Calculus is **declarative**, not procedural.
* **TRC** deals with *tuples*, **DRC** deals with *attributes/domains*.
* Queries specify **conditions**, not operations.
* Uses **predicate logic** and **quantifiers** to define results.
* **Safe queries** (domain-independent) are guaranteed to return finite, meaningful results.
* It’s fundamental in **database theory**, **SQL design**, and **GATE-level concepts**.

---