# High-Level Design (HLD) and Low-Level Design (LLD) in System Design - Complete Guide

High-Level Design (HLD) and Low-Level Design (LLD) are critical phases in system design, providing the architectural blueprint and detailed implementation plans, respectively. HLD focuses on the macro-level structure, while LLD translates it into specific classes, methods, and algorithms. This guide covers the definitions, components, differences, steps, examples, benefits, and best practices for both HLD and LLD, with a focus on their roles in building scalable, efficient systems.

![](https://imgs.search.brave.com/GTAUUoixOPpbbQdcNDvJrQdwOIMdxbGR2kVISqwvBJw/rs:fit:860:0:0:0/g:ce/aHR0cHM6Ly9tZWRp/YS5saWNkbi5jb20v/ZG1zL2ltYWdlL0Q0/RDEyQVFITGQwU1dC/ZWdwSVEvYXJ0aWNs/ZS1jb3Zlcl9pbWFn/ZS1zaHJpbmtfNzIw/XzEyODAvMC8xNjg5/ODI3Mjg2NTM0P2U9/MjE0NzQ4MzY0NyZ2/PWJldGEmdD1WSWU0/djUyOUN4R1BIcF8z/blkzMmQyS3VEeFdQ/ajd2SWJxdW9Tb19k/UUpz)

## What is High-Level Design (HLD)?

*sample high level design of a cab booking service like Uber*

![](https://media.geeksforgeeks.org/wp-content/cdn-uploads/20201120210648/Uber-System-Design-High-Level-Architecture.png)

HLD is the initial step in application development, defining the overall system structure and interactions between components at a macro level. It serves as a blueprint for stakeholders (developers, architects, product managers) to align on project objectives, ensuring effective communication without delving into implementation details.

**Key Features**:
- **Focus**: System architecture, technology stack, component interactions.
- **Scope**: Defines “what the system will do” (functional and non-functional aspects).
- **Purpose**: Ensures stakeholder alignment, guides development, and supports scalability and maintainability.
- **Examples**: Choosing MySQL or MongoDB, REST or GraphQL, service communication protocols.

**Analogy**:
- HLD is like an architect’s building plan, outlining the structure, rooms, and materials without specifying how each brick is laid.

## Components of High-Level Design

1. **System Architecture**:
   - Provides an overview of the system’s structure and component relationships.
   - Example: A cab booking system with mobile app, backend APIs, and database.

2. **Modules and Components**:
   - Breaks the system into functional modules with specific roles.
   - Example: User management, ride booking, and payment processing modules.

3. **Data Flow Diagrams (DFDs)**:
   - Illustrates data movement between components.
   - Example: Data flow from user app to payment service in a booking system.

4. **Interface Design**:
   - Defines APIs for system integration and user interfaces (UIs) for interaction.
   - Example: REST APIs for ride requests, UI for ride tracking.

5. **Technology Stack**:
   - Specifies programming languages, frameworks, and databases.
   - Example: Node.js backend, React Native app, MongoDB database.

6. **Deployment Architecture**:
   - Outlines hosting, server configurations, and cloud infrastructure.
   - Example: AWS EC2 servers, load balancers, and VPC setup.

## What is High-Level Design Document?

The HLD document includes:
- Data flows, flowcharts, and data structures to clarify system functionality.
- Descriptions of hardware, software, and user interfaces.
- Workflow and performance specifications for each module.
- Logic for component interactions based on functional requirements.

**Purpose**:
- Provides a technical representation of functional and non-functional requirements.
- Ensures modules interact effectively to meet business goals.

## What is Low-Level Design (LLD)?

LLD is the detailed blueprint for developers, translating HLD into specific classes, methods, data structures, algorithms, and interactions. It focuses on **how** each component is implemented, using object-oriented principles and design patterns.

**Key Features**:
- **Focus**: Detailed class designs, method implementations, and algorithms.
- **Scope**: Defines “how each part will be implemented.”
- **Examples**: Defining `User` or `Order` classes, login flow logic, sorting algorithms.
- **Tools**: UML diagrams (class, sequence, activity), SOLID principles, design patterns.

**Analogy**:
- LLD is like a contractor’s detailed construction plan, specifying how each wall, door, and fixture is built based on the architect’s blueprint.

## Components of Low-Level Design

1. **Classes**:
   - Define entities (e.g., `User`, `Order`) with attributes and methods.
   - Example: A `User` class with `name` and `placeOrder` method.

2. **Methods**:
   - Specify operations within classes (e.g., `addItem`, `getTotal`).
   - Example: `Order.getTotal()` calculates the sum of item prices.

3. **Data Structures**:
   - Choose structures like arrays, lists, or hash maps for efficiency.
   - Example: Use a vector to store `MenuItem` objects in an `Order`.

4. **Interactions**:
   - Define how objects communicate, often via UML diagrams.
   - Example: A sequence diagram showing `User` placing an `Order`.

5. **Design Patterns**:
   - Apply patterns like Singleton, Factory, or Strategy for reusable solutions.
   - Example: Use Strategy pattern for payment processing.

## HLD vs. LLD: Comparison

| **Feature**  | **High-Level Design (HLD)**                          | **Low-Level Design (LLD)**                          |
|--------------|----------------------------------------------------|---------------------------------------------------|
| **Focus**    | Architecture, tech stack, components                | Classes, methods, interactions                    |
| **Scope**    | “What the system will do”                          | “How each part will be implemented”               |
| **Examples** | Database: MySQL or MongoDB? <br> REST or GraphQL?  | Define `User`, `Order` classes <br> Login flow    |
| **Diagrams** | Block diagrams, architecture diagrams              | UML class, sequence, activity diagrams            |
| **Stakeholders** | Architects, product managers, developers         | Developers, testers                              |

## Steps to Create High-Level Design

1. **Define System Goals**:
   - Align with business and functional requirements.
   - Example: A cab booking system aims for real-time ride tracking.

2. **Choose Architecture**:
   - Select monolithic, microservices, or serverless based on needs.
   - Example: Use microservices for scalability in a booking system.

3. **Identify Modules**:
   - Break down into components like user management, ride booking.
   - Example: Modules for ride requests, payments, and notifications.

4. **Design Data Flow**:
   - Create DFDs to show data movement between components.
   - Example: Data flow from app to payment gateway.

5. **Select Technology Stack**:
   - Choose languages, frameworks, and databases.
   - Example: Node.js, MongoDB, AWS for a booking system.

6. **Plan Deployment**:
   - Define cloud infrastructure, servers, and load balancers.
   - Example: Deploy on AWS with ELB for load balancing.

## Steps to Create Low-Level Design

1. **Understand OOP Principles**:
   - Apply encapsulation, inheritance, polymorphism, and abstraction.
   - Example: Encapsulate `Order` data to prevent direct access.

2. **Analyze and Break Down Components**:
   - Identify entities (e.g., `User`, `Order`) and their relationships.
   - Example: Define composition between `Order` and `MenuItem`.

3. **Use Design Patterns**:
   - Apply creational (Singleton, Factory), structural (Adapter), or behavioral (Observer) patterns.
   - Example: Use Factory pattern to create payment methods.

4. **Create UML Diagrams**:
   - Use class, sequence, activity, state, or use case diagrams.
   - Example: A class diagram showing `User` and `Order` relationships.

5. **Follow SOLID Principles**:
   - Ensure single responsibility, open/closed, Liskov substitution, interface segregation, and dependency inversion.
   - Example: Separate `Payment` logic into distinct classes.

## Example: Online Food Delivery System

### HLD (Big Picture)
- **Components**: Mobile app, backend APIs, MySQL database, third-party payment service.
- **Architecture**: Microservices for modularity and scalability.
- **Data Flow**: User app → API → database → payment gateway.
- **Technology Stack**: Node.js, React Native, MySQL, AWS.
- **Deployment**: AWS EC2 with load balancers and auto-scaling.

### LLD (Detailed)
- **Entities**:
  - `User`: Manages user data and actions (e.g., placing orders).
  - `Restaurant`: Contains `MenuItem` objects.
  - `MenuItem`: Represents food items with name and price.
  - `Order`: Contains `MenuItem` objects and calculates total.
  - `Payment`: Handles payment processing (Strategy pattern).

- **UML Class Diagram (Simplified)**:
  ```
  User -------- places --------> Order -------- contains --------> MenuItem
   |                                  |
   |                                  v
   |                             Payment (Strategy Pattern)
   |
   v
  Restaurant (has MenuItems)
  ```

- **Implementation Example (C++ from User Notes)**:
  ```cpp
  #include <iostream>
  #include <vector>
  #include <string>
  using namespace std;

  class MenuItem {
      string name;
      double price;
  public:
      MenuItem(string n, double p) : name(n), price(p) {}
      string getName() const { return name; }
      double getPrice() const { return price; }
  };

  class Order {
      vector<MenuItem> items;
  public:
      void addItem(const MenuItem& item) {
          items.push_back(item);
      }
      double getTotal() const {
          double total = 0;
          for (auto& i : items) total += i.getPrice();
          return total;
      }
      void showOrder() const {
          cout << "Order contains:\n";
          for (auto& i : items) cout << "- " << i.getName() << " : $" << i.getPrice() << endl;
          cout << "Total: $" << getTotal() << endl;
      }
  };

  class User {
      string name;
  public:
      User(string n) : name(n) {}
      void placeOrder(Order& order) {
          cout << name << " placed an order.\n";
          order.showOrder();
      }
  };

  int main() {
      User u("Alice");
      Order o;
      o.addItem(MenuItem("Burger", 5.99));
      o.addItem(MenuItem("Fries", 2.99));
      u.placeOrder(o);
      return 0;
  }
  ```
  **Output**:
  ```
  Alice placed an order.
  Order contains:
  - Burger : $5.99
  - Fries : $2.99
  Total: $8.98
  ```

## Roadmap to Design Scalable HLD Systems

1. **Capacity Estimation**:
   - Predict resource needs (processing, memory, bandwidth) to handle workload.
   - Example: Estimate Twitter’s server capacity to deliver tweets to millions.

2. **HTTP and HTTPS**:
   - Use HTTP for data transfer, HTTPS for secure communication.
   - Methods: GET, POST, PUT.
   - Example: Use HTTPS for secure API calls in a cab booking system.

3. **WebSockets**:
   - Enable real-time, full-duplex communication for low-latency apps (e.g., chat, gaming).
   - Example: WebSocket for real-time ride updates in Uber.

4. **Polling**:
   - **Short Polling**: Client requests data at fixed intervals.
   - **Long Polling**: Server waits for new data before responding.
   - Example: Long polling for notification updates to reduce requests.

5. **Server-Sent Events (SSE)**:
   - One-way server-to-client communication for real-time updates over HTTP.
   - Example: SSE for streaming stock prices in a trading app.

6. **Rate Limiting**:
   - Restrict request rates to prevent overload.
   - Example: Limit API calls to 1000/hour per user in a booking system.

7. **Resiliency**:
   - Ensure fault tolerance through replication, redundancy, and availability.
   - Example: Replicate database across zones to handle server failures.

8. **Paging**:
   - Divide large datasets into pages for better performance and user experience.
   - Example: Paginate restaurant listings in a delivery app.

9. **Logging**:
   - Record events (e.g., transactions, microservices) for debugging and monitoring.
   - Approaches: Centralized logging, distributed logging, cloud-based logging.
   - Example: Use AWS CloudWatch for logging API requests.

## HLD Roadmap

1. **Basics of HLD**:
   - Understand HLD vs. LLD, goals of HLD.

2. **Core Components**:
   - Load Balancer, CDN, Caching, API Gateway, Message Queues, Consistent Hashing, Communication/Network Protocols.

3. **Design Principles**:
   - Scalability, availability, consistency, reliability, fault tolerance, CAP theorem, performance optimization.

4. **Types of HLD Diagrams**:
   - Component-based, sequence, DFD, deployment diagrams.

5. **Architectures and Patterns**:
   - Monolithic, Microservices, Event-Driven, Client-Server, Peer-to-Peer, Serverless, Circuit Breaker, Event Sourcing, CQRS.

6. **Interview Preparation**:
   - Study common HLD questions and system design strategies.

## Benefits of HLD

- **Stakeholder Alignment**: Ensures clear communication of system goals.
- **Scalability**: Designs systems to handle growth (e.g., Twitter’s tweet delivery).
- **Maintainability**: Modular components ease updates and debugging.
- **Performance**: Optimizes resource allocation and data flow.

## Benefits of LLD

- **Clear Implementation Plan**: Guides developers on what to code.
- **Easier Debugging**: Modular designs simplify issue identification.
- **Faster Development**: Predefined classes and methods speed up coding.
- **Maintainable Code**: SOLID principles and patterns ensure clean code.

## Best Practices for HLD

1. **Align with Requirements**:
   - Map HLD to functional and non-functional requirements.
   - Example: Ensure a cab booking system supports real-time tracking.

2. **Choose Scalable Architectures**:
   - Prefer microservices or serverless for high-traffic systems.
   - Example: Use microservices for a delivery app’s scalability.

3. **Optimize Data Flow**:
   - Design efficient DFDs to minimize bottlenecks.
   - Example: Streamline data flow from app to database.

4. **Incorporate Resiliency**:
   - Use replication and redundancy for fault tolerance.
   - Example: Deploy across multiple AWS zones.

5. **Document Clearly**:
   - Include diagrams and specifications in the HLD document.
   - Example: Use DFDs to show ride booking data flow.

## Best Practices for LLD

1. **Design Modular Components**:
   - Break down entities into independent classes.
   - Example: Separate `User` and `Order` classes.

2. **Use Interfaces and Abstractions**:
   - Promote flexibility and maintainability.
   - Example: Define a `Payment` interface for multiple payment methods.

3. **Prefer Composition Over Inheritance**:
   - Enhance flexibility and reduce tight coupling.
   - Example: Use composition for `Order` containing `MenuItem`.

4. **Apply Error Handling**:
   - Validate inputs and handle exceptions in methods.
   - Example: Check for invalid menu items in `Order.addItem`.

5. **Create UML Diagrams First**:
   - Visualize interactions before coding.
   - Example: Draw a sequence diagram for order placement.

## Summary

- **High-Level Design (HLD)**:
  - **Focus**: Macro-level system structure, components, and interactions.
  - **Components**: System architecture, modules, DFDs, interfaces, technology stack, deployment.
  - **Purpose**: Aligns stakeholders, ensures scalability and maintainability.
  - **Example**: A cab booking system with microservices, MySQL, and AWS.

- **Low-Level Design (LLD)**:
  - **Focus**: Detailed implementation of classes, methods, and algorithms.
  - **Components**: Classes, methods, data structures, interactions, design patterns.
  - **Purpose**: Provides a developer blueprint for clean, maintainable code.
  - **Example**: `User`, `Order`, `MenuItem` classes with UML and SOLID principles.

- **Key Differences**: HLD defines “what” (architecture), LLD defines “how” (implementation).
- **Scalability in HLD**: Achieved through capacity estimation, WebSockets, polling, SSE, rate limiting, resiliency, paging, and logging (e.g., caching in the roadmap).
- **Benefits**: HLD ensures stakeholder alignment and scalability; LLD enables clear, maintainable coding.
- **When to Use**:
  - HLD: Early planning to define system structure and goals.
  - LLD: Detailed implementation phase to guide coding.

HLD and LLD together form the backbone of system design, ensuring systems are scalable, maintainable, and aligned with business needs, with HLD providing the vision and LLD executing it.

