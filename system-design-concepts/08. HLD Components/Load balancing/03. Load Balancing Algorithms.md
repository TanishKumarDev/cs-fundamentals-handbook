# Load Balancing Algorithms in System Design - Complete Guide

Load balancing algorithms are critical for distributing traffic across servers in a network to prevent any single server from becoming overloaded, ensuring high performance, scalability, and availability. These algorithms can be categorized into **static** and **dynamic** types, each suited to different scenarios. This guide covers the types, implementations, use cases, benefits, and drawbacks of various load balancing algorithms.

![](https://media.geeksforgeeks.org/wp-content/uploads/20240130183244/llba.webp)

## Overview of Load Balancing Algorithms

**Purpose**:
- Distribute incoming traffic to ensure no server is overwhelmed.
- Enhance system performance, scalability, and reliability in applications with high user traffic.

**Categories**:
1. **Static Load Balancing**: Uses predetermined rules to assign tasks without considering real-time system conditions.
2. **Dynamic Load Balancing**: Adapts to real-time server conditions (e.g., load, response time) for traffic distribution.

**Analogy**:
- Load balancing is like distributing tasks among team members. Static algorithms assign tasks based on a fixed plan, while dynamic algorithms consider who is least busy at the moment.

## Static Load Balancing Algorithms

Static algorithms assign tasks based on fixed rules, ignoring real-time server conditions.

### 1. Round Robin Load Balancing Algorithm

![](https://media.geeksforgeeks.org/wp-content/uploads/20240130183312/Round-Robin-(1).webp)
**Description**:
- Distributes requests sequentially across servers in a circular order.
- Simple and fair but doesn’t account for server load or capacity.

**Analogy**:
- Sharing candies equally among friends in a circle, giving one to each friend in turn, regardless of their appetite.

**Implementation (JavaScript)**:
```javascript
class LoadBalancer {
    constructor(servers) {
        this.servers = servers;
        this.currentIndex = 0;
    }

    getNextServer() {
        const nextServer = this.servers[this.currentIndex];
        this.currentIndex = (this.currentIndex + 1) % this.servers.length;
        return nextServer;
    }
}

// Example Usage
const servers = ["Server1", "Server2", "Server3"];
const loadBalancer = new LoadBalancer(servers);

for (let i = 0; i < 10; i++) {
    console.log(`Request ${i + 1}: Routed to ${loadBalancer.getNextServer()}`);
}
```

**Output**:
```
Request 1: Routed to Server1
Request 2: Routed to Server2
Request 3: Routed to Server3
Request 4: Routed to Server1
Request 5: Routed to Server2
Request 6: Routed to Server3
Request 7: Routed to Server1
...
```

**Explanation**:
- **Class Structure**: Maintains a list of servers and a current index to track the next server.
- **Method**: `getNextServer` returns the next server in sequence and updates the index cyclically.
- **Usage**: Simulates requests by cycling through servers.

**When to Use**:
- Applications with similar server capacities and predictable workloads (e.g., basic web requests).
- Simple environments where balanced distribution is sufficient.

**Benefits**:
- **Simplicity**: Easy to implement and understand.
- **Fairness**: Ensures equal request distribution across servers.

**Drawbacks**:
- **Unequal Capacities**: Ignores varying server capacities, risking overload.
- **Predictability**: Suboptimal for heterogeneous servers.

### 2. Weighted Round Robin Load Balancing Algorithm

![](https://media.geeksforgeeks.org/wp-content/uploads/20240130183429/Weighted-Round-Robin-(1).webp)
**Description**:
- Extends Round Robin by assigning weights to servers based on their capacity.
- Servers with higher weights receive more requests proportionally.
- Cyclic distribution, but weighted to reflect server capabilities.

**Analogy**:
- Giving more candies to friends who can eat more, ensuring those with bigger appetites get a larger share.

**Example**:
- Servers: Server1 (weight 0.3), Server2 (weight 0.2), Server3 (weight 0.1).
- Total weight: 0.6.
- Distribution: Server1 (50%), Server2 (33.33%), Server3 (16.67%).

**Implementation (JavaScript)**:
```javascript
class Server {
    constructor(name, weight) {
        this.name = name;
        this.weight = weight;
    }
}

class WeightedRoundRobinBalancer {
    constructor(servers) {
        this.servers = servers;
        this.totalWeight = this.calculateTotalWeight();
        this.cumulativeWeights = this.calculateCumulativeWeights();
        this.currentIndex = 0;
    }

    calculateTotalWeight() {
        return this.servers.reduce((sum, server) => sum + server.weight, 0);
    }

    calculateCumulativeWeights() {
        const cumulativeWeights = [];
        cumulativeWeights[0] = this.servers[0].weight;
        for (let i = 1; i < this.servers.length; i++) {
            cumulativeWeights[i] = cumulativeWeights[i - 1] + this.servers[i].weight;
        }
        return cumulativeWeights;
    }

    getNextServer() {
        const randomValue = Math.floor(Math.random() * this.totalWeight);
        for (let i = 0; i < this.cumulativeWeights.length; i++) {
            if (randomValue < this.cumulativeWeights[i]) {
                this.currentIndex = i;
                break;
            }
        }
        return this.servers[this.currentIndex];
    }
}

// Example Usage
const servers = [
    new Server("Server1", 3),
    new Server("Server2", 2),
    new Server("Server3", 1)
];
const balancer = new WeightedRoundRobinBalancer(servers);

for (let i = 0; i < 10; i++) {
    const nextServer = balancer.getNextServer();
    console.log(`Request ${i + 1}: Routed to ${nextServer.name}`);
}
```

**Output (Sample)**:
```
Request 1: Routed to Server1
Request 2: Routed to Server2
Request 3: Routed to Server2
Request 4: Routed to Server3
Request 5: Routed to Server1
Request 6: Routed to Server3
Request 7: Routed to Server1
...
```

**Explanation**:
- **Server Class**: Stores server name and weight.
- **Balancer Class**: Calculates total and cumulative weights, selects servers based on weighted probability.
- **Method**: `getNextServer` uses a random value within the total weight to pick a server proportional to its weight.
- **Usage**: Simulates requests with weighted distribution.

**When to Use**:
- Environments with servers of varying capacities (e.g., different CPU/memory).
- Applications needing to maximize resource utilization.

**Benefits**:
- **Capacity Consideration**: Accounts for server differences via weights.
- **Flexibility**: Adjusts to varying workloads effectively.

**Drawbacks**:
- **Complexity**: More complex than Round Robin due to weight calculations.
- **Maintenance**: Requires updating weights when server capacities change.

### 3. Source IP Hash Load Balancing Algorithm
![](https://media.geeksforgeeks.org/wp-content/uploads/20240130183502/Source-IP-hash--(1).webp)

**Description**:
- Distributes requests based on the hash of the client’s source IP address.
- Ensures requests from the same IP consistently go to the same server, supporting session persistence.

**Analogy**:
- Assigning the same toy to a friend each time they visit, based on their name, to maintain consistency.

**Implementation (JavaScript)**:
```javascript
class SourceIpHashLoadBalancer {
    constructor() {
        this.ipToServerMap = new Map();
    }

    addServer(serverName) {
        this.ipToServerMap.set(serverName, serverName);
    }

    getServerForIp(sourceIp) {
        // Simple hash function for IP
        let hash = 0;
        for (let i = 0; i < sourceIp.length; i++) {
            hash = (hash << 5) - hash + sourceIp.charCodeAt(i);
            hash |= 0;
        }
        hash = Math.abs(hash);

        const servers = Array.from(this.ipToServerMap.keys());
        const serverIndex = hash % servers.length;
        return servers[serverIndex];
    }
}

// Example Usage
const loadBalancer = new SourceIpHashLoadBalancer();
loadBalancer.addServer("Server1");
loadBalancer.addServer("Server2");
loadBalancer.addServer("Server3");

const sourceIps = ["192.168.1.1", "10.0.0.1", "172.16.0.1"];
for (const sourceIp of sourceIps) {
    const selectedServer = loadBalancer.getServerForIp(sourceIp);
    console.log(`Request from ${sourceIp} routed to ${selectedServer}`);
}
```

**Output**:
```
Request from 192.168.1.1 routed to Server2
Request from 10.0.0.1 routed to Server3
Request from 172.16.0.1 routed to Server1
```

**Explanation**:
- **Class Structure**: Uses a `Map` to store servers.
- **Method**: `getServerForIp` hashes the source IP and maps it to a server using modulo.
- **Usage**: Ensures consistent routing for the same IP.

**When to Use**:
- Applications requiring session persistence (e.g., online banking, shopping carts).
- Scenarios where specific IPs should connect to dedicated servers (e.g., for compliance or performance).

**Benefits**:
- **Consistency**: Same IP always routes to the same server, maintaining session state.
- **Predictability**: Useful for applications needing connection persistence.

**Drawbacks**:
- **Limited Distribution**: Uneven load if some IPs generate more traffic.
- **Scaling Challenges**: Adding/removing servers may disrupt session persistence.

## Dynamic Load Balancing Algorithms

Dynamic algorithms adapt to real-time server conditions, such as load or response time, for optimal traffic distribution.

### 1. Least Connection Load Balancing Algorithm

![](https://media.geeksforgeeks.org/wp-content/uploads/20240130183529/Least-Connection-(1).webp)
**Description**:
- Routes new requests to the server with the fewest active connections.
- Balances workload by considering current server load.

**Analogy**:
- Joining the playground swing with the fewest kids to avoid crowding.

**Implementation (JavaScript)**:
```javascript
class LeastConnectionLoadBalancer {
    constructor() {
        this.serverConnections = new Map();
    }

    addServer(serverName) {
        this.serverConnections.set(serverName, 0);
    }

    getServerWithLeastConnections() {
        let minConnections = Number.MAX_SAFE_INTEGER;
        let selectedServer = "";

        for (const [server, connections] of this.serverConnections) {
            if (connections < minConnections) {
                minConnections = connections;
                selectedServer = server;
            }
        }

        if (selectedServer) {
            this.serverConnections.set(selectedServer, minConnections + 1);
        }

        return selectedServer;
    }
}

// Example Usage
const loadBalancer = new LeastConnectionLoadBalancer();
loadBalancer.addServer("Server1");
loadBalancer.addServer("Server2");
loadBalancer.addServer("Server3");

for (let i = 0; i < 10; i++) {
    const selectedServer = loadBalancer.getServerWithLeastConnections();
    console.log(`Request ${i + 1}: Routed to ${selectedServer}`);
}
```

**Output**:
```
Request 1: Routed to Server1
Request 2: Routed to Server2
Request 3: Routed to Server3
Request 4: Routed to Server1
Request 5: Routed to Server2
Request 6: Routed to Server3
Request 7: Routed to Server1
...
```

**Explanation**:
- **Class Structure**: Tracks active connections per server in a `Map`.
- **Method**: `getServerWithLeastConnections` selects the server with the fewest connections and increments its count.
- **Usage**: Simulates requests, prioritizing servers with fewer active connections.

**When to Use**:
- Applications with variable request durations (e.g., video streaming, file uploads).
- Systems with fluctuating traffic needing real-time load balancing.

**Benefits**:
- **Balanced Load**: Prevents overloading by routing to less busy servers.
- **Dynamic**: Adapts to current server workloads.

**Drawbacks**:
- **Ignored Capacities**: Doesn’t account for server capacity differences.
- **Sticky Sessions**: May not support session persistence.

### 2. Least Response Time Load Balancing Algorithm
![](https://media.geeksforgeeks.org/wp-content/uploads/20240130183553/Least-Response-(2).webp)

**Description**:
- Directs requests to the server with the lowest historical response time.
- Optimizes for faster processing by considering past performance.

**Analogy**:
- Choosing the fastest server at a snack bar to get food quickly.

**Implementation (JavaScript)**:
```javascript
class LeastResponseLoadBalancer {
    constructor() {
        this.serverResponseTimes = new Map();
    }

    addServer(serverName) {
        this.serverResponseTimes.set(serverName, 0);
    }

    getServerWithLeastResponseTime() {
        let minResponseTime = Number.MAX_SAFE_INTEGER;
        let selectedServer = "";

        for (const [server, responseTime] of this.serverResponseTimes) {
            if (responseTime < minResponseTime) {
                minResponseTime = responseTime;
                selectedServer = server;
            }
        }

        if (selectedServer) {
            this.serverResponseTimes.set(selectedServer, minResponseTime + 1);
        }

        return selectedServer;
    }
}

// Example Usage
const loadBalancer = new LeastResponseLoadBalancer();
loadBalancer.addServer("Server1");
loadBalancer.addServer("Server2");
loadBalancer.addServer("Server3");

for (let i = 0; i < 10; i++) {
    const selectedServer = loadBalancer.getServerWithLeastResponseTime();
    console.log(`Request ${i + 1}: Routed to ${selectedServer}`);
}
```

**Output**:
```
Request 1: Routed to Server1
Request 2: Routed to Server2
Request 3: Routed to Server3
Request 4: Routed to Server1
Request 5: Routed to Server2
Request 6: Routed to Server3
Request 7: Routed to Server1
...
```

**Explanation**:
- **Class Structure**: Tracks accumulated response times per server.
- **Method**: `getServerWithLeastResponseTime` selects the server with the lowest response time and increments it.
- **Usage**: Simulates requests, prioritizing faster-responding servers.

**When to Use**:
- Applications with heavy, fluctuating traffic (e.g., e-commerce, streaming).
- Systems where response time is critical for user experience.

**Benefits**:
- **Optimized Performance**: Routes to servers with faster response times.
- **Adaptable**: Adjusts to changing server responsiveness.

**Drawbacks**:
- **Historical Bias**: Past response times may not reflect current capabilities.
- **Complex Implementation**: Requires tracking response times.

### 3. Resource-Based Load Balancing Algorithm

**Description**:
- Distributes requests based on real-time server resource availability (e.g., CPU, memory, bandwidth).
- Routes to the server with the most available resources.

**Analogy**:
- Assigning office tasks to the least busy employee based on their current workload.

**Implementation (JavaScript)**:
```javascript
class Server {
    constructor(name) {
        this.name = name;
        this.cpuLoad = 0.0;
    }

    updateCpuLoad(load) {
        this.cpuLoad = load;
    }

    getCpuLoad() {
        return this.cpuLoad;
    }

    getName() {
        return this.name;
    }
}

class ResourceBasedLoadBalancer {
    constructor() {
        this.servers = new Map();
    }

    addServer(server) {
        this.servers.set(server.getName(), server);
    }

    getServerWithMostResources() {
        let lowestLoad = Number.MAX_SAFE_INTEGER;
        let bestServer = null;

        for (const server of this.servers.values()) {
            if (server.getCpuLoad() < lowestLoad) {
                lowestLoad = server.getCpuLoad();
                bestServer = server;
            }
        }

        return bestServer ? bestServer.getName() : "";
    }

    handleRequest() {
        const bestServer = this.getServerWithMostResources();
        if (bestServer) {
            console.log(`Routing request to server: ${bestServer} with current CPU load: ${this.servers.get(bestServer).getCpuLoad()}%`);
        } else {
            console.log("No servers available.");
        }
    }
}

// Example Usage
const loadBalancer = new ResourceBasedLoadBalancer();
const server1 = new Server("Server1");
const server2 = new Server("Server2");
const server3 = new Server("Server3");

loadBalancer.addServer(server1);
loadBalancer.addServer(server2);
loadBalancer.addServer(server3);

server1.updateCpuLoad(30.0);
server2.updateCpuLoad(50.0);
server3.updateCpuLoad(20.0);

loadBalancer.handleRequest();
```

**Output**:
```
Routing request to server: Server3 with current CPU load: 20%
```

**Explanation**:
- **Server Class**: Tracks server name and CPU load, with methods to update and retrieve load.
- **Balancer Class**: Manages servers, selects the one with the lowest CPU load.
- **Method**: `handleRequest` routes to the server with the most available resources.
- **Usage**: Simulates routing based on CPU load.

**When to Use**:
- Applications with CPU-intensive or memory-heavy tasks.
- Systems with heterogeneous servers, adapting to real-time resource availability.

**Benefits**:
- **Resource Optimization**: Balances based on real-time resource data.
- **Adaptability**: Adjusts to current server states.

**Drawbacks**:
- **Complex Implementation**: Requires continuous resource monitoring.
- **Higher Overhead**: Tracking resources adds computational cost.

## Static vs. Dynamic Load Balancing

| **Aspect**                | **Static Load Balancing**                          | **Dynamic Load Balancing**                         |
|---------------------------|---------------------------------------------------|---------------------------------------------------|
| **Basis**                 | Fixed rules (e.g., sequence, weights, IP hash).   | Real-time server conditions (e.g., connections, response time, resources). |
| **Adaptability**          | No adaptation to runtime changes.                 | Adapts to changing server states.                  |
| **Complexity**            | Simpler to implement and manage.                  | More complex due to real-time monitoring.          |
| **Use Case**              | Predictable workloads, similar servers.           | Fluctuating traffic, heterogeneous servers.        |

**When to Use**:
- **Static**: Predictable environments with consistent workloads (e.g., simple web apps).
- **Dynamic**: High-traffic, dynamic environments (e.g., streaming, e-commerce).

## Best Practices for Load Balancing Algorithms

1. **Choose the Right Algorithm**:
   - Use Round Robin for simple, uniform servers; Weighted Round Robin for varied capacities; Source IP Hash for session persistence; Least Connection/Response Time for fluctuating traffic; Resource-Based for resource-intensive tasks.
   - Example: Use Least Response Time for an e-commerce site during a sale.

2. **Monitor Server Health**:
   - Integrate health checks to avoid routing to failed servers.
   - Example: Check server response times every 5 seconds.

3. **Support Scalability**:
   - Pair with auto-scaling to dynamically adjust server count.
   - Example: Add servers during traffic spikes using AWS Auto Scaling.

4. **Ensure Session Persistence**:
   - Use Source IP Hash or session stores (e.g., Redis) for apps needing continuity.
   - Example: Maintain shopping cart sessions with Source IP Hash.

5. **Minimize Overhead**:
   - Optimize algorithms to reduce computational cost (e.g., efficient hash functions).
   - Example: Use a lightweight hash for Source IP Hash.

6. **Test Under Load**:
   - Simulate high traffic to ensure the algorithm handles spikes effectively.
   - Example: Stress-test with 10,000 concurrent requests.

## Summary

Load balancing algorithms are essential for distributing traffic across servers to ensure performance, scalability, and availability.

- **Static Algorithms**:
  - **Round Robin**: Simple, sequential distribution; best for uniform servers.
  - **Weighted Round Robin**: Weighted distribution for varied server capacities.
  - **Source IP Hash**: Consistent routing based on client IP for session persistence.
- **Dynamic Algorithms**:
  - **Least Connection**: Routes to servers with fewest active connections.
  - **Least Response Time**: Routes to servers with fastest historical response times.
  - **Resource-Based**: Routes based on real-time resource availability (e.g., CPU load).
- **Benefits**: Improved performance, scalability, balanced load, session consistency.
- **Drawbacks**: Complexity, overhead, potential uneven distribution in static methods.
- **Applications**: Web applications, e-commerce, streaming services, cloud systems.

**When to Use Load Balancing Algorithms**:
- Systems with multiple servers handling high traffic.
- Applications requiring scalability, fault tolerance, or session persistence.
- Environments with varying server capacities or workloads.

**When to Avoid Load Balancing Algorithms**:
- Single-server systems with low traffic.
- Applications where algorithm overhead outweighs benefits.
- Scenarios with no need for dynamic scaling or session consistency.

Load balancing algorithms are critical for modern system design, enabling efficient traffic management tailored to application needs.

