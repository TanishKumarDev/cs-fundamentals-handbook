# Database Normalization Notes

## Introduction to Normalization
- **Purpose**: Normalization is a process to organize data in a database to minimize redundancy and avoid anomalies (insertion, deletion, update issues).
- **Key Goal**: Ensure no data anomalies when inserting, updating, or deleting records. Decompose tables into smaller, related tables while preserving data integrity.
- **Why Important?**: Unnormalized data leads to:
  - **Insertion Anomaly**: Can't add new data without unrelated info (e.g., can't add a new student branch without student details).
  - **Deletion Anomaly**: Deleting one record removes unrelated data (e.g., deleting a student removes branch info).
  - **Update Anomaly**: Changing data requires updates in multiple places (e.g., updating a department name affects all students in that department).

## Functional Dependencies (FD)
- **Definition**: A relationship where one or more attributes (determinant) uniquely determine another attribute(s). Notation: A → B (A determines B).
  - If you know A, you can find B.
- **Example**:
  - Table: Employee (EmpID, Name, Dept, DeptName).
  - FD: EmpID → Name (EmpID determines Name).
  - FD: Dept → DeptName (Dept determines DeptName).
- **Types**:
  - **Trivial FD**: Determinant includes the dependent attribute (e.g., {A, B} → B). Always true, no issue.
  - **Non-Trivial FD**: Determinant does not include the dependent attribute (e.g., A → B).
- **Partial Dependency**: Non-key attribute depends on part of a composite primary key.
- **Transitive Dependency**: Non-key attribute depends on another non-key attribute (e.g., A → B, B → C implies A → C transitively).

### Example Table for FD
| EmpID | Name    | Dept | DeptName    |
|-------|---------|------|-------------|
| 101   | Alice   | IT   | Information Technology |
| 102   | Bob     | ME   | Mechanical Engineering |

- FDs: EmpID → Name; Dept → DeptName.
- If update DeptName for "IT", must change in all rows → Update Anomaly.

## Normal Forms (NF)
Normalization progresses through forms (1NF → 2NF → 3NF). Decompose tables until each satisfies the rules.

### 1st Normal Form (1NF)
- **Rule**: All attributes must be atomic (no repeating groups or arrays). Each row-column intersection holds a single value. Table must have a primary key.
- **Issues Addressed**: Eliminates repeating data.
- **Example** (Unnormalized):
  | StudentID | Name | Courses          |
  |-----------|------|------------------|
  | 1         | Alice| Math, Physics   |
  
  **Normalized to 1NF** (Split repeating groups):
  | StudentID | Name  | Course |
  |-----------|-------|--------|
  | 1         | Alice | Math   |
  | 1         | Alice | Physics|

- **Process**: Replace multi-valued attributes with separate rows.

### 2nd Normal Form (2NF)
- **Rule**: Must be in 1NF + No partial dependencies (non-prime attributes fully depend on entire primary key, not part of it).
- **Applies to**: Tables with composite primary keys.
- **Example** (1NF but violates 2NF):
  | StudentID | ProjectID | StudentName | ProjectName |
  |-----------|-----------|-------------|-------------|
  | 1         | 101       | Alice       | DB Project  |
  | 1         | 102       | Alice       | AI Project  |

  - Primary Key: {StudentID, ProjectID}.
  - Partial Dependency: StudentID → StudentName (depends only on part of PK).
  - ProjectID → ProjectName (depends only on part of PK).

  **Decompose to 2NF**:
  - **Table 1: Students** (PK: StudentID)
    | StudentID | StudentName |
    |-----------|-------------|
    | 1         | Alice       |

  - **Table 2: Projects** (PK: ProjectID)
    | ProjectID | ProjectName |
    |-----------|-------------|
    | 101       | DB Project  |

  - **Table 3: StudentProjects** (PK: {StudentID, ProjectID})
    | StudentID | ProjectID |
    |-----------|-----------|
    | 1         | 101       |

- **Benefits**: Reduces redundancy; updates to StudentName only in one place.

### 3rd Normal Form (3NF)
- **Rule**: Must be in 2NF + No transitive dependencies (non-prime attributes depend only on primary key, not other non-prime attributes).
- **Example** (2NF but violates 3NF):
  | StudentID | StudentName | BranchCode | BranchName      |
  |-----------|-------------|------------|-----------------|
  | 1         | Alice       | IT         | Information Tech|
  | 2         | Bob         | ME         | Mechanical Eng  |

  - Primary Key: StudentID.
  - Transitive Dependency: StudentID → BranchCode → BranchName.

  **Decompose to 3NF**:
  - **Table 1: Students** (PK: StudentID)
    | StudentID | StudentName | BranchCode |
    |-----------|-------------|------------|
    | 1         | Alice       | IT         |

  - **Table 2: Branches** (PK: BranchCode)
    | BranchCode | BranchName      |
    |------------|-----------------|
    | IT         | Information Tech|

- **Benefits**: Eliminates transitive issues; update BranchName in one place.

## General Normalization Process
1. Identify FDs in the relation.
2. Check for violations (partial/transitive dependencies).
3. Decompose into smaller relations.
4. Ensure lossless decomposition (can reconstruct original without data loss).
5. Continue until 3NF (or higher if needed; higher forms like BCNF are advanced).

## Additional Concepts
- **Primary Key**: Unique identifier for rows.
- **Candidate Key**: Potential primary key.
- **Superkey**: Set of attributes that uniquely identifies a row.
- **Decomposition**: Splitting tables while preserving dependencies.
- **Real-World Application**: Used in relational databases (e.g., MySQL, PostgreSQL) to design efficient schemas.

## Key Takeaways
- Normalization reduces anomalies but may increase join operations (trade-off for query performance).
- Always start with business rules to identify FDs.
- Practice: Analyze sample tables, find FDs, and normalize step-by-step.